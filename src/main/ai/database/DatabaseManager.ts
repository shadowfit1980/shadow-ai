/**
 * Database Manager
 * 
 * Unified support for Prisma, MongoDB, PostgreSQL, MySQL,
 * and Firebase Data Connect.
 */

import { EventEmitter } from 'events';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

// ============================================================================
// TYPES
// ============================================================================

export type DatabaseType = 'prisma' | 'mongodb' | 'postgresql' | 'mysql' | 'firebase' | 'sqlite';

export interface DatabaseConfig {
    type: DatabaseType;
    connectionString?: string;
    host?: string;
    port?: number;
    database?: string;
    username?: string;
    password?: string;
}

export interface DatabaseConnection {
    id: string;
    type: DatabaseType;
    name: string;
    status: 'connected' | 'disconnected' | 'error';
    config: DatabaseConfig;
}

export interface SchemaModel {
    name: string;
    fields: Array<{
        name: string;
        type: string;
        required: boolean;
        unique?: boolean;
        default?: any;
    }>;
    relations?: Array<{
        name: string;
        type: string;
        model: string;
    }>;
}

// ============================================================================
// DATABASE MANAGER
// ============================================================================

export class DatabaseManager extends EventEmitter {
    private static instance: DatabaseManager;
    private connections: Map<string, DatabaseConnection> = new Map();

    private constructor() {
        super();
    }

    static getInstance(): DatabaseManager {
        if (!DatabaseManager.instance) {
            DatabaseManager.instance = new DatabaseManager();
        }
        return DatabaseManager.instance;
    }

    // ========================================================================
    // PRISMA
    // ========================================================================

    /**
     * Initialize Prisma in a project
     */
    async initPrisma(projectPath: string, database: 'postgresql' | 'mysql' | 'sqlite' | 'mongodb' = 'postgresql'): Promise<void> {
        await execAsync(`npx prisma init --datasource-provider ${database}`, { cwd: projectPath });
        this.emit('prisma:initialized', { projectPath, database });
    }

    /**
     * Generate Prisma schema from models
     */
    async generatePrismaSchema(models: SchemaModel[], database: DatabaseType = 'postgresql'): Promise<string> {
        let schema = `// Prisma Schema
// Generated by Shadow AI

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${database === 'mongodb' ? 'mongodb' : database}"
  url      = env("DATABASE_URL")
}

`;

        for (const model of models) {
            schema += `model ${model.name} {\n`;

            // Add id field if not present
            if (!model.fields.some(f => f.name === 'id')) {
                if (database === 'mongodb') {
                    schema += `  id String @id @default(auto()) @map("_id") @db.ObjectId\n`;
                } else {
                    schema += `  id Int @id @default(autoincrement())\n`;
                }
            }

            for (const field of model.fields) {
                const optional = field.required ? '' : '?';
                const unique = field.unique ? ' @unique' : '';
                const defaultVal = field.default !== undefined ? ` @default(${field.default})` : '';
                schema += `  ${field.name} ${field.type}${optional}${unique}${defaultVal}\n`;
            }

            // Timestamps
            schema += `  createdAt DateTime @default(now())\n`;
            schema += `  updatedAt DateTime @updatedAt\n`;

            // Relations
            if (model.relations) {
                for (const rel of model.relations) {
                    schema += `  ${rel.name} ${rel.model}${rel.type === 'many' ? '[]' : ''}\n`;
                }
            }

            schema += `}\n\n`;
        }

        return schema;
    }

    /**
     * Run Prisma migrations
     */
    async runPrismaMigration(projectPath: string, name: string): Promise<void> {
        await execAsync(`npx prisma migrate dev --name ${name}`, { cwd: projectPath });
        this.emit('prisma:migrated', { projectPath, name });
    }

    /**
     * Generate Prisma Client
     */
    async generatePrismaClient(projectPath: string): Promise<void> {
        await execAsync('npx prisma generate', { cwd: projectPath });
        this.emit('prisma:generated', { projectPath });
    }

    // ========================================================================
    // MONGODB
    // ========================================================================

    /**
     * Generate MongoDB connection code
     */
    generateMongoDBConnection(connectionString: string): string {
        return `import { MongoClient } from 'mongodb';

const uri = "${connectionString}";
const client = new MongoClient(uri);

let db: any = null;

export async function connectToDatabase() {
  if (db) return db;
  
  await client.connect();
  db = client.db();
  console.log('Connected to MongoDB');
  
  return db;
}

export async function getCollection(name: string) {
  const database = await connectToDatabase();
  return database.collection(name);
}
`;
    }

    /**
     * Generate MongoDB model
     */
    generateMongoDBModel(model: SchemaModel): string {
        return `import { ObjectId } from 'mongodb';
import { getCollection } from './database';

export interface ${model.name} {
  _id?: ObjectId;
${model.fields.map(f => `  ${f.name}${f.required ? '' : '?'}: ${this.toTsType(f.type)};`).join('\n')}
  createdAt?: Date;
  updatedAt?: Date;
}

const COLLECTION = '${model.name.toLowerCase()}s';

export const ${model.name}Model = {
  async create(data: Omit<${model.name}, '_id' | 'createdAt' | 'updatedAt'>) {
    const collection = await getCollection(COLLECTION);
    const result = await collection.insertOne({
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
    return result;
  },

  async findById(id: string) {
    const collection = await getCollection(COLLECTION);
    return collection.findOne({ _id: new ObjectId(id) });
  },

  async findAll(filter = {}) {
    const collection = await getCollection(COLLECTION);
    return collection.find(filter).toArray();
  },

  async update(id: string, data: Partial<${model.name}>) {
    const collection = await getCollection(COLLECTION);
    return collection.updateOne(
      { _id: new ObjectId(id) },
      { $set: { ...data, updatedAt: new Date() } }
    );
  },

  async delete(id: string) {
    const collection = await getCollection(COLLECTION);
    return collection.deleteOne({ _id: new ObjectId(id) });
  },
};
`;
    }

    // ========================================================================
    // POSTGRESQL / MYSQL
    // ========================================================================

    /**
     * Generate SQL migration
     */
    generateSQLMigration(models: SchemaModel[], dialect: 'postgresql' | 'mysql' = 'postgresql'): string {
        let sql = `-- Migration generated by Shadow AI\n-- Dialect: ${dialect}\n\n`;

        for (const model of models) {
            const tableName = model.name.toLowerCase() + 's';
            sql += `CREATE TABLE IF NOT EXISTS ${tableName} (\n`;

            // ID
            if (dialect === 'postgresql') {
                sql += `  id SERIAL PRIMARY KEY,\n`;
            } else {
                sql += `  id INT AUTO_INCREMENT PRIMARY KEY,\n`;
            }

            // Fields
            for (const field of model.fields) {
                const sqlType = this.toSQLType(field.type, dialect);
                const nullable = field.required ? 'NOT NULL' : '';
                const unique = field.unique ? 'UNIQUE' : '';
                const defaultVal = field.default !== undefined ? `DEFAULT ${field.default}` : '';
                sql += `  ${field.name} ${sqlType} ${nullable} ${unique} ${defaultVal},\n`.replace(/\s+,/g, ',');
            }

            // Timestamps
            if (dialect === 'postgresql') {
                sql += `  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n`;
                sql += `  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n`;
            } else {
                sql += `  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n`;
                sql += `  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n`;
            }

            sql += `);\n\n`;
        }

        return sql;
    }

    // ========================================================================
    // FIREBASE DATA CONNECT
    // ========================================================================

    /**
     * Generate Firebase Data Connect schema
     */
    generateFirebaseSchema(models: SchemaModel[]): string {
        let schema = `# Firebase Data Connect Schema
# Generated by Shadow AI

`;

        for (const model of models) {
            schema += `type ${model.name} @table {\n`;
            schema += `  id: ID! @default(expr: "uuidV4()")\n`;

            for (const field of model.fields) {
                const gqlType = this.toGraphQLType(field.type);
                const required = field.required ? '!' : '';
                schema += `  ${field.name}: ${gqlType}${required}\n`;
            }

            schema += `  createdAt: DateTime! @default(expr: "now()")\n`;
            schema += `  updatedAt: DateTime!\n`;
            schema += `}\n\n`;
        }

        return schema;
    }

    /**
     * Initialize Firebase Data Connect
     */
    async initFirebaseDataConnect(projectPath: string): Promise<void> {
        await execAsync('firebase init dataconnect', { cwd: projectPath });
        this.emit('firebase:initialized', { projectPath });
    }

    // ========================================================================
    // UTILITIES
    // ========================================================================

    private toTsType(type: string): string {
        const map: Record<string, string> = {
            'String': 'string',
            'Int': 'number',
            'Float': 'number',
            'Boolean': 'boolean',
            'DateTime': 'Date',
            'Json': 'any',
        };
        return map[type] || type;
    }

    private toSQLType(type: string, dialect: 'postgresql' | 'mysql'): string {
        const pgMap: Record<string, string> = {
            'String': 'VARCHAR(255)',
            'Int': 'INTEGER',
            'Float': 'DECIMAL(10,2)',
            'Boolean': 'BOOLEAN',
            'DateTime': 'TIMESTAMP',
            'Json': 'JSONB',
            'Text': 'TEXT',
        };
        const mysqlMap: Record<string, string> = {
            'String': 'VARCHAR(255)',
            'Int': 'INT',
            'Float': 'DECIMAL(10,2)',
            'Boolean': 'TINYINT(1)',
            'DateTime': 'DATETIME',
            'Json': 'JSON',
            'Text': 'TEXT',
        };
        return dialect === 'postgresql' ? (pgMap[type] || 'VARCHAR(255)') : (mysqlMap[type] || 'VARCHAR(255)');
    }

    private toGraphQLType(type: string): string {
        const map: Record<string, string> = {
            'String': 'String',
            'Int': 'Int',
            'Float': 'Float',
            'Boolean': 'Boolean',
            'DateTime': 'DateTime',
            'Json': 'JSON',
        };
        return map[type] || 'String';
    }

    /**
     * Test database connection
     */
    async testConnection(config: DatabaseConfig): Promise<boolean> {
        try {
            switch (config.type) {
                case 'postgresql':
                    await execAsync(`psql "${config.connectionString}" -c "SELECT 1"`);
                    break;
                case 'mysql':
                    await execAsync(`mysql -h ${config.host} -u ${config.username} -p${config.password} -e "SELECT 1"`);
                    break;
                case 'mongodb':
                    await execAsync(`mongosh "${config.connectionString}" --eval "db.runCommand({ping: 1})"`);
                    break;
                default:
                    return true;
            }
            return true;
        } catch {
            return false;
        }
    }

    /**
     * Get connections
     */
    getConnections(): DatabaseConnection[] {
        return Array.from(this.connections.values());
    }
}

// Export singleton
export const databaseManager = DatabaseManager.getInstance();
