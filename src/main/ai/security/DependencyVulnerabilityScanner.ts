/**
 * Dependency Vulnerability Scanner
 * Scan and report security vulnerabilities in dependencies
 * Grok Recommendation: Security Vulnerability Detection
 */
import { EventEmitter } from 'events';
import * as crypto from 'crypto';

interface Vulnerability {
    id: string;
    cve?: string;
    ghsa?: string;
    title: string;
    description: string;
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    cvssScore?: number;
    package: string;
    affectedVersions: string;
    patchedVersions?: string;
    recommendation: string;
    references: string[];
    publishedAt: Date;
    updatedAt: Date;
}

interface Dependency {
    name: string;
    version: string;
    type: 'direct' | 'transitive';
    scope: 'production' | 'development' | 'optional';
    dependencies: string[];
    vulnerabilities: Vulnerability[];
    license: string;
    outdated: boolean;
    latestVersion?: string;
}

interface ScanResult {
    id: string;
    projectName: string;
    scannedAt: Date;
    duration: number;
    totalDependencies: number;
    vulnerableDependencies: number;
    vulnerabilities: Vulnerability[];
    summary: VulnerabilitySummary;
    dependencies: Dependency[];
    recommendations: string[];
}

interface VulnerabilitySummary {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
    fixable: number;
    score: number;
}

interface VulnerabilityDatabase {
    packages: Map<string, KnownVulnerability[]>;
    lastUpdated: Date;
}

interface KnownVulnerability {
    id: string;
    package: string;
    affectedRange: string;
    patchedVersion?: string;
    severity: Vulnerability['severity'];
    title: string;
    description: string;
    cve?: string;
}

export class DependencyVulnerabilityScanner extends EventEmitter {
    private static instance: DependencyVulnerabilityScanner;
    private database: VulnerabilityDatabase;
    private scanHistory: ScanResult[] = [];

    private constructor() {
        super();
        this.database = this.initializeDatabase();
    }

    static getInstance(): DependencyVulnerabilityScanner {
        if (!DependencyVulnerabilityScanner.instance) {
            DependencyVulnerabilityScanner.instance = new DependencyVulnerabilityScanner();
        }
        return DependencyVulnerabilityScanner.instance;
    }

    private initializeDatabase(): VulnerabilityDatabase {
        const packages = new Map<string, KnownVulnerability[]>();

        // Common vulnerabilities database (simplified)
        const knownVulns: KnownVulnerability[] = [
            { id: 'VULN-001', package: 'lodash', affectedRange: '<4.17.21', patchedVersion: '4.17.21', severity: 'high', title: 'Prototype Pollution', description: 'Lodash versions before 4.17.21 are vulnerable to prototype pollution.', cve: 'CVE-2021-23337' },
            { id: 'VULN-002', package: 'axios', affectedRange: '<0.21.1', patchedVersion: '0.21.1', severity: 'medium', title: 'SSRF Vulnerability', description: 'Server-side request forgery in axios.', cve: 'CVE-2020-28168' },
            { id: 'VULN-003', package: 'express', affectedRange: '<4.17.3', patchedVersion: '4.17.3', severity: 'medium', title: 'Open Redirect', description: 'Express vulnerable to open redirect.', cve: 'CVE-2022-24999' },
            { id: 'VULN-004', package: 'minimist', affectedRange: '<1.2.6', patchedVersion: '1.2.6', severity: 'critical', title: 'Prototype Pollution', description: 'Minimist before 1.2.6 is vulnerable to prototype pollution.', cve: 'CVE-2021-44906' },
            { id: 'VULN-005', package: 'node-fetch', affectedRange: '<2.6.7', patchedVersion: '2.6.7', severity: 'high', title: 'Exposure of Sensitive Info', description: 'Node-fetch may expose authorization headers.', cve: 'CVE-2022-0235' },
            { id: 'VULN-006', package: 'jsonwebtoken', affectedRange: '<9.0.0', patchedVersion: '9.0.0', severity: 'high', title: 'Algorithm Confusion', description: 'JWT algorithm confusion vulnerability.', cve: 'CVE-2022-23529' },
            { id: 'VULN-007', package: 'moment', affectedRange: '<2.29.4', patchedVersion: '2.29.4', severity: 'high', title: 'ReDoS', description: 'Regular expression denial of service.', cve: 'CVE-2022-31129' },
            { id: 'VULN-008', package: 'shell-quote', affectedRange: '<1.7.3', patchedVersion: '1.7.3', severity: 'critical', title: 'Command Injection', description: 'Improper neutralization of special elements.', cve: 'CVE-2021-42740' },
            { id: 'VULN-009', package: 'tar', affectedRange: '<6.1.11', patchedVersion: '6.1.11', severity: 'high', title: 'Arbitrary File Write', description: 'Tar vulnerable to arbitrary file write.', cve: 'CVE-2021-37701' },
            { id: 'VULN-010', package: 'ansi-regex', affectedRange: '<6.0.1', patchedVersion: '6.0.1', severity: 'high', title: 'ReDoS', description: 'Regular expression denial of service.', cve: 'CVE-2021-3807' }
        ];

        for (const vuln of knownVulns) {
            if (!packages.has(vuln.package)) {
                packages.set(vuln.package, []);
            }
            packages.get(vuln.package)!.push(vuln);
        }

        return { packages, lastUpdated: new Date() };
    }

    async scanPackageJson(packageJson: { dependencies?: Record<string, string>; devDependencies?: Record<string, string>; name?: string }): Promise<ScanResult> {
        const startTime = Date.now();
        const dependencies: Dependency[] = [];
        const allVulnerabilities: Vulnerability[] = [];

        // Scan production dependencies
        if (packageJson.dependencies) {
            for (const [name, version] of Object.entries(packageJson.dependencies)) {
                const dep = this.scanDependency(name, version, 'production');
                dependencies.push(dep);
                allVulnerabilities.push(...dep.vulnerabilities);
            }
        }

        // Scan dev dependencies
        if (packageJson.devDependencies) {
            for (const [name, version] of Object.entries(packageJson.devDependencies)) {
                const dep = this.scanDependency(name, version, 'development');
                dependencies.push(dep);
                allVulnerabilities.push(...dep.vulnerabilities);
            }
        }

        const summary = this.calculateSummary(allVulnerabilities);
        const recommendations = this.generateRecommendations(allVulnerabilities, dependencies);

        const result: ScanResult = {
            id: crypto.randomUUID(),
            projectName: packageJson.name || 'Unknown',
            scannedAt: new Date(),
            duration: Date.now() - startTime,
            totalDependencies: dependencies.length,
            vulnerableDependencies: dependencies.filter(d => d.vulnerabilities.length > 0).length,
            vulnerabilities: allVulnerabilities,
            summary,
            dependencies,
            recommendations
        };

        this.scanHistory.push(result);
        this.emit('scanComplete', result);

        return result;
    }

    private scanDependency(name: string, versionSpec: string, scope: Dependency['scope']): Dependency {
        const version = versionSpec.replace(/^[\^~>=<]/, '');
        const knownVulns = this.database.packages.get(name) || [];
        const vulnerabilities: Vulnerability[] = [];

        for (const vuln of knownVulns) {
            if (this.isVersionAffected(version, vuln.affectedRange)) {
                vulnerabilities.push({
                    id: vuln.id,
                    cve: vuln.cve,
                    title: vuln.title,
                    description: vuln.description,
                    severity: vuln.severity,
                    package: name,
                    affectedVersions: vuln.affectedRange,
                    patchedVersions: vuln.patchedVersion,
                    recommendation: vuln.patchedVersion
                        ? `Upgrade to ${vuln.patchedVersion} or later`
                        : 'Consider alternative package',
                    references: vuln.cve ? [`https://nvd.nist.gov/vuln/detail/${vuln.cve}`] : [],
                    publishedAt: new Date(),
                    updatedAt: new Date()
                });
            }
        }

        return {
            name,
            version,
            type: 'direct',
            scope,
            dependencies: [],
            vulnerabilities,
            license: 'MIT',
            outdated: vulnerabilities.length > 0,
            latestVersion: knownVulns.length > 0 ? knownVulns[0].patchedVersion : undefined
        };
    }

    private isVersionAffected(version: string, affectedRange: string): boolean {
        // Simplified version check
        const match = affectedRange.match(/^<(.+)$/);
        if (match) {
            return this.compareVersions(version, match[1]) < 0;
        }
        return false;
    }

    private compareVersions(v1: string, v2: string): number {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);

        for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
            const p1 = parts1[i] || 0;
            const p2 = parts2[i] || 0;
            if (p1 < p2) return -1;
            if (p1 > p2) return 1;
        }
        return 0;
    }

    private calculateSummary(vulnerabilities: Vulnerability[]): VulnerabilitySummary {
        const summary: VulnerabilitySummary = {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            info: 0,
            total: vulnerabilities.length,
            fixable: 0,
            score: 100
        };

        for (const vuln of vulnerabilities) {
            summary[vuln.severity]++;
            if (vuln.patchedVersions) summary.fixable++;
        }

        // Calculate security score
        summary.score = Math.max(0, 100 -
            (summary.critical * 25) -
            (summary.high * 15) -
            (summary.medium * 7) -
            (summary.low * 2) -
            (summary.info * 0.5)
        );

        return summary;
    }

    private generateRecommendations(vulnerabilities: Vulnerability[], dependencies: Dependency[]): string[] {
        const recommendations: string[] = [];

        const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
        const highVulns = vulnerabilities.filter(v => v.severity === 'high');

        if (criticalVulns.length > 0) {
            recommendations.push(`ðŸš¨ CRITICAL: ${criticalVulns.length} critical vulnerabilities require immediate attention.`);
            for (const vuln of criticalVulns.slice(0, 3)) {
                recommendations.push(`  - ${vuln.package}: ${vuln.recommendation}`);
            }
        }

        if (highVulns.length > 0) {
            recommendations.push(`âš ï¸ HIGH: ${highVulns.length} high severity vulnerabilities found.`);
        }

        const fixable = vulnerabilities.filter(v => v.patchedVersions);
        if (fixable.length > 0) {
            recommendations.push(`âœ… ${fixable.length} vulnerabilities can be fixed by updating packages.`);
        }

        const outdated = dependencies.filter(d => d.outdated);
        if (outdated.length > 5) {
            recommendations.push(`ðŸ“¦ ${outdated.length} packages are outdated. Consider running npm update.`);
        }

        if (recommendations.length === 0) {
            recommendations.push('âœ¨ No vulnerabilities found! Your dependencies are secure.');
        }

        return recommendations;
    }

    generateReport(scanId: string, format: 'text' | 'json' | 'html' | 'markdown' = 'markdown'): string {
        const scan = this.scanHistory.find(s => s.id === scanId);
        if (!scan) return '';

        switch (format) {
            case 'json':
                return JSON.stringify(scan, null, 2);

            case 'markdown':
                return this.generateMarkdownReport(scan);

            case 'html':
                return this.generateHTMLReport(scan);

            default:
                return this.generateTextReport(scan);
        }
    }

    private generateMarkdownReport(scan: ScanResult): string {
        const lines: string[] = [
            `# Security Scan Report`,
            '',
            `**Project:** ${scan.projectName}`,
            `**Scanned:** ${scan.scannedAt.toISOString()}`,
            `**Duration:** ${scan.duration}ms`,
            '',
            `## Summary`,
            '',
            `| Severity | Count |`,
            `|----------|-------|`,
            `| ðŸ”´ Critical | ${scan.summary.critical} |`,
            `| ðŸŸ  High | ${scan.summary.high} |`,
            `| ðŸŸ¡ Medium | ${scan.summary.medium} |`,
            `| ðŸŸ¢ Low | ${scan.summary.low} |`,
            `| ðŸ”µ Info | ${scan.summary.info} |`,
            '',
            `**Security Score:** ${scan.summary.score}/100`,
            `**Fixable:** ${scan.summary.fixable}/${scan.summary.total}`,
            '',
            `## Recommendations`,
            ''
        ];

        for (const rec of scan.recommendations) {
            lines.push(`- ${rec}`);
        }

        if (scan.vulnerabilities.length > 0) {
            lines.push('', `## Vulnerabilities`, '');
            for (const vuln of scan.vulnerabilities) {
                lines.push(`### ${vuln.title}`);
                lines.push(`- **Package:** ${vuln.package}`);
                lines.push(`- **Severity:** ${vuln.severity.toUpperCase()}`);
                lines.push(`- **CVE:** ${vuln.cve || 'N/A'}`);
                lines.push(`- **Fix:** ${vuln.recommendation}`);
                lines.push('');
            }
        }

        return lines.join('\n');
    }

    private generateHTMLReport(scan: ScanResult): string {
        const severityColors = { critical: '#dc2626', high: '#ea580c', medium: '#ca8a04', low: '#16a34a', info: '#2563eb' };

        return `<!DOCTYPE html>
<html><head><title>Security Scan - ${scan.projectName}</title>
<style>
body { font-family: system-ui; background: #0f172a; color: #e2e8f0; padding: 40px; }
.card { background: #1e293b; border-radius: 8px; padding: 20px; margin: 20px 0; }
.critical { border-left: 4px solid ${severityColors.critical}; }
.high { border-left: 4px solid ${severityColors.high}; }
.medium { border-left: 4px solid ${severityColors.medium}; }
.low { border-left: 4px solid ${severityColors.low}; }
.score { font-size: 48px; color: ${scan.summary.score > 70 ? '#22c55e' : scan.summary.score > 40 ? '#eab308' : '#ef4444'}; }
</style></head><body>
<h1>Security Scan Report</h1>
<p>Project: ${scan.projectName} | Scanned: ${scan.scannedAt.toISOString()}</p>
<div class="card"><div class="score">${scan.summary.score}/100</div><p>Security Score</p></div>
${scan.vulnerabilities.map(v => `<div class="card ${v.severity}"><strong>${v.title}</strong><br>${v.package} - ${v.recommendation}</div>`).join('')}
</body></html>`;
    }

    private generateTextReport(scan: ScanResult): string {
        const lines = [
            `Security Scan Report - ${scan.projectName}`,
            `${'='.repeat(50)}`,
            `Score: ${scan.summary.score}/100`,
            `Critical: ${scan.summary.critical} | High: ${scan.summary.high} | Medium: ${scan.summary.medium} | Low: ${scan.summary.low}`,
            '',
            'Recommendations:',
            ...scan.recommendations.map(r => `  ${r}`),
            ''
        ];
        return lines.join('\n');
    }

    getScanHistory(): ScanResult[] {
        return [...this.scanHistory];
    }

    getLatestScan(): ScanResult | undefined {
        return this.scanHistory[this.scanHistory.length - 1];
    }

    getDatabaseStats(): { packages: number; vulnerabilities: number; lastUpdated: Date } {
        let totalVulns = 0;
        for (const vulns of this.database.packages.values()) {
            totalVulns += vulns.length;
        }
        return {
            packages: this.database.packages.size,
            vulnerabilities: totalVulns,
            lastUpdated: this.database.lastUpdated
        };
    }
}

export const dependencyVulnerabilityScanner = DependencyVulnerabilityScanner.getInstance();
