/**
 * ðŸ”— APIClientGenerator
 * 
 * API client generation:
 * - REST, GraphQL, typed clients
 */

import { EventEmitter } from 'events';

export class APIClientGenerator extends EventEmitter {
    private static instance: APIClientGenerator;
    private constructor() { super(); }
    static getInstance(): APIClientGenerator {
        if (!APIClientGenerator.instance) {
            APIClientGenerator.instance = new APIClientGenerator();
        }
        return APIClientGenerator.instance;
    }

    generate(): string {
        return `// API Client Generator - REST, GraphQL, typed clients
// Generated by Shadow AI

// Type-safe API Client
class APIClient {
    private baseUrl: string;
    private headers: Record<string, string>;
    
    constructor(baseUrl: string, options?: { headers?: Record<string, string> }) {
        this.baseUrl = baseUrl;
        this.headers = { 'Content-Type': 'application/json', ...options?.headers };
    }
    
    async get<T>(path: string, params?: Record<string, any>): Promise<T> {
        const url = new URL(path, this.baseUrl);
        if (params) {
            Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
        }
        
        const response = await fetch(url.toString(), { headers: this.headers });
        if (!response.ok) throw new APIError(response.status, await response.text());
        return response.json();
    }
    
    async post<T>(path: string, body?: any): Promise<T> {
        const response = await fetch(new URL(path, this.baseUrl).toString(), {
            method: 'POST',
            headers: this.headers,
            body: body ? JSON.stringify(body) : undefined
        });
        if (!response.ok) throw new APIError(response.status, await response.text());
        return response.json();
    }
    
    async put<T>(path: string, body?: any): Promise<T> {
        const response = await fetch(new URL(path, this.baseUrl).toString(), {
            method: 'PUT',
            headers: this.headers,
            body: body ? JSON.stringify(body) : undefined
        });
        if (!response.ok) throw new APIError(response.status, await response.text());
        return response.json();
    }
    
    async delete<T>(path: string): Promise<T> {
        const response = await fetch(new URL(path, this.baseUrl).toString(), {
            method: 'DELETE',
            headers: this.headers
        });
        if (!response.ok) throw new APIError(response.status, await response.text());
        return response.json();
    }
}

// React Query Hook Factory
function createAPIHooks(client: APIClient) {
    return {
        useQuery: <T>(key: string[], path: string, params?: any) => {
            return useQuery({
                queryKey: key,
                queryFn: () => client.get<T>(path, params)
            });
        },
        
        useMutation: <T, V>(path: string, method: 'post' | 'put' | 'delete') => {
            const queryClient = useQueryClient();
            
            return useMutation({
                mutationFn: (data: V) => {
                    if (method === 'post') return client.post<T>(path, data);
                    if (method === 'put') return client.put<T>(path, data);
                    return client.delete<T>(path);
                },
                onSuccess: () => {
                    queryClient.invalidateQueries();
                }
            });
        }
    };
}

// OpenAPI Client Generator
class OpenAPIClientGenerator {
    async generateFromSpec(specUrl: string) {
        const spec = await fetch(specUrl).then(r => r.json());
        
        let code = 'export class GeneratedAPIClient {\\n';
        code += '  private client: APIClient;\\n\\n';
        code += '  constructor(baseUrl: string) {\\n';
        code += '    this.client = new APIClient(baseUrl);\\n';
        code += '  }\\n\\n';
        
        for (const [path, methods] of Object.entries(spec.paths)) {
            for (const [method, operation] of Object.entries(methods as any)) {
                const fnName = operation.operationId || this.pathToFnName(method, path);
                code += this.generateMethod(fnName, method, path, operation);
            }
        }
        
        code += '}';
        return code;
    }
}

class APIError extends Error {
    constructor(public status: number, public body: string) {
        super(\`API Error \${status}: \${body}\`);
    }
}

export { APIClient, createAPIHooks, OpenAPIClientGenerator, APIError };
`;
    }
}

export const apiClientGenerator = APIClientGenerator.getInstance();
