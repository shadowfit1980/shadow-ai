/**
 * ðŸ”— APIVersioningGenerator
 * 
 * API versioning:
 * - URL, header, content negotiation
 */

import { EventEmitter } from 'events';

export class APIVersioningGenerator extends EventEmitter {
    private static instance: APIVersioningGenerator;
    private constructor() { super(); }
    static getInstance(): APIVersioningGenerator {
        if (!APIVersioningGenerator.instance) {
            APIVersioningGenerator.instance = new APIVersioningGenerator();
        }
        return APIVersioningGenerator.instance;
    }

    generate(): string {
        return `// API Versioning Generator - URL, header, content negotiation
// Generated by Shadow AI

// Version Middleware
function versionMiddleware(req: any, res: any, next: Function) {
    // Try header first
    let version = req.headers['api-version'] || req.headers['x-api-version'];
    
    // Try URL path
    if (!version) {
        const match = req.path.match(/\\/v(\\d+)/);
        if (match) version = match[1];
    }
    
    // Try Accept header (content negotiation)
    if (!version) {
        const accept = req.headers.accept || '';
        const match = accept.match(/application\\/vnd\\.api\\.v(\\d+)\\+json/);
        if (match) version = match[1];
    }
    
    // Default to latest
    req.apiVersion = parseInt(version || '2');
    
    next();
}

// Version Router
class VersionedRouter {
    private versions: Map<number, express.Router> = new Map();
    
    version(v: number): express.Router {
        if (!this.versions.has(v)) {
            this.versions.set(v, express.Router());
        }
        return this.versions.get(v)!;
    }
    
    middleware() {
        return (req: any, res: any, next: Function) => {
            const router = this.versions.get(req.apiVersion);
            
            if (!router) {
                return res.status(400).json({ error: \`Unsupported API version: v\${req.apiVersion}\` });
            }
            
            router(req, res, next);
        };
    }
}

// Response Transformer
class ResponseTransformer {
    private transformers: Map<number, Map<string, (data: any) => any>> = new Map();
    
    register(version: number, resource: string, transformer: (data: any) => any) {
        if (!this.transformers.has(version)) {
            this.transformers.set(version, new Map());
        }
        this.transformers.get(version)!.set(resource, transformer);
    }
    
    transform(data: any, resource: string, version: number): any {
        const versionTransformers = this.transformers.get(version);
        if (!versionTransformers) return data;
        
        const transformer = versionTransformers.get(resource);
        if (!transformer) return data;
        
        return transformer(data);
    }
}

// Deprecation Header
function deprecationMiddleware(deprecatedVersions: number[]) {
    return (req: any, res: any, next: Function) => {
        if (deprecatedVersions.includes(req.apiVersion)) {
            res.set('Deprecation', 'true');
            res.set('Sunset', 'Sat, 01 Jan 2025 00:00:00 GMT');
            res.set('Link', '</api/v2>; rel="successor-version"');
        }
        next();
    };
}

// Usage Example
const router = new VersionedRouter();

// V1 routes
router.version(1).get('/users', async (req, res) => {
    const users = await getUsers();
    res.json(users.map(u => ({ id: u.id, name: u.name }))); // V1 format
});

// V2 routes (with more fields)
router.version(2).get('/users', async (req, res) => {
    const users = await getUsers();
    res.json(users.map(u => ({ id: u.id, name: u.name, email: u.email, createdAt: u.createdAt })));
});

export { versionMiddleware, VersionedRouter, ResponseTransformer, deprecationMiddleware };
`;
    }
}

export const apiVersioningGenerator = APIVersioningGenerator.getInstance();
