/**
 * â™¿ Accessibility Auditor
 * 
 * WCAG compliance:
 * - Accessibility testing, fixes, reports
 */

import { EventEmitter } from 'events';

export class AccessibilityAuditor extends EventEmitter {
    private static instance: AccessibilityAuditor;

    private constructor() { super(); }

    static getInstance(): AccessibilityAuditor {
        if (!AccessibilityAuditor.instance) {
            AccessibilityAuditor.instance = new AccessibilityAuditor();
        }
        return AccessibilityAuditor.instance;
    }

    generate(): string {
        return `// Accessibility Auditor
// Generated by Shadow AI

/**
 * ACCESSIBILITY AUDITOR
 * 
 * WCAG 2.1 compliance checking and automatic fixes.
 */

interface A11yIssue {
    id: string;
    rule: string;
    wcagCriteria: string;
    level: 'A' | 'AA' | 'AAA';
    severity: 'critical' | 'serious' | 'moderate' | 'minor';
    element: string;
    issue: string;
    fix: string;
    autoFixable: boolean;
}

// === Accessibility Scanner ===
class AccessibilityScanner {
    async scanPage(url: string): Promise<A11yIssue[]> {
        const browser = await puppeteer.launch();
        const page = await browser.newPage();
        await page.goto(url);
        
        // Inject axe-core
        await page.addScriptTag({ url: 'https://cdnjs.cloudflare.com/ajax/libs/axe-core/4.7.0/axe.min.js' });
        
        // Run audit
        const results = await page.evaluate(async () => {
            return await axe.run();
        });
        
        await browser.close();
        
        return this.mapAxeResults(results);
    }
    
    async scanComponent(componentPath: string): Promise<A11yIssue[]> {
        const content = await fs.readFile(componentPath, 'utf-8');
        const issues: A11yIssue[] = [];
        
        // Check for missing alt text
        const imgMatches = content.matchAll(/<img[^>]*>/g);
        for (const match of imgMatches) {
            if (!match[0].includes('alt=')) {
                issues.push({
                    id: crypto.randomUUID(),
                    rule: 'image-alt',
                    wcagCriteria: '1.1.1',
                    level: 'A',
                    severity: 'critical',
                    element: match[0],
                    issue: 'Image missing alt attribute',
                    fix: 'Add alt="description" or alt="" for decorative images',
                    autoFixable: false
                });
            }
        }
        
        // Check for missing form labels
        const inputMatches = content.matchAll(/<input[^>]*>/g);
        for (const match of inputMatches) {
            if (!match[0].includes('aria-label') && !match[0].includes('id=')) {
                issues.push({
                    id: crypto.randomUUID(),
                    rule: 'label',
                    wcagCriteria: '1.3.1',
                    level: 'A',
                    severity: 'serious',
                    element: match[0],
                    issue: 'Form input missing label',
                    fix: 'Add aria-label or associate with <label>',
                    autoFixable: true
                });
            }
        }
        
        // Check for missing button text
        const buttonMatches = content.matchAll(/<button[^>]*>([^<]*)<\\/button>/g);
        for (const match of buttonMatches) {
            if (!match[1].trim() && !match[0].includes('aria-label')) {
                issues.push({
                    id: crypto.randomUUID(),
                    rule: 'button-name',
                    wcagCriteria: '4.1.2',
                    level: 'A',
                    severity: 'critical',
                    element: match[0],
                    issue: 'Button has no accessible name',
                    fix: 'Add text content or aria-label',
                    autoFixable: false
                });
            }
        }
        
        // Check color contrast (simplified)
        const colorContrast = await this.checkColorContrast(content);
        issues.push(...colorContrast);
        
        return issues;
    }
}

// === Auto Fixer ===
class A11yAutoFixer {
    async fix(issue: A11yIssue, filePath: string): Promise<boolean> {
        if (!issue.autoFixable) return false;
        
        const content = await fs.readFile(filePath, 'utf-8');
        let fixed = content;
        
        switch (issue.rule) {
            case 'label':
                // Add aria-label to inputs
                fixed = this.addAriaLabel(content, issue.element);
                break;
            case 'tabindex':
                // Fix tabindex values
                fixed = this.fixTabindex(content, issue.element);
                break;
            case 'focus-visible':
                // Add focus styles
                fixed = this.addFocusStyles(content, issue.element);
                break;
        }
        
        if (fixed !== content) {
            await fs.writeFile(filePath, fixed);
            return true;
        }
        
        return false;
    }
    
    private addAriaLabel(content: string, element: string): string {
        const placeholder = element.match(/placeholder="([^"]+)"/)?.[1];
        const type = element.match(/type="([^"]+)"/)?.[1] || 'text';
        const label = placeholder || \`Enter \${type}\`;
        
        return content.replace(element, element.replace('<input', \`<input aria-label="\${label}"\`));
    }
}

// === Report Generator ===
class A11yReportGenerator {
    generateReport(issues: A11yIssue[]): string {
        const byLevel = {
            A: issues.filter(i => i.level === 'A'),
            AA: issues.filter(i => i.level === 'AA'),
            AAA: issues.filter(i => i.level === 'AAA')
        };
        
        const bySeverity = {
            critical: issues.filter(i => i.severity === 'critical'),
            serious: issues.filter(i => i.severity === 'serious'),
            moderate: issues.filter(i => i.severity === 'moderate'),
            minor: issues.filter(i => i.severity === 'minor')
        };
        
        return \`
# Accessibility Audit Report

## Summary
- Total Issues: \${issues.length}
- Critical: \${bySeverity.critical.length}
- Serious: \${bySeverity.serious.length}
- Moderate: \${bySeverity.moderate.length}
- Minor: \${bySeverity.minor.length}

## WCAG Compliance
- Level A Issues: \${byLevel.A.length}
- Level AA Issues: \${byLevel.AA.length}
- Level AAA Issues: \${byLevel.AAA.length}

## Issues

### Critical
\${bySeverity.critical.map(i => \`- [\${i.wcagCriteria}] \${i.issue}\\n  Fix: \${i.fix}\`).join('\\n')}

### Serious
\${bySeverity.serious.map(i => \`- [\${i.wcagCriteria}] \${i.issue}\\n  Fix: \${i.fix}\`).join('\\n')}

### Recommendations
1. Add skip navigation links
2. Ensure all interactive elements are keyboard accessible
3. Provide text alternatives for non-text content
4. Use semantic HTML elements
5. Test with screen readers
        \`;
    }
}

// === ESLint Plugin Generator ===
class A11yESLintGenerator {
    generateConfig(): string {
        return \`
// ESLint Accessibility Config - Generated by Shadow AI
module.exports = {
    plugins: ['jsx-a11y'],
    extends: ['plugin:jsx-a11y/recommended'],
    rules: {
        'jsx-a11y/alt-text': 'error',
        'jsx-a11y/anchor-has-content': 'error',
        'jsx-a11y/anchor-is-valid': 'error',
        'jsx-a11y/aria-activedescendant-has-tabindex': 'error',
        'jsx-a11y/aria-props': 'error',
        'jsx-a11y/aria-proptypes': 'error',
        'jsx-a11y/aria-role': 'error',
        'jsx-a11y/aria-unsupported-elements': 'error',
        'jsx-a11y/click-events-have-key-events': 'error',
        'jsx-a11y/heading-has-content': 'error',
        'jsx-a11y/html-has-lang': 'error',
        'jsx-a11y/iframe-has-title': 'error',
        'jsx-a11y/img-redundant-alt': 'error',
        'jsx-a11y/interactive-supports-focus': 'error',
        'jsx-a11y/label-has-associated-control': 'error',
        'jsx-a11y/lang': 'error',
        'jsx-a11y/media-has-caption': 'error',
        'jsx-a11y/mouse-events-have-key-events': 'error',
        'jsx-a11y/no-access-key': 'error',
        'jsx-a11y/no-autofocus': 'warn',
        'jsx-a11y/no-distracting-elements': 'error',
        'jsx-a11y/no-interactive-element-to-noninteractive-role': 'error',
        'jsx-a11y/no-noninteractive-element-interactions': 'error',
        'jsx-a11y/no-noninteractive-element-to-interactive-role': 'error',
        'jsx-a11y/no-noninteractive-tabindex': 'error',
        'jsx-a11y/no-redundant-roles': 'error',
        'jsx-a11y/no-static-element-interactions': 'error',
        'jsx-a11y/role-has-required-aria-props': 'error',
        'jsx-a11y/role-supports-aria-props': 'error',
        'jsx-a11y/scope': 'error',
        'jsx-a11y/tabindex-no-positive': 'error'
    }
};
        \`;
    }
}

export { AccessibilityScanner, A11yAutoFixer, A11yReportGenerator, A11yESLintGenerator };
`;
    }
}

export const accessibilityAuditor = AccessibilityAuditor.getInstance();
