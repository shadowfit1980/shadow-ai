/**
 * ðŸ”„ AgentLoopService
 * 
 * Agent execution loop:
 * - ReAct, chain-of-thought, self-correction
 */

import { EventEmitter } from 'events';

export class AgentLoopService extends EventEmitter {
    private static instance: AgentLoopService;
    private constructor() { super(); }
    static getInstance(): AgentLoopService {
        if (!AgentLoopService.instance) {
            AgentLoopService.instance = new AgentLoopService();
        }
        return AgentLoopService.instance;
    }

    generate(): string {
        return `// Agent Loop Service - ReAct, chain-of-thought
// Generated by Shadow AI

class AgentLoop {
    private maxIterations = 20;
    private toolExecutor: ToolExecutor;
    private memory: AgentMemory;
    
    constructor(toolExecutor: ToolExecutor, memory: AgentMemory) {
        this.toolExecutor = toolExecutor;
        this.memory = memory;
    }
    
    async run(goal: string): Promise<AgentResult> {
        const messages: Message[] = [
            { role: 'system', content: this.getSystemPrompt() },
            { role: 'user', content: goal }
        ];
        
        let iterations = 0;
        
        while (iterations < this.maxIterations) {
            iterations++;
            
            // Think
            const response = await llm.chat(messages, {
                tools: this.toolExecutor.getToolDefinitions(),
                tool_choice: 'auto'
            });
            
            messages.push({ role: 'assistant', content: response.content });
            
            // Check if done
            if (!response.tool_calls || response.tool_calls.length === 0) {
                return {
                    success: true,
                    result: response.content,
                    iterations,
                    messages
                };
            }
            
            // Act - execute tool calls
            for (const toolCall of response.tool_calls) {
                try {
                    const result = await this.toolExecutor.execute(
                        toolCall.function.name,
                        JSON.parse(toolCall.function.arguments)
                    );
                    
                    messages.push({
                        role: 'tool',
                        tool_call_id: toolCall.id,
                        content: JSON.stringify(result)
                    });
                } catch (error) {
                    messages.push({
                        role: 'tool',
                        tool_call_id: toolCall.id,
                        content: JSON.stringify({ error: error.message })
                    });
                }
            }
            
            // Store in memory
            await this.memory.store('agent', \`Iteration \${iterations}: \${response.content}\`);
        }
        
        return {
            success: false,
            result: 'Max iterations reached',
            iterations,
            messages
        };
    }
    
    private getSystemPrompt(): string {
        return \`You are an AI coding assistant. You have access to tools for reading files, writing files, searching code, and executing commands.

When given a task:
1. Think about what needs to be done (Thought)
2. Decide which tool to use (Action)
3. Observe the result (Observation)
4. Repeat until the task is complete

Always explain your reasoning before taking actions. Be careful with destructive operations.
When the task is complete, provide a summary of what was accomplished.\`;
    }
    
    async runWithSelfCorrection(goal: string): Promise<AgentResult> {
        let result = await this.run(goal);
        
        // Verify the result
        const verification = await llm.chat([
            { role: 'system', content: 'Verify if the following result correctly accomplishes the goal. Return JSON: { valid: boolean, issues: string[] }' },
            { role: 'user', content: \`Goal: \${goal}\\n\\nResult: \${result.result}\` }
        ]);
        
        const check = JSON.parse(verification.content);
        
        if (!check.valid && result.iterations < this.maxIterations) {
            // Self-correct
            return this.run(\`\${goal}\\n\\nPrevious attempt had issues: \${check.issues.join(', ')}. Please fix these.\`);
        }
        
        return result;
    }
}

export { AgentLoop };
`;
    }
}

export const agentLoopService = AgentLoopService.getInstance();
