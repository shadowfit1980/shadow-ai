/**
 * ðŸ§  AgentMemoryService
 * 
 * Long-term memory for agents:
 * - Vector storage, recall, context
 */

import { EventEmitter } from 'events';

export class AgentMemoryService extends EventEmitter {
    private static instance: AgentMemoryService;
    private constructor() { super(); }
    static getInstance(): AgentMemoryService {
        if (!AgentMemoryService.instance) {
            AgentMemoryService.instance = new AgentMemoryService();
        }
        return AgentMemoryService.instance;
    }

    generate(): string {
        return `// Agent Memory Service - Long-term memory, vector storage
// Generated by Shadow AI

import { OpenAIEmbeddings } from 'langchain/embeddings/openai';
import { PineconeStore } from 'langchain/vectorstores/pinecone';

class AgentMemory {
    private vectorStore: PineconeStore;
    private embeddings: OpenAIEmbeddings;
    private shortTermMemory: Map<string, any[]> = new Map();
    
    constructor() {
        this.embeddings = new OpenAIEmbeddings();
    }
    
    // Store a memory with embedding
    async store(agentId: string, content: string, metadata: Record<string, any> = {}) {
        const embedding = await this.embeddings.embedQuery(content);
        
        await this.vectorStore.addDocuments([{
            pageContent: content,
            metadata: { agentId, timestamp: Date.now(), ...metadata }
        }]);
        
        // Also store in short-term
        if (!this.shortTermMemory.has(agentId)) {
            this.shortTermMemory.set(agentId, []);
        }
        this.shortTermMemory.get(agentId)!.push({ content, metadata, timestamp: Date.now() });
        
        // Keep only last 50 in short-term
        const memories = this.shortTermMemory.get(agentId)!;
        if (memories.length > 50) memories.shift();
    }
    
    // Recall relevant memories
    async recall(agentId: string, query: string, k = 5): Promise<Memory[]> {
        const results = await this.vectorStore.similaritySearch(query, k, {
            agentId
        });
        
        return results.map(doc => ({
            content: doc.pageContent,
            metadata: doc.metadata,
            relevance: doc.metadata.score
        }));
    }
    
    // Get recent short-term memories
    getRecent(agentId: string, count = 10): Memory[] {
        const memories = this.shortTermMemory.get(agentId) || [];
        return memories.slice(-count);
    }
    
    // Summarize conversation history
    async summarize(agentId: string): Promise<string> {
        const recent = this.getRecent(agentId, 20);
        
        const response = await llm.chat([{
            role: 'system',
            content: 'Summarize the following conversation history concisely:'
        }, {
            role: 'user',
            content: recent.map(m => m.content).join('\\n')
        }]);
        
        return response.content;
    }
    
    // Forget specific memories
    async forget(agentId: string, filter: Record<string, any>) {
        await this.vectorStore.delete({ filter: { agentId, ...filter } });
    }
    
    // Get memory statistics
    async getStats(agentId: string) {
        const shortTermCount = this.shortTermMemory.get(agentId)?.length || 0;
        
        return {
            shortTermMemories: shortTermCount,
            agentId
        };
    }
}

export { AgentMemory };
`;
    }
}

export const agentMemoryService = AgentMemoryService.getInstance();
