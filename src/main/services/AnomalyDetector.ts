/**
 * üîî Anomaly Detector
 * 
 * AI-powered anomaly detection:
 * - Logs, metrics, behavior patterns
 */

import { EventEmitter } from 'events';

export class AnomalyDetector extends EventEmitter {
    private static instance: AnomalyDetector;

    private constructor() { super(); }

    static getInstance(): AnomalyDetector {
        if (!AnomalyDetector.instance) {
            AnomalyDetector.instance = new AnomalyDetector();
        }
        return AnomalyDetector.instance;
    }

    generate(): string {
        return `// Anomaly Detector
// Generated by Shadow AI

/**
 * ANOMALY DETECTOR
 * 
 * AI-powered system that detects anomalies in:
 * - Application logs
 * - Performance metrics
 * - User behavior patterns
 */

interface Anomaly {
    id: string;
    type: 'error-spike' | 'latency' | 'traffic' | 'resource' | 'security' | 'behavior';
    severity: 'low' | 'medium' | 'high' | 'critical';
    timestamp: Date;
    description: string;
    metric: string;
    expectedValue: number;
    actualValue: number;
    deviation: number;
    suggestedAction: string;
}

// === Time Series Analyzer ===
class TimeSeriesAnalyzer {
    private historicalData: Map<string, number[]> = new Map();
    
    addDataPoint(metric: string, value: number): void {
        if (!this.historicalData.has(metric)) {
            this.historicalData.set(metric, []);
        }
        const data = this.historicalData.get(metric)!;
        data.push(value);
        
        // Keep last 1000 points
        if (data.length > 1000) data.shift();
    }
    
    detectAnomaly(metric: string, value: number): Anomaly | null {
        const data = this.historicalData.get(metric);
        if (!data || data.length < 30) return null;
        
        const mean = data.reduce((a, b) => a + b, 0) / data.length;
        const stdDev = Math.sqrt(
            data.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / data.length
        );
        
        const zScore = Math.abs((value - mean) / stdDev);
        
        if (zScore > 3) {
            return {
                id: crypto.randomUUID(),
                type: 'latency',
                severity: zScore > 5 ? 'critical' : zScore > 4 ? 'high' : 'medium',
                timestamp: new Date(),
                description: \`\${metric} deviated significantly from normal\`,
                metric,
                expectedValue: mean,
                actualValue: value,
                deviation: zScore,
                suggestedAction: \`Investigate \${metric} - \${zScore.toFixed(1)} standard deviations from mean\`
            };
        }
        
        return null;
    }
}

// === Log Anomaly Detector ===
class LogAnomalyDetector {
    private normalPatterns: Map<string, number> = new Map();
    private errorBudget: { total: number; used: number } = { total: 100, used: 0 };
    
    async analyzeLog(log: string): Promise<Anomaly | null> {
        // Check for error spikes
        if (log.includes('ERROR') || log.includes('Exception')) {
            this.errorBudget.used++;
            
            if (this.errorBudget.used > this.errorBudget.total * 0.1) {
                return {
                    id: crypto.randomUUID(),
                    type: 'error-spike',
                    severity: 'high',
                    timestamp: new Date(),
                    description: 'Error rate exceeded 10% of budget',
                    metric: 'error_rate',
                    expectedValue: this.errorBudget.total * 0.01,
                    actualValue: this.errorBudget.used,
                    deviation: this.errorBudget.used / (this.errorBudget.total * 0.01),
                    suggestedAction: 'Check recent deployments and investigate error sources'
                };
            }
        }
        
        // Pattern analysis with AI
        const pattern = await this.extractPattern(log);
        if (!this.normalPatterns.has(pattern)) {
            // New pattern detected
            return {
                id: crypto.randomUUID(),
                type: 'behavior',
                severity: 'low',
                timestamp: new Date(),
                description: \`New log pattern detected: \${pattern.substring(0, 50)}...\`,
                metric: 'new_pattern',
                expectedValue: 0,
                actualValue: 1,
                deviation: 1,
                suggestedAction: 'Review new log pattern for potential issues'
            };
        }
        
        return null;
    }
    
    private async extractPattern(log: string): Promise<string> {
        // Normalize numbers and IDs
        return log
            .replace(/\\d{4}-\\d{2}-\\d{2}/g, '<DATE>')
            .replace(/\\d{2}:\\d{2}:\\d{2}/g, '<TIME>')
            .replace(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi, '<UUID>')
            .replace(/\\d+/g, '<NUM>');
    }
}

// === Real-time Monitor ===
class AnomalyMonitor {
    private timeSeriesAnalyzer = new TimeSeriesAnalyzer();
    private logAnalyzer = new LogAnomalyDetector();
    private anomalyCount = 0;
    
    async processMetric(name: string, value: number): Promise<void> {
        this.timeSeriesAnalyzer.addDataPoint(name, value);
        const anomaly = this.timeSeriesAnalyzer.detectAnomaly(name, value);
        
        if (anomaly) {
            await this.handleAnomaly(anomaly);
        }
    }
    
    async processLog(log: string): Promise<void> {
        const anomaly = await this.logAnalyzer.analyzeLog(log);
        
        if (anomaly) {
            await this.handleAnomaly(anomaly);
        }
    }
    
    private async handleAnomaly(anomaly: Anomaly): Promise<void> {
        this.anomalyCount++;
        console.log(\`‚ö†Ô∏è Anomaly detected: \${anomaly.description}\`);
        
        // Alert based on severity
        if (anomaly.severity === 'critical') {
            await this.sendAlert('pagerduty', anomaly);
        } else if (anomaly.severity === 'high') {
            await this.sendAlert('slack', anomaly);
        }
        
        // Auto-remediation for known issues
        if (anomaly.type === 'resource' && anomaly.metric === 'cpu') {
            console.log('üîß Triggering auto-scaling...');
            await this.triggerAutoScale();
        }
    }
    
    private async sendAlert(channel: string, anomaly: Anomaly): Promise<void> {
        // Integration with alerting services
    }
    
    private async triggerAutoScale(): Promise<void> {
        // Auto-scaling logic
    }
}

export { TimeSeriesAnalyzer, LogAnomalyDetector, AnomalyMonitor };
`;
    }
}

export const anomalyDetector = AnomalyDetector.getInstance();
