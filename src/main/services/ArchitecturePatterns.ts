/**
 * ğŸ›ï¸ Architecture Patterns Generator
 * 
 * Generate architecture patterns:
 * - Clean, Hexagonal, DDD
 */

import { EventEmitter } from 'events';

export class ArchitecturePatterns extends EventEmitter {
    private static instance: ArchitecturePatterns;

    private constructor() { super(); }

    static getInstance(): ArchitecturePatterns {
        if (!ArchitecturePatterns.instance) {
            ArchitecturePatterns.instance = new ArchitecturePatterns();
        }
        return ArchitecturePatterns.instance;
    }

    generateCleanArchitecture(): string {
        return `// Clean Architecture
// Generated by Shadow AI

/*
Project Structure:
src/
â”œâ”€â”€ domain/           # Enterprise Business Rules (innermost)
â”‚   â”œâ”€â”€ entities/
â”‚   â””â”€â”€ value-objects/
â”œâ”€â”€ application/      # Application Business Rules
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”œâ”€â”€ ports/       # Interfaces (Input/Output ports)
â”‚   â””â”€â”€ dto/
â”œâ”€â”€ infrastructure/   # Frameworks & Drivers (outermost)
â”‚   â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ controllers/
â””â”€â”€ main/             # Composition Root
    â””â”€â”€ di/
*/

// === Domain Layer ===
// domain/entities/User.ts
class UserId {
    constructor(public readonly value: string) {
        if (!value || value.length < 1) throw new Error('Invalid user ID');
    }
}

class Email {
    constructor(public readonly value: string) {
        if (!value.includes('@')) throw new Error('Invalid email');
    }
}

class User {
    constructor(
        public readonly id: UserId,
        public readonly email: Email,
        public readonly name: string,
        private _password: string
    ) {}

    changePassword(newPassword: string): void {
        if (newPassword.length < 8) throw new Error('Password too short');
        this._password = newPassword;
    }

    static create(email: string, name: string, password: string): User {
        return new User(
            new UserId(crypto.randomUUID()),
            new Email(email),
            name,
            password
        );
    }
}

// === Application Layer ===
// application/ports/UserRepository.ts (Output Port)
interface UserRepository {
    save(user: User): Promise<void>;
    findById(id: UserId): Promise<User | null>;
    findByEmail(email: Email): Promise<User | null>;
}

// application/ports/PasswordHasher.ts (Output Port)
interface PasswordHasher {
    hash(password: string): Promise<string>;
    verify(password: string, hash: string): Promise<boolean>;
}

// application/use-cases/CreateUser.ts
interface CreateUserInput {
    email: string;
    name: string;
    password: string;
}

interface CreateUserOutput {
    id: string;
    email: string;
    name: string;
}

class CreateUserUseCase {
    constructor(
        private userRepo: UserRepository,
        private passwordHasher: PasswordHasher
    ) {}

    async execute(input: CreateUserInput): Promise<CreateUserOutput> {
        // Business rule: email must be unique
        const existing = await this.userRepo.findByEmail(new Email(input.email));
        if (existing) throw new Error('Email already in use');

        const hashedPassword = await this.passwordHasher.hash(input.password);
        const user = User.create(input.email, input.name, hashedPassword);

        await this.userRepo.save(user);

        return {
            id: user.id.value,
            email: user.email.value,
            name: user.name
        };
    }
}

// === Infrastructure Layer ===
// infrastructure/repositories/PrismaUserRepository.ts
class PrismaUserRepository implements UserRepository {
    constructor(private prisma: PrismaClient) {}

    async save(user: User): Promise<void> {
        await this.prisma.user.upsert({
            where: { id: user.id.value },
            create: {
                id: user.id.value,
                email: user.email.value,
                name: user.name
            },
            update: {
                email: user.email.value,
                name: user.name
            }
        });
    }

    async findById(id: UserId): Promise<User | null> {
        const data = await this.prisma.user.findUnique({ where: { id: id.value } });
        if (!data) return null;
        return new User(new UserId(data.id), new Email(data.email), data.name, data.password);
    }

    async findByEmail(email: Email): Promise<User | null> {
        const data = await this.prisma.user.findUnique({ where: { email: email.value } });
        if (!data) return null;
        return new User(new UserId(data.id), new Email(data.email), data.name, data.password);
    }
}

// infrastructure/services/BcryptPasswordHasher.ts
class BcryptPasswordHasher implements PasswordHasher {
    async hash(password: string): Promise<string> {
        return bcrypt.hash(password, 12);
    }

    async verify(password: string, hash: string): Promise<boolean> {
        return bcrypt.compare(password, hash);
    }
}

// infrastructure/controllers/UserController.ts
class UserController {
    constructor(private createUser: CreateUserUseCase) {}

    async create(req: Request, res: Response) {
        try {
            const output = await this.createUser.execute(req.body);
            res.status(201).json(output);
        } catch (error: any) {
            res.status(400).json({ error: error.message });
        }
    }
}

// === Composition Root (Dependency Injection) ===
// main/di/container.ts
const prisma = new PrismaClient();
const userRepository = new PrismaUserRepository(prisma);
const passwordHasher = new BcryptPasswordHasher();
const createUserUseCase = new CreateUserUseCase(userRepository, passwordHasher);
const userController = new UserController(createUserUseCase);

export { User, UserId, Email, CreateUserUseCase, userController };
`;
    }

    generateHexagonal(): string {
        return `// Hexagonal Architecture (Ports & Adapters)
// Generated by Shadow AI

/*
src/
â”œâ”€â”€ core/                # Inside (Business Logic)
â”‚   â”œâ”€â”€ domain/
â”‚   â””â”€â”€ application/
â”‚       â”œâ”€â”€ ports/
â”‚       â”‚   â”œâ”€â”€ input/   # Driving/Primary ports
â”‚       â”‚   â””â”€â”€ output/  # Driven/Secondary ports
â”‚       â””â”€â”€ services/
â”œâ”€â”€ adapters/            # Outside (Infrastructure)
â”‚   â”œâ”€â”€ input/           # Driving adapters (REST, GraphQL, CLI)
â”‚   â””â”€â”€ output/          # Driven adapters (DB, Email, Queue)
â””â”€â”€ config/
*/

// === Ports (Interfaces) ===
// core/application/ports/input/OrderService.ts
interface OrderService {
    createOrder(command: CreateOrderCommand): Promise<OrderDTO>;
    getOrder(id: string): Promise<OrderDTO>;
    shipOrder(id: string): Promise<void>;
}

// core/application/ports/output/OrderRepository.ts
interface OrderRepository {
    save(order: Order): Promise<void>;
    findById(id: OrderId): Promise<Order | null>;
}

// core/application/ports/output/PaymentGateway.ts
interface PaymentGateway {
    charge(amount: Money, customerId: string): Promise<PaymentResult>;
    refund(paymentId: string): Promise<void>;
}

// core/application/ports/output/NotificationSender.ts
interface NotificationSender {
    sendOrderConfirmation(order: Order): Promise<void>;
    sendShippingNotification(order: Order, trackingNumber: string): Promise<void>;
}

// === Application Service (Use Case Implementation) ===
// core/application/services/OrderServiceImpl.ts
class OrderServiceImpl implements OrderService {
    constructor(
        private orderRepo: OrderRepository,
        private paymentGateway: PaymentGateway,
        private notificationSender: NotificationSender
    ) {}

    async createOrder(command: CreateOrderCommand): Promise<OrderDTO> {
        // Domain logic
        const order = Order.create(command.customerId, command.items);

        // Charge payment
        const payment = await this.paymentGateway.charge(order.total, command.customerId);
        order.setPaymentId(payment.id);

        // Persist
        await this.orderRepo.save(order);

        // Side effect
        await this.notificationSender.sendOrderConfirmation(order);

        return OrderDTO.fromDomain(order);
    }

    async shipOrder(id: string): Promise<void> {
        const order = await this.orderRepo.findById(new OrderId(id));
        if (!order) throw new Error('Order not found');

        order.ship();
        await this.orderRepo.save(order);
    }
}

// === Input Adapters (Driving) ===
// adapters/input/rest/OrderController.ts
class OrderRestController {
    constructor(private orderService: OrderService) {}

    @Post('/orders')
    async create(@Body() body: CreateOrderRequest) {
        return this.orderService.createOrder(body);
    }

    @Get('/orders/:id')
    async get(@Param('id') id: string) {
        return this.orderService.getOrder(id);
    }
}

// adapters/input/graphql/OrderResolver.ts
class OrderResolver {
    constructor(private orderService: OrderService) {}

    @Mutation()
    createOrder(@Args() args: CreateOrderInput) {
        return this.orderService.createOrder(args);
    }

    @Query()
    order(@Args('id') id: string) {
        return this.orderService.getOrder(id);
    }
}

// adapters/input/cli/OrderCLI.ts
class OrderCLI {
    constructor(private orderService: OrderService) {}

    async run(args: string[]) {
        const [command, ...params] = args;
        switch (command) {
            case 'create':
                const order = await this.orderService.createOrder(JSON.parse(params[0]));
                console.log('Created:', order);
                break;
        }
    }
}

// === Output Adapters (Driven) ===
// adapters/output/persistence/PrismaOrderRepository.ts
class PrismaOrderRepository implements OrderRepository {
    constructor(private prisma: PrismaClient) {}

    async save(order: Order): Promise<void> {
        await this.prisma.order.upsert({
            where: { id: order.id.value },
            create: this.toRecord(order),
            update: this.toRecord(order)
        });
    }

    async findById(id: OrderId): Promise<Order | null> {
        const record = await this.prisma.order.findUnique({ where: { id: id.value } });
        return record ? this.toDomain(record) : null;
    }
}

// adapters/output/payment/StripePaymentGateway.ts
class StripePaymentGateway implements PaymentGateway {
    constructor(private stripe: Stripe) {}

    async charge(amount: Money, customerId: string): Promise<PaymentResult> {
        const paymentIntent = await this.stripe.paymentIntents.create({
            amount: amount.cents,
            currency: amount.currency.toLowerCase(),
            customer: customerId
        });
        return { id: paymentIntent.id, status: paymentIntent.status };
    }
}

// adapters/output/notification/EmailNotificationSender.ts
class EmailNotificationSender implements NotificationSender {
    constructor(private emailService: EmailService) {}

    async sendOrderConfirmation(order: Order): Promise<void> {
        await this.emailService.send({
            to: order.customerEmail,
            subject: \`Order \${order.id.value} Confirmed\`,
            template: 'order-confirmation',
            data: { order }
        });
    }
}

export { OrderServiceImpl, OrderRestController, PrismaOrderRepository };
`;
    }
}

export const architecturePatterns = ArchitecturePatterns.getInstance();
