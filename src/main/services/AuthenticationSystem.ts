/**
 * ðŸ” Authentication System Generator
 * 
 * Generate auth code for:
 * - JWT, OAuth, Sessions, MFA
 */

import { EventEmitter } from 'events';

export type AuthMethod = 'jwt' | 'oauth' | 'session' | 'mfa';

export class AuthenticationSystem extends EventEmitter {
    private static instance: AuthenticationSystem;

    private constructor() { super(); }

    static getInstance(): AuthenticationSystem {
        if (!AuthenticationSystem.instance) {
            AuthenticationSystem.instance = new AuthenticationSystem();
        }
        return AuthenticationSystem.instance;
    }

    getSupportedMethods(): AuthMethod[] {
        return ['jwt', 'oauth', 'session', 'mfa'];
    }

    generateAuth(method: AuthMethod): string {
        switch (method) {
            case 'jwt': return this.generateJWT();
            case 'oauth': return this.generateOAuth();
            case 'session': return this.generateSession();
            case 'mfa': return this.generateMFA();
            default: return '';
        }
    }

    private generateJWT(): string {
        return `// JWT Authentication
// Generated by Shadow AI

import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const JWT_EXPIRES = '7d';
const REFRESH_EXPIRES = '30d';

export class AuthService {
    async register(email: string, password: string, name: string) {
        const existingUser = await User.findByEmail(email);
        if (existingUser) {
            throw new Error('Email already registered');
        }
        
        const hashedPassword = await bcrypt.hash(password, 12);
        const user = await User.create({ email, password: hashedPassword, name });
        
        const tokens = this.generateTokens(user);
        return { user: this.sanitizeUser(user), ...tokens };
    }

    async login(email: string, password: string) {
        const user = await User.findByEmail(email);
        if (!user) {
            throw new Error('Invalid credentials');
        }
        
        const isValid = await bcrypt.compare(password, user.password);
        if (!isValid) {
            throw new Error('Invalid credentials');
        }
        
        const tokens = this.generateTokens(user);
        return { user: this.sanitizeUser(user), ...tokens };
    }

    async refreshToken(refreshToken: string) {
        try {
            const payload = jwt.verify(refreshToken, JWT_SECRET) as any;
            const user = await User.findById(payload.userId);
            if (!user) throw new Error('User not found');
            
            return this.generateTokens(user);
        } catch (error) {
            throw new Error('Invalid refresh token');
        }
    }

    async changePassword(userId: string, oldPassword: string, newPassword: string) {
        const user = await User.findById(userId);
        const isValid = await bcrypt.compare(oldPassword, user.password);
        if (!isValid) throw new Error('Invalid current password');
        
        user.password = await bcrypt.hash(newPassword, 12);
        await user.save();
    }

    async forgotPassword(email: string) {
        const user = await User.findByEmail(email);
        if (!user) return; // Don't reveal if email exists
        
        const resetToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '1h' });
        // Send email with reset link
    }

    generateTokens(user: any) {
        const accessToken = jwt.sign(
            { userId: user.id, email: user.email },
            JWT_SECRET,
            { expiresIn: JWT_EXPIRES }
        );
        
        const refreshToken = jwt.sign(
            { userId: user.id, type: 'refresh' },
            JWT_SECRET,
            { expiresIn: REFRESH_EXPIRES }
        );
        
        return { accessToken, refreshToken };
    }

    sanitizeUser(user: any) {
        const { password, ...safe } = user;
        return safe;
    }

    verifyToken(token: string) {
        return jwt.verify(token, JWT_SECRET);
    }
}

// Middleware
export function authMiddleware(req, res, next) {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No token provided' });
    }
    
    const token = authHeader.slice(7);
    try {
        const payload = jwt.verify(token, JWT_SECRET);
        req.user = payload;
        next();
    } catch (error) {
        res.status(401).json({ error: 'Invalid token' });
    }
}
`;
    }

    private generateOAuth(): string {
        return `// OAuth 2.0 Authentication
// Generated by Shadow AI

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';

// Google OAuth
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: '/auth/google/callback'
}, async (accessToken, refreshToken, profile, done) => {
    try {
        let user = await User.findOne({ googleId: profile.id });
        
        if (!user) {
            user = await User.create({
                googleId: profile.id,
                email: profile.emails[0].value,
                name: profile.displayName,
                avatar: profile.photos[0]?.value
            });
        }
        
        done(null, user);
    } catch (error) {
        done(error, null);
    }
}));

// GitHub OAuth
passport.use(new GitHubStrategy({
    clientID: process.env.GITHUB_CLIENT_ID,
    clientSecret: process.env.GITHUB_CLIENT_SECRET,
    callbackURL: '/auth/github/callback'
}, async (accessToken, refreshToken, profile, done) => {
    try {
        let user = await User.findOne({ githubId: profile.id });
        
        if (!user) {
            user = await User.create({
                githubId: profile.id,
                email: profile.emails?.[0]?.value,
                name: profile.displayName || profile.username,
                avatar: profile.photos?.[0]?.value
            });
        }
        
        done(null, user);
    } catch (error) {
        done(error, null);
    }
}));

// Serialization
passport.serializeUser((user, done) => done(null, user.id));
passport.deserializeUser(async (id, done) => {
    const user = await User.findById(id);
    done(null, user);
});

// Routes
export function setupOAuthRoutes(app) {
    // Google
    app.get('/auth/google', passport.authenticate('google', { scope: ['profile', 'email'] }));
    app.get('/auth/google/callback',
        passport.authenticate('google', { failureRedirect: '/login' }),
        (req, res) => res.redirect('/dashboard')
    );
    
    // GitHub
    app.get('/auth/github', passport.authenticate('github', { scope: ['user:email'] }));
    app.get('/auth/github/callback',
        passport.authenticate('github', { failureRedirect: '/login' }),
        (req, res) => res.redirect('/dashboard')
    );
    
    // Logout
    app.post('/auth/logout', (req, res) => {
        req.logout();
        res.json({ success: true });
    });
}
`;
    }

    private generateSession(): string {
        return `// Session-based Authentication
// Generated by Shadow AI

import session from 'express-session';
import RedisStore from 'connect-redis';
import { createClient } from 'redis';
import bcrypt from 'bcryptjs';

// Redis client
const redisClient = createClient({ url: process.env.REDIS_URL });
redisClient.connect();

// Session middleware
export const sessionMiddleware = session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET || 'your-secret',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        sameSite: 'lax'
    }
});

export class SessionAuth {
    async login(req, email: string, password: string) {
        const user = await User.findByEmail(email);
        if (!user) throw new Error('Invalid credentials');
        
        const valid = await bcrypt.compare(password, user.password);
        if (!valid) throw new Error('Invalid credentials');
        
        req.session.userId = user.id;
        req.session.user = { id: user.id, email: user.email, name: user.name };
        
        return req.session.user;
    }

    async logout(req) {
        return new Promise((resolve, reject) => {
            req.session.destroy((err) => {
                if (err) reject(err);
                else resolve(true);
            });
        });
    }

    async getCurrentUser(req) {
        if (!req.session?.userId) return null;
        return User.findById(req.session.userId);
    }
}

// Middleware
export function requireAuth(req, res, next) {
    if (!req.session?.userId) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    next();
}
`;
    }

    private generateMFA(): string {
        return `// Multi-Factor Authentication
// Generated by Shadow AI

import speakeasy from 'speakeasy';
import QRCode from 'qrcode';

export class MFAService {
    generateSecret(email: string) {
        const secret = speakeasy.generateSecret({
            name: \`MyApp (\${email})\`,
            issuer: 'MyApp'
        });
        
        return {
            secret: secret.base32,
            otpAuthUrl: secret.otpauth_url
        };
    }

    async generateQRCode(otpAuthUrl: string) {
        return QRCode.toDataURL(otpAuthUrl);
    }

    verifyToken(secret: string, token: string) {
        return speakeasy.totp.verify({
            secret,
            encoding: 'base32',
            token,
            window: 1
        });
    }

    async enableMFA(userId: string) {
        const user = await User.findById(userId);
        const { secret, otpAuthUrl } = this.generateSecret(user.email);
        const qrCode = await this.generateQRCode(otpAuthUrl);
        
        // Store secret temporarily until verified
        await TempMFASecret.create({ userId, secret, expiresAt: new Date(Date.now() + 600000) });
        
        return { qrCode, secret };
    }

    async verifyAndActivate(userId: string, token: string) {
        const temp = await TempMFASecret.findOne({ userId });
        if (!temp) throw new Error('MFA setup expired');
        
        const valid = this.verifyToken(temp.secret, token);
        if (!valid) throw new Error('Invalid code');
        
        await User.updateOne({ _id: userId }, { 
            mfaEnabled: true, 
            mfaSecret: temp.secret 
        });
        await TempMFASecret.deleteOne({ userId });
        
        // Generate backup codes
        const backupCodes = this.generateBackupCodes();
        await User.updateOne({ _id: userId }, { backupCodes });
        
        return { success: true, backupCodes };
    }

    async verifyMFALogin(userId: string, token: string) {
        const user = await User.findById(userId);
        if (!user.mfaEnabled) return true;
        
        // Check TOTP
        if (this.verifyToken(user.mfaSecret, token)) return true;
        
        // Check backup codes
        const codeIndex = user.backupCodes?.indexOf(token);
        if (codeIndex >= 0) {
            user.backupCodes.splice(codeIndex, 1);
            await user.save();
            return true;
        }
        
        return false;
    }

    generateBackupCodes(count = 10) {
        const codes = [];
        for (let i = 0; i < count; i++) {
            codes.push(Math.random().toString(36).substring(2, 10).toUpperCase());
        }
        return codes;
    }

    async disableMFA(userId: string, password: string) {
        const user = await User.findById(userId);
        const valid = await bcrypt.compare(password, user.password);
        if (!valid) throw new Error('Invalid password');
        
        await User.updateOne({ _id: userId }, {
            mfaEnabled: false,
            mfaSecret: null,
            backupCodes: []
        });
    }
}
`;
    }
}

export const authSystem = AuthenticationSystem.getInstance();
