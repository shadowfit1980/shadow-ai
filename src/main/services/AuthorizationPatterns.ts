/**
 * üîê Authorization Patterns
 * 
 * Generate authorization:
 * - RBAC, ABAC, policies
 */

import { EventEmitter } from 'events';

export class AuthorizationPatterns extends EventEmitter {
    private static instance: AuthorizationPatterns;

    private constructor() { super(); }

    static getInstance(): AuthorizationPatterns {
        if (!AuthorizationPatterns.instance) {
            AuthorizationPatterns.instance = new AuthorizationPatterns();
        }
        return AuthorizationPatterns.instance;
    }

    generate(): string {
        return `// Authorization Patterns (RBAC/ABAC)
// Generated by Shadow AI

// === Role-Based Access Control (RBAC) ===
type Role = 'ADMIN' | 'MANAGER' | 'EDITOR' | 'VIEWER';
type Permission = 'create' | 'read' | 'update' | 'delete' | 'manage';
type Resource = 'users' | 'posts' | 'comments' | 'settings';

const rolePermissions: Record<Role, Record<Resource, Permission[]>> = {
    ADMIN: {
        users: ['create', 'read', 'update', 'delete', 'manage'],
        posts: ['create', 'read', 'update', 'delete', 'manage'],
        comments: ['create', 'read', 'update', 'delete', 'manage'],
        settings: ['read', 'update', 'manage']
    },
    MANAGER: {
        users: ['read', 'update'],
        posts: ['create', 'read', 'update', 'delete'],
        comments: ['create', 'read', 'update', 'delete'],
        settings: ['read']
    },
    EDITOR: {
        users: ['read'],
        posts: ['create', 'read', 'update'],
        comments: ['create', 'read', 'update', 'delete'],
        settings: []
    },
    VIEWER: {
        users: ['read'],
        posts: ['read'],
        comments: ['read'],
        settings: []
    }
};

function hasPermission(role: Role, resource: Resource, permission: Permission): boolean {
    return rolePermissions[role]?.[resource]?.includes(permission) ?? false;
}

// Express middleware
function requirePermission(resource: Resource, permission: Permission) {
    return (req, res, next) => {
        const userRole = req.user?.role as Role;
        
        if (!userRole || !hasPermission(userRole, resource, permission)) {
            return res.status(403).json({ error: 'Insufficient permissions' });
        }
        
        next();
    };
}

// Usage: router.delete('/posts/:id', requirePermission('posts', 'delete'), deletePost);

// === Attribute-Based Access Control (ABAC) ===
interface User {
    id: string;
    role: Role;
    department: string;
    location: string;
}

interface ResourceContext {
    type: Resource;
    ownerId?: string;
    department?: string;
    status?: string;
}

interface PolicyContext {
    user: User;
    resource: ResourceContext;
    action: Permission;
    environment: { time: Date; ip: string };
}

type PolicyRule = (ctx: PolicyContext) => boolean;

const policies: PolicyRule[] = [
    // Admins can do anything
    (ctx) => ctx.user.role === 'ADMIN',
    
    // Owners can manage their own resources
    (ctx) => ctx.resource.ownerId === ctx.user.id && ['read', 'update', 'delete'].includes(ctx.action),
    
    // Same department can read
    (ctx) => ctx.user.department === ctx.resource.department && ctx.action === 'read',
    
    // Only allow during business hours for sensitive actions
    (ctx) => {
        if (ctx.action === 'delete' && ctx.resource.type === 'users') {
            const hour = ctx.environment.time.getHours();
            return hour >= 9 && hour <= 17;
        }
        return true;
    },
    
    // Block certain IPs
    (ctx) => !['blocked-ip'].includes(ctx.environment.ip)
];

function evaluatePolicies(ctx: PolicyContext): boolean {
    return policies.every(policy => policy(ctx));
}

// ABAC Middleware
function abacMiddleware(resource: Resource, action: Permission) {
    return async (req, res, next) => {
        const resourceData = await getResourceContext(req);
        
        const ctx: PolicyContext = {
            user: req.user,
            resource: { type: resource, ...resourceData },
            action,
            environment: { time: new Date(), ip: req.ip }
        };
        
        if (!evaluatePolicies(ctx)) {
            return res.status(403).json({ error: 'Access denied by policy' });
        }
        
        next();
    };
}

// === CASL (Recommended Library) ===
import { AbilityBuilder, PureAbility, subject } from '@casl/ability';

type Actions = 'create' | 'read' | 'update' | 'delete' | 'manage';
type Subjects = 'User' | 'Post' | 'Comment' | 'all';
type AppAbility = PureAbility<[Actions, Subjects]>;

function defineAbilityFor(user: User): AppAbility {
    const { can, cannot, build } = new AbilityBuilder<AppAbility>(PureAbility);

    switch (user.role) {
        case 'ADMIN':
            can('manage', 'all');
            break;
        case 'MANAGER':
            can('read', 'User');
            can('manage', 'Post');
            can('manage', 'Comment');
            cannot('delete', 'Post', { published: true }); // Can't delete published posts
            break;
        case 'EDITOR':
            can('read', 'User');
            can(['create', 'read', 'update'], 'Post');
            can('manage', 'Comment');
            break;
        case 'VIEWER':
            can('read', ['User', 'Post', 'Comment']);
            break;
    }

    // User can always manage their own resources
    can('manage', 'Post', { authorId: user.id });
    can('manage', 'Comment', { authorId: user.id });

    return build();
}

// React integration
import { createContext, useContext } from 'react';
import { createContextualCan } from '@casl/react';

const AbilityContext = createContext<AppAbility>(null!);
const Can = createContextualCan(AbilityContext.Consumer);

function AbilityProvider({ user, children }) {
    const ability = defineAbilityFor(user);
    return <AbilityContext.Provider value={ability}>{children}</AbilityContext.Provider>;
}

function useAbility() {
    return useContext(AbilityContext);
}

// Usage in component
function PostActions({ post }) {
    return (
        <div>
            <Can I="update" this={subject('Post', post)}>
                <button>Edit</button>
            </Can>
            <Can I="delete" this={subject('Post', post)}>
                <button>Delete</button>
            </Can>
        </div>
    );
}

export { hasPermission, requirePermission, evaluatePolicies, abacMiddleware, defineAbilityFor, AbilityProvider, useAbility, Can };
`;
    }
}

export const authorizationPatterns = AuthorizationPatterns.getInstance();
