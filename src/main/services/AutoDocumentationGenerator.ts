/**
 * üìö Auto Documentation Generator
 * 
 * Full docs from code:
 * - API docs, architecture diagrams, tutorials
 */

import { EventEmitter } from 'events';

export class AutoDocumentationGenerator extends EventEmitter {
    private static instance: AutoDocumentationGenerator;

    private constructor() { super(); }

    static getInstance(): AutoDocumentationGenerator {
        if (!AutoDocumentationGenerator.instance) {
            AutoDocumentationGenerator.instance = new AutoDocumentationGenerator();
        }
        return AutoDocumentationGenerator.instance;
    }

    generate(): string {
        return `// Auto Documentation Generator
// Generated by Shadow AI

/**
 * AUTO DOCUMENTATION GENERATOR
 * 
 * Automatically generates comprehensive documentation from code:
 * - API documentation (OpenAPI/Swagger)
 * - Architecture diagrams (Mermaid)
 * - Code walkthroughs
 * - Interactive tutorials
 */

// === Code Analyzer ===
interface CodeEntity {
    type: 'function' | 'class' | 'interface' | 'type' | 'component' | 'hook';
    name: string;
    file: string;
    line: number;
    signature: string;
    jsdoc?: string;
    dependencies: string[];
    usedBy: string[];
}

class CodeAnalyzer {
    async analyzeProject(projectPath: string): Promise<CodeEntity[]> {
        const entities: CodeEntity[] = [];
        
        const files = await glob(\`\${projectPath}/**/*.{ts,tsx,js,jsx}\`, {
            ignore: ['**/node_modules/**', '**/dist/**']
        });
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            const fileEntities = await this.analyzeFile(file, content);
            entities.push(...fileEntities);
        }
        
        // Build dependency graph
        this.resolveDependencies(entities);
        
        return entities;
    }
    
    private async analyzeFile(file: string, content: string): Promise<CodeEntity[]> {
        const sourceFile = ts.createSourceFile(file, content, ts.ScriptTarget.Latest, true);
        const entities: CodeEntity[] = [];
        
        const visit = (node: ts.Node) => {
            if (ts.isFunctionDeclaration(node) && node.name) {
                entities.push({
                    type: 'function',
                    name: node.name.text,
                    file,
                    line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1,
                    signature: this.extractSignature(node),
                    jsdoc: this.extractJSDoc(node, sourceFile),
                    dependencies: [],
                    usedBy: []
                });
            }
            
            if (ts.isClassDeclaration(node) && node.name) {
                entities.push({
                    type: 'class',
                    name: node.name.text,
                    file,
                    line: sourceFile.getLineAndCharacterOfPosition(node.pos).line + 1,
                    signature: this.extractClassSignature(node),
                    jsdoc: this.extractJSDoc(node, sourceFile),
                    dependencies: [],
                    usedBy: []
                });
            }
            
            ts.forEachChild(node, visit);
        };
        
        visit(sourceFile);
        return entities;
    }
}

// === Documentation Generator ===
class DocumentationGenerator {
    async generateApiDocs(entities: CodeEntity[]): Promise<string> {
        const apiFunctions = entities.filter(e => 
            e.type === 'function' && e.file.includes('/api/')
        );
        
        let markdown = '# API Reference\\n\\n';
        
        for (const func of apiFunctions) {
            markdown += \`## \${func.name}\\n\\n\`;
            markdown += \`\\\`\\\`\\\`typescript\\n\${func.signature}\\n\\\`\\\`\\\`\\n\\n\`;
            
            if (func.jsdoc) {
                markdown += \`\${func.jsdoc}\\n\\n\`;
            }
            
            // Generate AI description if no JSDoc
            if (!func.jsdoc) {
                const description = await this.generateDescription(func);
                markdown += \`\${description}\\n\\n\`;
            }
        }
        
        return markdown;
    }
    
    async generateArchitectureDiagram(entities: CodeEntity[]): Promise<string> {
        // Group by module/directory
        const modules = this.groupByModule(entities);
        
        let mermaid = 'graph TD\\n';
        
        // Add nodes
        for (const [moduleName, moduleEntities] of modules) {
            mermaid += \`    subgraph \${moduleName}\\n\`;
            for (const entity of moduleEntities.slice(0, 5)) { // Limit for readability
                mermaid += \`        \${entity.name}[\${entity.name}]\\n\`;
            }
            mermaid += '    end\\n';
        }
        
        // Add edges for dependencies
        for (const entity of entities) {
            for (const dep of entity.dependencies) {
                mermaid += \`    \${entity.name} --> \${dep}\\n\`;
            }
        }
        
        return mermaid;
    }
    
    async generateCodeWalkthrough(entity: CodeEntity): Promise<string> {
        const sourceCode = await this.getSourceCode(entity.file, entity.line);
        
        const prompt = \`
            Generate a step-by-step code walkthrough for this code:
            
            \${sourceCode}
            
            Include:
            1. Overview of what the code does
            2. Line-by-line explanation of key parts
            3. Common use cases
            4. Potential pitfalls
            5. Related concepts to learn
            
            Format as Markdown with clear sections.
        \`;
        
        return await this.llm.complete(prompt);
    }
    
    async generateInteractiveTutorial(topic: string, entities: CodeEntity[]): Promise<Tutorial> {
        const relatedEntities = entities.filter(e => 
            e.name.toLowerCase().includes(topic.toLowerCase()) ||
            e.jsdoc?.toLowerCase().includes(topic.toLowerCase())
        );
        
        const tutorial: Tutorial = {
            title: \`Learning \${topic}\`,
            steps: [],
            codeExamples: [],
            quiz: []
        };
        
        // Generate tutorial steps
        const prompt = \`
            Create an interactive tutorial for "\${topic}" based on this codebase:
            
            Related code entities:
            \${JSON.stringify(relatedEntities.map(e => ({ name: e.name, type: e.type, signature: e.signature })))}
            
            Include:
            1. Introduction (what and why)
            2. Step-by-step guide (3-5 steps)
            3. Code examples with explanations
            4. Hands-on exercises
            5. Quiz questions to test understanding
        \`;
        
        const tutorialContent = await this.llm.complete(prompt);
        return JSON.parse(tutorialContent);
    }
}

// === OpenAPI Generator ===
class OpenAPIGenerator {
    async generateSpec(entities: CodeEntity[]): Promise<OpenAPISpec> {
        const apiRoutes = entities.filter(e => 
            e.file.includes('/api/') || e.file.includes('/routes/')
        );
        
        const spec: OpenAPISpec = {
            openapi: '3.1.0',
            info: {
                title: 'API Documentation',
                version: '1.0.0',
                description: 'Auto-generated API documentation'
            },
            paths: {}
        };
        
        for (const route of apiRoutes) {
            const endpoint = await this.inferEndpoint(route);
            spec.paths[endpoint.path] = {
                [endpoint.method.toLowerCase()]: {
                    summary: endpoint.summary,
                    description: endpoint.description,
                    parameters: endpoint.parameters,
                    requestBody: endpoint.requestBody,
                    responses: endpoint.responses
                }
            };
        }
        
        return spec;
    }
}

// === Main Service ===
class AutoDocsService {
    private analyzer = new CodeAnalyzer();
    private docGenerator = new DocumentationGenerator();
    private openApiGenerator = new OpenAPIGenerator();
    
    async generateFullDocs(projectPath: string): Promise<DocumentationBundle> {
        console.log('üìö Analyzing codebase...');
        const entities = await this.analyzer.analyzeProject(projectPath);
        console.log(\`Found \${entities.length} code entities\`);
        
        console.log('üìñ Generating API docs...');
        const apiDocs = await this.docGenerator.generateApiDocs(entities);
        
        console.log('üèóÔ∏è Generating architecture diagram...');
        const architecture = await this.docGenerator.generateArchitectureDiagram(entities);
        
        console.log('üìã Generating OpenAPI spec...');
        const openApiSpec = await this.openApiGenerator.generateSpec(entities);
        
        return {
            apiReference: apiDocs,
            architectureDiagram: architecture,
            openApiSpec,
            entities
        };
    }
}

export { CodeAnalyzer, DocumentationGenerator, OpenAPIGenerator, AutoDocsService };
`;
    }
}

export const autoDocumentationGenerator = AutoDocumentationGenerator.getInstance();
