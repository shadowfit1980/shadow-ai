/**
 * ðŸ”’ Auto Penetration Tester
 * 
 * Automated security scanning:
 * - OWASP Top 10, vulnerability detection
 */

import { EventEmitter } from 'events';

export class AutoPenTester extends EventEmitter {
    private static instance: AutoPenTester;

    private constructor() { super(); }

    static getInstance(): AutoPenTester {
        if (!AutoPenTester.instance) {
            AutoPenTester.instance = new AutoPenTester();
        }
        return AutoPenTester.instance;
    }

    generate(): string {
        return `// Auto Penetration Tester
// Generated by Shadow AI

/**
 * AUTO PENETRATION TESTER
 * 
 * Automated security vulnerability scanning.
 * Detects OWASP Top 10 vulnerabilities.
 */

interface Vulnerability {
    id: string;
    category: string; // OWASP category
    severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
    title: string;
    description: string;
    location: { file: string; line?: number; endpoint?: string };
    evidence: string;
    remediation: string;
    cwe: string;
    cvss?: number;
}

// === OWASP Top 10 Checks ===
class OWASPScanner {
    async scan(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        
        vulns.push(...await this.checkInjection(projectPath));
        vulns.push(...await this.checkBrokenAuth(projectPath));
        vulns.push(...await this.checkSensitiveData(projectPath));
        vulns.push(...await this.checkXXE(projectPath));
        vulns.push(...await this.checkAccessControl(projectPath));
        vulns.push(...await this.checkMisconfig(projectPath));
        vulns.push(...await this.checkXSS(projectPath));
        vulns.push(...await this.checkDeserialization(projectPath));
        vulns.push(...await this.checkComponents(projectPath));
        vulns.push(...await this.checkLogging(projectPath));
        
        return vulns;
    }
    
    // A1: Injection
    private async checkInjection(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        const files = await glob(\`\${projectPath}/**/*.{ts,js}\`);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            const lines = content.split('\\n');
            
            lines.forEach((line, idx) => {
                // SQL Injection
                if (line.includes('query(') && line.includes('\${') && !line.includes('parameterized')) {
                    vulns.push({
                        id: crypto.randomUUID(),
                        category: 'A03:2021 - Injection',
                        severity: 'critical',
                        title: 'Potential SQL Injection',
                        description: 'User input appears to be directly concatenated into SQL query',
                        location: { file, line: idx + 1 },
                        evidence: line.trim(),
                        remediation: 'Use parameterized queries or prepared statements',
                        cwe: 'CWE-89'
                    });
                }
                
                // Command Injection
                if ((line.includes('exec(') || line.includes('spawn(')) && line.includes('\${')) {
                    vulns.push({
                        id: crypto.randomUUID(),
                        category: 'A03:2021 - Injection',
                        severity: 'critical',
                        title: 'Potential Command Injection',
                        description: 'User input may be directly passed to shell command',
                        location: { file, line: idx + 1 },
                        evidence: line.trim(),
                        remediation: 'Sanitize inputs and avoid shell commands with user data',
                        cwe: 'CWE-78'
                    });
                }
            });
        }
        
        return vulns;
    }
    
    // A7: XSS
    private async checkXSS(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        const files = await glob(\`\${projectPath}/**/*.{tsx,jsx}\`);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            if (content.includes('dangerouslySetInnerHTML')) {
                const lines = content.split('\\n');
                lines.forEach((line, idx) => {
                    if (line.includes('dangerouslySetInnerHTML')) {
                        vulns.push({
                            id: crypto.randomUUID(),
                            category: 'A03:2021 - Injection (XSS)',
                            severity: 'high',
                            title: 'Potential XSS via dangerouslySetInnerHTML',
                            description: 'Using dangerouslySetInnerHTML without proper sanitization',
                            location: { file, line: idx + 1 },
                            evidence: line.trim(),
                            remediation: 'Sanitize HTML with DOMPurify before rendering',
                            cwe: 'CWE-79'
                        });
                    }
                });
            }
        }
        
        return vulns;
    }
    
    // A02: Broken Authentication
    private async checkBrokenAuth(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        const files = await glob(\`\${projectPath}/**/*.{ts,js}\`);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            // Weak password requirements
            if (content.includes('password') && content.match(/minLength.*[1-5][^0-9]/)) {
                vulns.push({
                    id: crypto.randomUUID(),
                    category: 'A07:2021 - Identification and Authentication Failures',
                    severity: 'medium',
                    title: 'Weak Password Requirements',
                    description: 'Password minimum length appears to be less than 8 characters',
                    location: { file },
                    evidence: 'minLength < 8',
                    remediation: 'Require at least 8 characters, with complexity requirements',
                    cwe: 'CWE-521'
                });
            }
            
            // Hardcoded credentials
            if (content.match(/password\\s*[=:]\\s*["'][^"']+["']/i)) {
                vulns.push({
                    id: crypto.randomUUID(),
                    category: 'A07:2021 - Identification and Authentication Failures',
                    severity: 'critical',
                    title: 'Hardcoded Credentials',
                    description: 'Password appears to be hardcoded in source code',
                    location: { file },
                    evidence: '[REDACTED]',
                    remediation: 'Use environment variables or secret management',
                    cwe: 'CWE-798'
                });
            }
        }
        
        return vulns;
    }
    
    // A05: Security Misconfiguration
    private async checkMisconfig(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        
        // Check for DEBUG mode in production configs
        const configFiles = await glob(\`\${projectPath}/**/*.{json,yaml,yml,env}\`);
        
        for (const file of configFiles) {
            const content = await fs.readFile(file, 'utf-8');
            
            if (file.includes('prod') && content.includes('DEBUG=true')) {
                vulns.push({
                    id: crypto.randomUUID(),
                    category: 'A05:2021 - Security Misconfiguration',
                    severity: 'medium',
                    title: 'Debug Mode Enabled in Production',
                    description: 'DEBUG is set to true in production configuration',
                    location: { file },
                    evidence: 'DEBUG=true',
                    remediation: 'Disable debug mode in production environments',
                    cwe: 'CWE-489'
                });
            }
        }
        
        return vulns;
    }
}

// === Dependency Scanner ===
class DependencyScanner {
    async scan(projectPath: string): Promise<Vulnerability[]> {
        const vulns: Vulnerability[] = [];
        
        try {
            const result = await exec(\`cd \${projectPath} && npm audit --json\`);
            const audit = JSON.parse(result.stdout);
            
            for (const [name, data] of Object.entries(audit.vulnerabilities || {})) {
                vulns.push({
                    id: crypto.randomUUID(),
                    category: 'A06:2021 - Vulnerable and Outdated Components',
                    severity: (data as any).severity,
                    title: \`Vulnerable dependency: \${name}\`,
                    description: (data as any).via?.[0]?.title || 'Known vulnerability',
                    location: { file: 'package.json' },
                    evidence: \`\${name}@\${(data as any).range}\`,
                    remediation: \`Update to \${(data as any).fixAvailable?.version || 'latest'}\`,
                    cwe: (data as any).via?.[0]?.cwe?.[0] || 'Unknown'
                });
            }
        } catch {}
        
        return vulns;
    }
}

export { OWASPScanner, DependencyScanner };
`;
    }
}

export const autoPenTester = AutoPenTester.getInstance();
