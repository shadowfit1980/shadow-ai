/**
 * ðŸ”„ Auto Refactoring Service
 * 
 * Detect and fix code smells:
 * - Technical debt, anti-patterns
 */

import { EventEmitter } from 'events';

export class AutoRefactoring extends EventEmitter {
    private static instance: AutoRefactoring;

    private constructor() { super(); }

    static getInstance(): AutoRefactoring {
        if (!AutoRefactoring.instance) {
            AutoRefactoring.instance = new AutoRefactoring();
        }
        return AutoRefactoring.instance;
    }

    generate(): string {
        return `// Auto Refactoring Service
// Generated by Shadow AI

/**
 * AUTO REFACTORING
 * 
 * Detect and fix code smells, anti-patterns, and technical debt.
 */

interface CodeSmell {
    id: string;
    type: string;
    severity: 'minor' | 'major' | 'critical';
    file: string;
    line: number;
    description: string;
    suggestion: string;
    autoFixable: boolean;
}

// === Code Smell Detector ===
class CodeSmellDetector {
    async detectSmells(projectPath: string): Promise<CodeSmell[]> {
        const smells: CodeSmell[] = [];
        const files = await glob(\`\${projectPath}/**/*.{ts,tsx,js,jsx}\`);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            smells.push(...this.detectLongMethods(file, content));
            smells.push(...this.detectDuplicateCode(file, content));
            smells.push(...this.detectGodClasses(file, content));
            smells.push(...this.detectDeadCode(file, content));
            smells.push(...this.detectMagicNumbers(file, content));
            smells.push(...this.detectComplexConditions(file, content));
        }
        
        return smells;
    }
    
    private detectLongMethods(file: string, content: string): CodeSmell[] {
        const smells: CodeSmell[] = [];
        const ast = parse(content);
        
        traverse(ast, {
            FunctionDeclaration(path) {
                const lines = path.node.loc!.end.line - path.node.loc!.start.line;
                if (lines > 50) {
                    smells.push({
                        id: crypto.randomUUID(),
                        type: 'long-method',
                        severity: lines > 100 ? 'critical' : 'major',
                        file,
                        line: path.node.loc!.start.line,
                        description: \`Method has \${lines} lines (recommended: <50)\`,
                        suggestion: 'Extract smaller, focused functions',
                        autoFixable: true
                    });
                }
            }
        });
        
        return smells;
    }
    
    private detectDuplicateCode(file: string, content: string): CodeSmell[] {
        // Use AST fingerprinting to detect similar code blocks
        const smells: CodeSmell[] = [];
        const chunks = this.extractCodeChunks(content);
        const seen = new Map<string, { file: string; line: number }>();
        
        for (const chunk of chunks) {
            const fingerprint = this.generateFingerprint(chunk.code);
            
            if (seen.has(fingerprint)) {
                const original = seen.get(fingerprint)!;
                smells.push({
                    id: crypto.randomUUID(),
                    type: 'duplicate-code',
                    severity: 'major',
                    file,
                    line: chunk.line,
                    description: \`Duplicate code found (original at \${original.file}:\${original.line})\`,
                    suggestion: 'Extract to shared function or module',
                    autoFixable: true
                });
            } else {
                seen.set(fingerprint, { file, line: chunk.line });
            }
        }
        
        return smells;
    }
    
    private detectMagicNumbers(file: string, content: string): CodeSmell[] {
        const smells: CodeSmell[] = [];
        const lines = content.split('\\n');
        
        lines.forEach((line, idx) => {
            // Detect numbers that aren't 0, 1, -1, or in obvious contexts
            const magicNumbers = line.match(/[^\\w]([2-9]|\\d{2,})(?=[^\\d]|$)/g);
            
            if (magicNumbers && !line.includes('const') && !line.includes('//')) {
                smells.push({
                    id: crypto.randomUUID(),
                    type: 'magic-number',
                    severity: 'minor',
                    file,
                    line: idx + 1,
                    description: \`Magic number detected: \${magicNumbers[0]}\`,
                    suggestion: 'Extract to named constant',
                    autoFixable: true
                });
            }
        });
        
        return smells;
    }
}

// === Auto Fixer ===
class AutoFixer {
    async fix(smell: CodeSmell): Promise<FixResult> {
        switch (smell.type) {
            case 'long-method':
                return this.fixLongMethod(smell);
            case 'duplicate-code':
                return this.fixDuplicateCode(smell);
            case 'magic-number':
                return this.fixMagicNumber(smell);
            default:
                return { success: false, message: 'No auto-fix available' };
        }
    }
    
    private async fixLongMethod(smell: CodeSmell): Promise<FixResult> {
        const content = await fs.readFile(smell.file, 'utf-8');
        
        const prompt = \`
            Refactor this long method by extracting smaller functions:
            
            \${this.extractMethodCode(content, smell.line)}
            
            Requirements:
            - Each extracted function should do one thing
            - Use descriptive names
            - Maintain the original behavior
            - Keep the public interface unchanged
            
            Return the refactored code.
        \`;
        
        const refactored = await this.llm.complete(prompt);
        await fs.writeFile(smell.file, this.replaceMethod(content, smell.line, refactored));
        
        return { success: true, message: 'Method split into smaller functions' };
    }
    
    private async fixMagicNumber(smell: CodeSmell): Promise<FixResult> {
        const content = await fs.readFile(smell.file, 'utf-8');
        const lines = content.split('\\n');
        const line = lines[smell.line - 1];
        
        // Extract the magic number
        const match = line.match(/([2-9]|\\d{2,})/);
        if (!match) return { success: false, message: 'Could not find magic number' };
        
        const number = match[0];
        const constName = await this.suggestConstantName(line, number);
        
        // Add constant at top of file
        const constDeclaration = \`const \${constName} = \${number};\\n\`;
        lines.splice(0, 0, constDeclaration);
        
        // Replace magic number with constant
        lines[smell.line] = line.replace(number, constName);
        
        await fs.writeFile(smell.file, lines.join('\\n'));
        
        return { success: true, message: \`Extracted \${number} to constant \${constName}\` };
    }
    
    private async suggestConstantName(context: string, value: string): Promise<string> {
        const prompt = \`
            Suggest a descriptive constant name for the value \${value} in this context:
            \${context}
            
            Return only the constant name in SCREAMING_SNAKE_CASE.
        \`;
        
        const name = await this.llm.complete(prompt);
        return name.trim().toUpperCase().replace(/[^A-Z0-9_]/g, '_');
    }
}

export { CodeSmellDetector, AutoFixer };
`;
    }
}

export const autoRefactoring = AutoRefactoring.getInstance();
