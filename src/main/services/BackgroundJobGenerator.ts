/**
 * ðŸ”„ BackgroundJobGenerator
 * 
 * Background jobs:
 * - BullMQ, queues, workers
 */

import { EventEmitter } from 'events';

export class BackgroundJobGenerator extends EventEmitter {
    private static instance: BackgroundJobGenerator;
    private constructor() { super(); }
    static getInstance(): BackgroundJobGenerator {
        if (!BackgroundJobGenerator.instance) {
            BackgroundJobGenerator.instance = new BackgroundJobGenerator();
        }
        return BackgroundJobGenerator.instance;
    }

    generate(): string {
        return `// Background Job Generator - BullMQ, queues, workers
// Generated by Shadow AI

import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';

const connection = new IORedis(process.env.REDIS_URL);

// Email Queue
const emailQueue = new Queue('email', { connection });

const emailWorker = new Worker('email', async (job: Job) => {
    const { to, subject, html } = job.data;
    await sendEmail({ to, subject, html });
}, { connection });

emailWorker.on('completed', (job) => {
    console.log(\`Email job \${job.id} completed\`);
});

emailWorker.on('failed', (job, err) => {
    console.error(\`Email job \${job?.id} failed:\`, err);
});

// Generic Job Manager
class JobManager {
    private queues: Map<string, Queue> = new Map();
    private workers: Map<string, Worker> = new Map();
    
    createQueue(name: string) {
        const queue = new Queue(name, { connection });
        this.queues.set(name, queue);
        return queue;
    }
    
    createWorker(name: string, processor: (job: Job) => Promise<any>) {
        const worker = new Worker(name, processor, { connection });
        this.workers.set(name, worker);
        
        worker.on('completed', (job) => console.log(\`[\${name}] Job \${job.id} completed\`));
        worker.on('failed', (job, err) => console.error(\`[\${name}] Job \${job?.id} failed:\`, err));
        
        return worker;
    }
    
    async addJob(queueName: string, data: any, options?: { delay?: number; attempts?: number }) {
        const queue = this.queues.get(queueName);
        if (!queue) throw new Error(\`Queue \${queueName} not found\`);
        
        return queue.add(queueName, data, {
            delay: options?.delay,
            attempts: options?.attempts || 3,
            backoff: { type: 'exponential', delay: 1000 }
        });
    }
    
    async getJobStatus(queueName: string, jobId: string) {
        const queue = this.queues.get(queueName);
        if (!queue) throw new Error(\`Queue \${queueName} not found\`);
        
        const job = await queue.getJob(jobId);
        if (!job) return null;
        
        const state = await job.getState();
        return { id: job.id, state, data: job.data, progress: job.progress };
    }
}

// Scheduled Jobs
class ScheduledJobService {
    async scheduleDaily(queueName: string, data: any, hour: number, minute = 0) {
        const queue = this.queues.get(queueName);
        
        await queue.add(queueName, data, {
            repeat: {
                pattern: \`\${minute} \${hour} * * *\` // cron format
            }
        });
    }
    
    async scheduleWeekly(queueName: string, data: any, dayOfWeek: number, hour: number) {
        const queue = this.queues.get(queueName);
        
        await queue.add(queueName, data, {
            repeat: {
                pattern: \`0 \${hour} * * \${dayOfWeek}\`
            }
        });
    }
}

export { emailQueue, JobManager, ScheduledJobService };
`;
    }
}

export const backgroundJobGenerator = BackgroundJobGenerator.getInstance();
