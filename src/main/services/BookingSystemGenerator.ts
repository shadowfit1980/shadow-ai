/**
 * ðŸ“† BookingSystem Generator
 * 
 * Appointment booking:
 * - Calendar, scheduling, reminders
 */

import { EventEmitter } from 'events';

export class BookingSystemGenerator extends EventEmitter {
    private static instance: BookingSystemGenerator;

    private constructor() { super(); }

    static getInstance(): BookingSystemGenerator {
        if (!BookingSystemGenerator.instance) {
            BookingSystemGenerator.instance = new BookingSystemGenerator();
        }
        return BookingSystemGenerator.instance;
    }

    generate(): string {
        return `// Booking System Generator
// Generated by Shadow AI

/**
 * BOOKING SYSTEM GENERATOR
 * 
 * Appointment booking with calendar integration.
 */

// === Availability System ===
class AvailabilitySystem {
    generateAvailabilityAPI(): string {
        return \`
// Availability Management
interface TimeSlot {
    start: Date;
    end: Date;
    available: boolean;
}

interface AvailabilityRule {
    dayOfWeek: number; // 0-6
    startTime: string; // "09:00"
    endTime: string;   // "17:00"
    slotDuration: number; // minutes
    breakBetweenSlots: number; // minutes
}

export async function getAvailableSlots(
    providerId: string,
    serviceId: string,
    date: Date
): Promise<TimeSlot[]> {
    // Get provider's availability rules
    const rules = await getAvailabilityRules(providerId);
    const dayRule = rules.find(r => r.dayOfWeek === date.getDay());
    
    if (!dayRule) return []; // Provider doesn't work this day
    
    // Get service duration
    const service = await getService(serviceId);
    const duration = service.duration;
    
    // Get existing bookings for the day
    const bookings = await getBookingsForDay(providerId, date);
    
    // Generate all possible slots
    const slots: TimeSlot[] = [];
    let current = parseTime(dayRule.startTime, date);
    const end = parseTime(dayRule.endTime, date);
    
    while (current.getTime() + duration * 60000 <= end.getTime()) {
        const slotEnd = new Date(current.getTime() + duration * 60000);
        
        // Check if slot conflicts with existing booking
        const isBooked = bookings.some(b =>
            (current >= b.start && current < b.end) ||
            (slotEnd > b.start && slotEnd <= b.end)
        );
        
        slots.push({
            start: new Date(current),
            end: slotEnd,
            available: !isBooked
        });
        
        current = new Date(current.getTime() + (duration + dayRule.breakBetweenSlots) * 60000);
    }
    
    return slots;
}
        \`;
    }
}

// === Booking Flow ===
class BookingFlow {
    generateBookingComponent(): string {
        return \`
// Booking Component
export function BookingWidget({
    providerId,
    services
}: {
    providerId: string;
    services: Service[];
}) {
    const [step, setStep] = useState<'service' | 'date' | 'time' | 'details' | 'confirm'>('service');
    const [selectedService, setSelectedService] = useState<Service | null>(null);
    const [selectedDate, setSelectedDate] = useState<Date | null>(null);
    const [selectedSlot, setSelectedSlot] = useState<TimeSlot | null>(null);
    const [customerDetails, setCustomerDetails] = useState({});
    
    const { data: slots } = useQuery(
        ['slots', providerId, selectedService?.id, selectedDate],
        () => getAvailableSlots(providerId, selectedService!.id, selectedDate!),
        { enabled: !!selectedService && !!selectedDate }
    );
    
    const mutation = useMutation(createBooking, {
        onSuccess: (booking) => {
            setStep('confirm');
        }
    });
    
    return (
        <div className="booking-widget">
            {step === 'service' && (
                <ServiceSelection
                    services={services}
                    onSelect={(s) => { setSelectedService(s); setStep('date'); }}
                />
            )}
            
            {step === 'date' && (
                <DatePicker
                    value={selectedDate}
                    onChange={(d) => { setSelectedDate(d); setStep('time'); }}
                    disabledDays={/* blocked days */}
                />
            )}
            
            {step === 'time' && slots && (
                <TimeSlotPicker
                    slots={slots}
                    onSelect={(s) => { setSelectedSlot(s); setStep('details'); }}
                />
            )}
            
            {step === 'details' && (
                <CustomerForm
                    onSubmit={(details) => {
                        setCustomerDetails(details);
                        mutation.mutate({
                            providerId,
                            serviceId: selectedService!.id,
                            start: selectedSlot!.start,
                            customer: details
                        });
                    }}
                />
            )}
            
            {step === 'confirm' && (
                <BookingConfirmation booking={mutation.data} />
            )}
        </div>
    );
}
        \`;
    }
}

// === Reminder System ===
class ReminderSystem {
    generateReminders(): string {
        return \`
// Automated Reminders
import { CronJob } from 'cron';

// Send reminders 24 hours before
new CronJob('0 * * * *', async () => {
    const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);
    const bookings = await getUpcomingBookings(tomorrow);
    
    for (const booking of bookings) {
        if (!booking.reminder24Sent) {
            await sendReminder(booking, '24h');
            await markReminderSent(booking.id, '24h');
        }
    }
}).start();

// Send reminders 1 hour before
new CronJob('*/15 * * * *', async () => {
    const oneHour = new Date(Date.now() + 60 * 60 * 1000);
    const bookings = await getUpcomingBookings(oneHour);
    
    for (const booking of bookings) {
        if (!booking.reminder1hSent) {
            await sendReminder(booking, '1h');
            await markReminderSent(booking.id, '1h');
        }
    }
}).start();

async function sendReminder(booking: Booking, type: string) {
    // Email
    await sendEmail({
        to: booking.customer.email,
        subject: 'Appointment Reminder',
        template: 'appointment-reminder',
        data: { booking, reminderType: type }
    });
    
    // SMS
    if (booking.customer.phone) {
        await sendSMS({
            to: booking.customer.phone,
            message: \\\`Reminder: Your appointment is scheduled for \\\${formatDate(booking.start)}\\\`
        });
    }
}
        \`;
    }
}

export { AvailabilitySystem, BookingFlow, ReminderSystem };
`;
    }
}

export const bookingSystemGenerator = BookingSystemGenerator.getInstance();
