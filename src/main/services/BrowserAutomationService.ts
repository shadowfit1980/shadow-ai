/**
 * üåê BrowserAutomationService
 * 
 * Browser automation:
 * - Puppeteer, Playwright, scraping
 */

import { EventEmitter } from 'events';

export class BrowserAutomationService extends EventEmitter {
    private static instance: BrowserAutomationService;
    private constructor() { super(); }
    static getInstance(): BrowserAutomationService {
        if (!BrowserAutomationService.instance) {
            BrowserAutomationService.instance = new BrowserAutomationService();
        }
        return BrowserAutomationService.instance;
    }

    generate(): string {
        return `// Browser Automation Service - Puppeteer, Playwright
// Generated by Shadow AI

import { chromium, Browser, Page } from 'playwright';

class BrowserAutomation {
    private browser: Browser | null = null;
    private page: Page | null = null;
    
    async launch(headless = true): Promise<void> {
        this.browser = await chromium.launch({ headless });
        this.page = await this.browser.newPage();
    }
    
    async navigate(url: string): Promise<void> {
        if (!this.page) throw new Error('Browser not launched');
        await this.page.goto(url, { waitUntil: 'networkidle' });
    }
    
    async click(selector: string): Promise<void> {
        await this.page?.click(selector);
    }
    
    async type(selector: string, text: string): Promise<void> {
        await this.page?.fill(selector, text);
    }
    
    async screenshot(path: string): Promise<void> {
        await this.page?.screenshot({ path, fullPage: true });
    }
    
    async getPageContent(): Promise<string> {
        return await this.page?.content() || '';
    }
    
    async extractText(selector: string): Promise<string> {
        return await this.page?.textContent(selector) || '';
    }
    
    async extractAll(selector: string): Promise<string[]> {
        const elements = await this.page?.$$eval(selector, els => els.map(el => el.textContent || ''));
        return elements || [];
    }
    
    async waitForSelector(selector: string, timeout = 30000): Promise<void> {
        await this.page?.waitForSelector(selector, { timeout });
    }
    
    async close(): Promise<void> {
        await this.browser?.close();
        this.browser = null;
        this.page = null;
    }
    
    // Execute script in page context
    async evaluate<T>(fn: () => T): Promise<T> {
        return await this.page?.evaluate(fn) as T;
    }
    
    // Scrape structured data
    async scrape<T>(config: ScrapeConfig): Promise<T[]> {
        if (!this.page) throw new Error('Browser not launched');
        
        await this.page.goto(config.url);
        
        const items = await this.page.$$eval(config.itemSelector, (elements, fields) => {
            return elements.map(el => {
                const item: any = {};
                for (const [key, selector] of Object.entries(fields)) {
                    const element = el.querySelector(selector);
                    item[key] = element?.textContent?.trim() || '';
                }
                return item;
            });
        }, config.fields);
        
        return items as T[];
    }
    
    // Record user interaction
    async record(): Promise<RecordedActions> {
        const actions: Action[] = [];
        
        await this.page?.exposeFunction('recordAction', (action: Action) => {
            actions.push(action);
        });
        
        await this.page?.evaluate(() => {
            document.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                (window as any).recordAction({
                    type: 'click',
                    selector: target.tagName + (target.id ? '#' + target.id : '') + (target.className ? '.' + target.className.split(' ').join('.') : '')
                });
            });
            
            document.addEventListener('input', (e) => {
                const target = e.target as HTMLInputElement;
                (window as any).recordAction({
                    type: 'input',
                    selector: target.id || target.name,
                    value: target.value
                });
            });
        });
        
        return { actions, stop: () => actions };
    }
    
    // AI-driven navigation
    async aiNavigate(goal: string): Promise<void> {
        const pageContent = await this.getPageContent();
        
        const response = await llm.chat([{
            role: 'system',
            content: 'Given the page HTML and a goal, return JSON of actions to take: [{ type, selector, value? }]'
        }, {
            role: 'user',
            content: \`Goal: \${goal}\\n\\nPage HTML (truncated):\\n\${pageContent.slice(0, 5000)}\`
        }]);
        
        const actions = JSON.parse(response.content);
        
        for (const action of actions) {
            if (action.type === 'click') await this.click(action.selector);
            if (action.type === 'type') await this.type(action.selector, action.value);
            if (action.type === 'navigate') await this.navigate(action.url);
        }
    }
}

export { BrowserAutomation };
`;
    }
}

export const browserAutomationService = BrowserAutomationService.getInstance();
