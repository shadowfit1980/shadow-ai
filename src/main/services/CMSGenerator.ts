/**
 * üìù CMS Generator
 * 
 * Generate CMS integrations:
 * - Strapi, Sanity, Contentful
 */

import { EventEmitter } from 'events';

export type CMSProvider = 'strapi' | 'sanity' | 'contentful';

export class CMSGenerator extends EventEmitter {
    private static instance: CMSGenerator;

    private constructor() { super(); }

    static getInstance(): CMSGenerator {
        if (!CMSGenerator.instance) {
            CMSGenerator.instance = new CMSGenerator();
        }
        return CMSGenerator.instance;
    }

    getProviders(): CMSProvider[] {
        return ['strapi', 'sanity', 'contentful'];
    }

    generate(provider: CMSProvider): string {
        switch (provider) {
            case 'strapi': return this.generateStrapi();
            case 'sanity': return this.generateSanity();
            case 'contentful': return this.generateContentful();
            default: return '';
        }
    }

    private generateStrapi(): string {
        return `// Strapi CMS Integration
// Generated by Shadow AI

const STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';
const STRAPI_TOKEN = process.env.STRAPI_TOKEN;

export class StrapiClient {
    private baseUrl: string;
    private headers: HeadersInit;

    constructor() {
        this.baseUrl = STRAPI_URL;
        this.headers = {
            'Content-Type': 'application/json',
            ...(STRAPI_TOKEN && { 'Authorization': \`Bearer \${STRAPI_TOKEN}\` })
        };
    }

    async find(collection: string, params: Record<string, any> = {}) {
        const queryString = this.buildQueryString(params);
        const res = await fetch(\`\${this.baseUrl}/api/\${collection}?\${queryString}\`, {
            headers: this.headers
        });
        const data = await res.json();
        return data.data;
    }

    async findOne(collection: string, id: string, params: Record<string, any> = {}) {
        const queryString = this.buildQueryString(params);
        const res = await fetch(\`\${this.baseUrl}/api/\${collection}/\${id}?\${queryString}\`, {
            headers: this.headers
        });
        const data = await res.json();
        return data.data;
    }

    async create(collection: string, data: any) {
        const res = await fetch(\`\${this.baseUrl}/api/\${collection}\`, {
            method: 'POST',
            headers: this.headers,
            body: JSON.stringify({ data })
        });
        return res.json();
    }

    async update(collection: string, id: string, data: any) {
        const res = await fetch(\`\${this.baseUrl}/api/\${collection}/\${id}\`, {
            method: 'PUT',
            headers: this.headers,
            body: JSON.stringify({ data })
        });
        return res.json();
    }

    async delete(collection: string, id: string) {
        await fetch(\`\${this.baseUrl}/api/\${collection}/\${id}\`, {
            method: 'DELETE',
            headers: this.headers
        });
    }

    // Media upload
    async uploadMedia(file: File) {
        const formData = new FormData();
        formData.append('files', file);
        
        const res = await fetch(\`\${this.baseUrl}/api/upload\`, {
            method: 'POST',
            headers: { Authorization: \`Bearer \${STRAPI_TOKEN}\` },
            body: formData
        });
        
        return res.json();
    }

    private buildQueryString(params: Record<string, any>): string {
        const searchParams = new URLSearchParams();
        
        // Populate relations
        if (params.populate) {
            searchParams.set('populate', params.populate);
        }
        
        // Filters
        if (params.filters) {
            Object.entries(params.filters).forEach(([key, value]) => {
                searchParams.set(\`filters[\${key}]\`, String(value));
            });
        }
        
        // Pagination
        if (params.pagination) {
            searchParams.set('pagination[page]', String(params.pagination.page || 1));
            searchParams.set('pagination[pageSize]', String(params.pagination.pageSize || 25));
        }
        
        // Sort
        if (params.sort) {
            searchParams.set('sort', params.sort);
        }
        
        return searchParams.toString();
    }
}

// React hooks
export function useStrapi() {
    const client = new StrapiClient();
    
    const useCollection = (collection: string, params?: any) => {
        return useSWR([collection, params], () => client.find(collection, params));
    };
    
    const useDocument = (collection: string, id: string, params?: any) => {
        return useSWR([collection, id, params], () => client.findOne(collection, id, params));
    };
    
    return { client, useCollection, useDocument };
}
`;
    }

    private generateSanity(): string {
        return `// Sanity CMS Integration
// Generated by Shadow AI

import { createClient, groq } from '@sanity/client';
import imageUrlBuilder from '@sanity/image-url';

export const sanityClient = createClient({
    projectId: process.env.SANITY_PROJECT_ID!,
    dataset: process.env.SANITY_DATASET || 'production',
    apiVersion: '2024-01-01',
    useCdn: process.env.NODE_ENV === 'production',
    token: process.env.SANITY_TOKEN // Optional for mutations
});

const builder = imageUrlBuilder(sanityClient);

export function urlFor(source: any) {
    return builder.image(source);
}

// Queries
export const queries = {
    posts: groq\`*[_type == "post"] | order(publishedAt desc) {
        _id,
        title,
        slug,
        excerpt,
        "author": author->{ name, image },
        mainImage,
        publishedAt,
        categories[]->{ title, slug }
    }\`,
    
    postBySlug: groq\`*[_type == "post" && slug.current == $slug][0] {
        _id,
        title,
        body,
        "author": author->{ name, image, bio },
        mainImage,
        publishedAt,
        categories[]->{ title, slug },
        "related": *[_type == "post" && slug.current != $slug && count(categories[@._ref in ^.^.categories[]._ref]) > 0][0...3] {
            title,
            slug,
            mainImage
        }
    }\`,
    
    pages: groq\`*[_type == "page" && slug.current == $slug][0] {
        title,
        content,
        seo
    }\`
};

// Fetch functions
export async function getPosts() {
    return sanityClient.fetch(queries.posts);
}

export async function getPostBySlug(slug: string) {
    return sanityClient.fetch(queries.postBySlug, { slug });
}

export async function getPage(slug: string) {
    return sanityClient.fetch(queries.pages, { slug });
}

// Schema example
export const postSchema = {
    name: 'post',
    title: 'Post',
    type: 'document',
    fields: [
        { name: 'title', title: 'Title', type: 'string', validation: Rule => Rule.required() },
        { name: 'slug', title: 'Slug', type: 'slug', options: { source: 'title' } },
        { name: 'author', title: 'Author', type: 'reference', to: [{ type: 'author' }] },
        { name: 'mainImage', title: 'Main Image', type: 'image', options: { hotspot: true } },
        { name: 'categories', title: 'Categories', type: 'array', of: [{ type: 'reference', to: [{ type: 'category' }] }] },
        { name: 'publishedAt', title: 'Published At', type: 'datetime' },
        { name: 'body', title: 'Body', type: 'blockContent' }
    ]
};
`;
    }

    private generateContentful(): string {
        return `// Contentful CMS Integration
// Generated by Shadow AI

import { createClient } from 'contentful';

export const contentfulClient = createClient({
    space: process.env.CONTENTFUL_SPACE_ID!,
    accessToken: process.env.CONTENTFUL_ACCESS_TOKEN!,
    environment: process.env.CONTENTFUL_ENVIRONMENT || 'master'
});

// Preview client
export const previewClient = createClient({
    space: process.env.CONTENTFUL_SPACE_ID!,
    accessToken: process.env.CONTENTFUL_PREVIEW_TOKEN!,
    host: 'preview.contentful.com'
});

const client = (preview: boolean) => preview ? previewClient : contentfulClient;

export async function getEntries(contentType: string, options: any = {}) {
    const entries = await contentfulClient.getEntries({
        content_type: contentType,
        ...options
    });
    
    return entries.items.map(item => ({
        id: item.sys.id,
        ...item.fields
    }));
}

export async function getEntry(id: string, preview = false) {
    const entry = await client(preview).getEntry(id);
    return { id: entry.sys.id, ...entry.fields };
}

export async function getEntriesBySlug(contentType: string, slug: string, preview = false) {
    const entries = await client(preview).getEntries({
        content_type: contentType,
        'fields.slug': slug,
        limit: 1
    });
    
    if (entries.items.length === 0) return null;
    const item = entries.items[0];
    return { id: item.sys.id, ...item.fields };
}

// Rich text renderer
import { documentToReactComponents } from '@contentful/rich-text-react-renderer';
import { BLOCKS, INLINES } from '@contentful/rich-text-types';

export const richTextOptions = {
    renderNode: {
        [BLOCKS.EMBEDDED_ASSET]: (node) => {
            const { file, title } = node.data.target.fields;
            return <img src={\`https:\${file.url}\`} alt={title} />;
        },
        [INLINES.HYPERLINK]: (node, children) => (
            <a href={node.data.uri} target="_blank" rel="noopener noreferrer">
                {children}
            </a>
        )
    }
};

export function RichText({ content }) {
    return documentToReactComponents(content, richTextOptions);
}
`;
    }
}

export const cmsGenerator = CMSGenerator.getInstance();
