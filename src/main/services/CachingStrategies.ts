/**
 * ðŸ’¾ Caching Strategies Generator
 * 
 * Generate caching patterns:
 * - Redis, CDN, browser
 */

import { EventEmitter } from 'events';

export class CachingStrategies extends EventEmitter {
    private static instance: CachingStrategies;

    private constructor() { super(); }

    static getInstance(): CachingStrategies {
        if (!CachingStrategies.instance) {
            CachingStrategies.instance = new CachingStrategies();
        }
        return CachingStrategies.instance;
    }

    generate(): string {
        return `// Caching Strategies
// Generated by Shadow AI

import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// === Cache Patterns ===

// 1. Cache-Aside (Lazy Loading)
async function cacheAside<T>(key: string, fetchFn: () => Promise<T>, ttl = 3600): Promise<T> {
    // Try cache first
    const cached = await redis.get(key);
    if (cached) {
        return JSON.parse(cached);
    }

    // Fetch from source
    const data = await fetchFn();

    // Store in cache
    await redis.setex(key, ttl, JSON.stringify(data));

    return data;
}

// Usage
const user = await cacheAside(\`user:\${userId}\`, () => db.user.findUnique({ where: { id: userId } }));

// 2. Write-Through
async function writeThrough<T>(key: string, data: T, saveFn: (data: T) => Promise<T>, ttl = 3600): Promise<T> {
    // Write to database first
    const saved = await saveFn(data);

    // Update cache
    await redis.setex(key, ttl, JSON.stringify(saved));

    return saved;
}

// 3. Write-Behind (Write-Back)
const writeQueue: Array<{ key: string; data: any; saveFn: Function }> = [];
let flushInterval: NodeJS.Timeout;

function writeBehind<T>(key: string, data: T, saveFn: (data: T) => Promise<T>) {
    // Update cache immediately
    redis.set(key, JSON.stringify(data));

    // Queue for batch write
    writeQueue.push({ key, data, saveFn });

    // Start flush timer if not already running
    if (!flushInterval) {
        flushInterval = setInterval(flushWrites, 5000);
    }
}

async function flushWrites() {
    const batch = writeQueue.splice(0, writeQueue.length);
    await Promise.all(batch.map(({ data, saveFn }) => saveFn(data)));
}

// 4. Read-Through with Stale-While-Revalidate
async function staleWhileRevalidate<T>(
    key: string,
    fetchFn: () => Promise<T>,
    ttl = 300,
    staleTtl = 3600
): Promise<T> {
    const cached = await redis.get(key);
    const ttlRemaining = await redis.ttl(key);

    if (cached && ttlRemaining > staleTtl - ttl) {
        // Fresh cache
        return JSON.parse(cached);
    }

    if (cached) {
        // Stale cache - return but revalidate in background
        setImmediate(async () => {
            const fresh = await fetchFn();
            await redis.setex(key, staleTtl, JSON.stringify(fresh));
        });
        return JSON.parse(cached);
    }

    // No cache - fetch synchronously
    const data = await fetchFn();
    await redis.setex(key, staleTtl, JSON.stringify(data));
    return data;
}

// === Cache Invalidation ===
async function invalidate(pattern: string) {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
        await redis.del(...keys);
    }
}

// Tag-based invalidation
async function setWithTags(key: string, data: any, tags: string[], ttl = 3600) {
    const pipeline = redis.pipeline();
    pipeline.setex(key, ttl, JSON.stringify(data));
    tags.forEach(tag => pipeline.sadd(\`tag:\${tag}\`, key));
    await pipeline.exec();
}

async function invalidateByTag(tag: string) {
    const keys = await redis.smembers(\`tag:\${tag}\`);
    if (keys.length > 0) {
        await redis.del(...keys, \`tag:\${tag}\`);
    }
}

// === HTTP Caching Headers ===
function setCacheHeaders(res: any, options: {
    maxAge?: number;
    sMaxAge?: number;
    staleWhileRevalidate?: number;
    staleIfError?: number;
    private?: boolean;
    noStore?: boolean;
    etag?: string;
    lastModified?: Date;
}) {
    const directives = [];

    if (options.noStore) {
        directives.push('no-store');
    } else {
        directives.push(options.private ? 'private' : 'public');
        if (options.maxAge !== undefined) directives.push(\`max-age=\${options.maxAge}\`);
        if (options.sMaxAge !== undefined) directives.push(\`s-maxage=\${options.sMaxAge}\`);
        if (options.staleWhileRevalidate !== undefined) directives.push(\`stale-while-revalidate=\${options.staleWhileRevalidate}\`);
        if (options.staleIfError !== undefined) directives.push(\`stale-if-error=\${options.staleIfError}\`);
    }

    res.setHeader('Cache-Control', directives.join(', '));

    if (options.etag) res.setHeader('ETag', options.etag);
    if (options.lastModified) res.setHeader('Last-Modified', options.lastModified.toUTCString());
}

// Conditional request handling
function handleConditionalRequest(req: any, res: any, etag: string, lastModified: Date): boolean {
    const ifNoneMatch = req.headers['if-none-match'];
    const ifModifiedSince = req.headers['if-modified-since'];

    if (ifNoneMatch === etag || (ifModifiedSince && new Date(ifModifiedSince) >= lastModified)) {
        res.status(304).end();
        return true;
    }
    return false;
}

// === CDN / Edge Caching ===
/*
Vercel Edge Config:
// next.config.js
{
    async headers() {
        return [{
            source: '/api/public/:path*',
            headers: [
                { key: 'Cache-Control', value: 'public, s-maxage=3600, stale-while-revalidate=86400' }
            ]
        }];
    }
}

Cloudflare:
// _headers
/api/*
  Cache-Control: public, max-age=300, s-maxage=3600
  CDN-Cache-Control: max-age=86400
  Cloudflare-CDN-Cache-Control: max-age=86400
*/

export { cacheAside, writeThrough, writeBehind, staleWhileRevalidate, invalidate, invalidateByTag, setCacheHeaders };
`;
    }
}

export const cachingStrategies = CachingStrategies.getInstance();
