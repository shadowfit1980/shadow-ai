/**
 * ðŸ“ ChangelogAutomation
 * 
 * Changelog automation:
 * - Conventional commits, releases
 */

import { EventEmitter } from 'events';

export class ChangelogAutomation extends EventEmitter {
    private static instance: ChangelogAutomation;
    private constructor() { super(); }
    static getInstance(): ChangelogAutomation {
        if (!ChangelogAutomation.instance) {
            ChangelogAutomation.instance = new ChangelogAutomation();
        }
        return ChangelogAutomation.instance;
    }

    generate(): string {
        return `// Changelog Automation - Conventional commits, releases
// Generated by Shadow AI

// Conventional Commit Parser
class CommitParser {
    parse(message: string): ParsedCommit | null {
        const regex = /^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(?:\\(([^)]+)\\))?(!)?:\\s*(.+)$/;
        const match = message.match(regex);
        
        if (!match) return null;
        
        return {
            type: match[1] as CommitType,
            scope: match[2] || null,
            breaking: !!match[3],
            description: match[4]
        };
    }
    
    categorize(commits: ParsedCommit[]) {
        const categories = {
            features: commits.filter(c => c.type === 'feat'),
            fixes: commits.filter(c => c.type === 'fix'),
            breaking: commits.filter(c => c.breaking),
            docs: commits.filter(c => c.type === 'docs'),
            perf: commits.filter(c => c.type === 'perf'),
            other: commits.filter(c => !['feat', 'fix', 'docs', 'perf'].includes(c.type))
        };
        return categories;
    }
}

// Version Calculator
class VersionCalculator {
    calculate(currentVersion: string, commits: ParsedCommit[]): string {
        const [major, minor, patch] = currentVersion.split('.').map(Number);
        
        const hasBreaking = commits.some(c => c.breaking);
        const hasFeatures = commits.some(c => c.type === 'feat');
        const hasFixes = commits.some(c => c.type === 'fix');
        
        if (hasBreaking) return \`\${major + 1}.0.0\`;
        if (hasFeatures) return \`\${major}.\${minor + 1}.0\`;
        if (hasFixes) return \`\${major}.\${minor}.\${patch + 1}\`;
        
        return currentVersion;
    }
}

// Changelog Renderer
class ChangelogRendererService {
    render(version: string, date: string, categories: any): string {
        let changelog = \`## [\${version}] - \${date}\\n\\n\`;
        
        if (categories.breaking.length > 0) {
            changelog += \`### âš ï¸ BREAKING CHANGES\\n\\n\`;
            categories.breaking.forEach((c: any) => {
                changelog += \`- \${c.scope ? \`**\${c.scope}**: \` : ''}\${c.description}\\n\`;
            });
            changelog += '\\n';
        }
        
        if (categories.features.length > 0) {
            changelog += \`### âœ¨ Features\\n\\n\`;
            categories.features.forEach((c: any) => {
                changelog += \`- \${c.scope ? \`**\${c.scope}**: \` : ''}\${c.description}\\n\`;
            });
            changelog += '\\n';
        }
        
        if (categories.fixes.length > 0) {
            changelog += \`### ðŸ› Bug Fixes\\n\\n\`;
            categories.fixes.forEach((c: any) => {
                changelog += \`- \${c.scope ? \`**\${c.scope}**: \` : ''}\${c.description}\\n\`;
            });
            changelog += '\\n';
        }
        
        return changelog;
    }
}

export { CommitParser, VersionCalculator, ChangelogRendererService };
`;
    }
}

export const changelogAutomation = ChangelogAutomation.getInstance();
