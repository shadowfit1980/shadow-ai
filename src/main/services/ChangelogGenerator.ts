/**
 * üìù Changelog Generator
 * 
 * Generate CHANGELOGs:
 * - Conventional commits, semver
 */

import { EventEmitter } from 'events';

export class ChangelogGenerator extends EventEmitter {
    private static instance: ChangelogGenerator;

    private constructor() { super(); }

    static getInstance(): ChangelogGenerator {
        if (!ChangelogGenerator.instance) {
            ChangelogGenerator.instance = new ChangelogGenerator();
        }
        return ChangelogGenerator.instance;
    }

    generate(releases: Array<{
        version: string;
        date: string;
        changes: Array<{ type: string; scope?: string; description: string }>;
    }>): string {
        let changelog = `# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

`;
        for (const release of releases) {
            changelog += this.formatRelease(release);
        }

        return changelog;
    }

    private formatRelease(release: { version: string; date: string; changes: Array<{ type: string; scope?: string; description: string }> }): string {
        const groups: Record<string, string[]> = {
            'Added': [],
            'Changed': [],
            'Deprecated': [],
            'Removed': [],
            'Fixed': [],
            'Security': []
        };

        const typeMap: Record<string, string> = {
            'feat': 'Added',
            'feature': 'Added',
            'fix': 'Fixed',
            'bugfix': 'Fixed',
            'change': 'Changed',
            'refactor': 'Changed',
            'perf': 'Changed',
            'deprecate': 'Deprecated',
            'remove': 'Removed',
            'security': 'Security',
            'docs': 'Changed',
            'style': 'Changed',
            'test': 'Changed',
            'chore': 'Changed'
        };

        for (const change of release.changes) {
            const group = typeMap[change.type.toLowerCase()] || 'Changed';
            const scope = change.scope ? `**${change.scope}:** ` : '';
            groups[group].push(`- ${scope}${change.description}`);
        }

        let output = `## [${release.version}] - ${release.date}\n\n`;

        for (const [group, items] of Object.entries(groups)) {
            if (items.length > 0) {
                output += `### ${group}\n\n${items.join('\n')}\n\n`;
            }
        }

        return output;
    }

    generateFromCommits(): string {
        return `// Changelog Generator Script
// Generated by Shadow AI

const { execSync } = require('child_process');
const fs = require('fs');

// Parse git log
function getCommits(since?: string) {
    const range = since ? \`\${since}..HEAD\` : 'HEAD';
    const log = execSync(
        \`git log \${range} --pretty=format:'%H|%s|%b|%ad' --date=short\`,
        { encoding: 'utf-8' }
    );
    
    return log.split('\\n').filter(Boolean).map(line => {
        const [hash, subject, body, date] = line.split('|');
        const match = subject.match(/^(\\w+)(\\(([^)]+)\\))?:\\s*(.+)$/);
        
        if (match) {
            return {
                hash,
                type: match[1],
                scope: match[3],
                description: match[4],
                body,
                date,
                breaking: body.includes('BREAKING CHANGE') || subject.includes('!')
            };
        }
        
        return { hash, type: 'other', description: subject, date };
    });
}

// Get version from package.json
function getCurrentVersion() {
    const pkg = JSON.parse(fs.readFileSync('package.json', 'utf-8'));
    return pkg.version;
}

// Calculate next version
function getNextVersion(commits, currentVersion) {
    const [major, minor, patch] = currentVersion.split('.').map(Number);
    
    const hasBreaking = commits.some(c => c.breaking);
    const hasFeature = commits.some(c => c.type === 'feat');
    
    if (hasBreaking) return \`\${major + 1}.0.0\`;
    if (hasFeature) return \`\${major}.\${minor + 1}.0\`;
    return \`\${major}.\${minor}.\${patch + 1}\`;
}

// Generate entry
function generateEntry(version, date, commits) {
    const groups = {
        'Added': commits.filter(c => c.type === 'feat'),
        'Fixed': commits.filter(c => c.type === 'fix'),
        'Changed': commits.filter(c => ['refactor', 'perf', 'docs'].includes(c.type)),
        'Breaking': commits.filter(c => c.breaking)
    };
    
    let entry = \`## [\${version}] - \${date}\\n\\n\`;
    
    for (const [group, items] of Object.entries(groups)) {
        if (items.length > 0) {
            entry += \`### \${group}\\n\\n\`;
            for (const item of items) {
                const scope = item.scope ? \`**\${item.scope}:** \` : '';
                entry += \`- \${scope}\${item.description}\\n\`;
            }
            entry += '\\n';
        }
    }
    
    return entry;
}

// Main
const lastTag = execSync('git describe --tags --abbrev=0 2>/dev/null || echo ""', { encoding: 'utf-8' }).trim();
const commits = getCommits(lastTag);
const currentVersion = getCurrentVersion();
const nextVersion = getNextVersion(commits, currentVersion);
const date = new Date().toISOString().split('T')[0];

const entry = generateEntry(nextVersion, date, commits);

// Prepend to CHANGELOG.md
const existing = fs.existsSync('CHANGELOG.md') ? fs.readFileSync('CHANGELOG.md', 'utf-8') : '';
const headerEnd = existing.indexOf('## [');
const header = headerEnd > -1 ? existing.slice(0, headerEnd) : '# Changelog\\n\\n';
const rest = headerEnd > -1 ? existing.slice(headerEnd) : '';

fs.writeFileSync('CHANGELOG.md', header + entry + rest);
console.log(\`Generated changelog for version \${nextVersion}\`);
`;
    }
}

export const changelogGenerator = ChangelogGenerator.getInstance();
