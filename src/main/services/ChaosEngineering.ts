/**
 * üî• Chaos Engineering Generator
 * 
 * Generate resilience testing:
 * - Fault injection, chaos experiments
 */

import { EventEmitter } from 'events';

export class ChaosEngineering extends EventEmitter {
    private static instance: ChaosEngineering;

    private constructor() { super(); }

    static getInstance(): ChaosEngineering {
        if (!ChaosEngineering.instance) {
            ChaosEngineering.instance = new ChaosEngineering();
        }
        return ChaosEngineering.instance;
    }

    generate(): string {
        return `// Chaos Engineering
// Generated by Shadow AI

// === Fault Injection Middleware ===

interface ChaosConfig {
    enabled: boolean;
    latency?: { min: number; max: number; percentage: number };
    error?: { code: number; percentage: number };
    timeout?: { duration: number; percentage: number };
}

const chaosConfig: ChaosConfig = {
    enabled: process.env.CHAOS_ENABLED === 'true',
    latency: { min: 100, max: 2000, percentage: 10 },
    error: { code: 500, percentage: 5 },
    timeout: { duration: 30000, percentage: 2 }
};

function shouldApply(percentage: number): boolean {
    return Math.random() * 100 < percentage;
}

// Express middleware
function chaosMiddleware(req: any, res: any, next: any) {
    if (!chaosConfig.enabled) return next();

    // Random latency injection
    if (chaosConfig.latency && shouldApply(chaosConfig.latency.percentage)) {
        const delay = Math.random() * (chaosConfig.latency.max - chaosConfig.latency.min) + chaosConfig.latency.min;
        console.log(\`[CHAOS] Injecting \${Math.round(delay)}ms latency\`);
        return setTimeout(next, delay);
    }

    // Random error injection
    if (chaosConfig.error && shouldApply(chaosConfig.error.percentage)) {
        console.log(\`[CHAOS] Injecting error \${chaosConfig.error.code}\`);
        return res.status(chaosConfig.error.code).json({
            error: 'Chaos injection: Simulated failure',
            chaos: true
        });
    }

    // Random timeout
    if (chaosConfig.timeout && shouldApply(chaosConfig.timeout.percentage)) {
        console.log(\`[CHAOS] Injecting timeout\`);
        // Don't call next, let request timeout
        return;
    }

    next();
}

// === Chaos HTTP Client ===
class ChaosHttpClient {
    private config: ChaosConfig;

    constructor(config: ChaosConfig) {
        this.config = config;
    }

    async fetch(url: string, options?: RequestInit): Promise<Response> {
        if (this.config.enabled) {
            // Simulate network failure
            if (shouldApply(5)) {
                throw new Error('Chaos: Network failure simulated');
            }

            // Simulate slow response
            if (this.config.latency && shouldApply(this.config.latency.percentage)) {
                const delay = Math.random() * this.config.latency.max;
                await new Promise(r => setTimeout(r, delay));
            }
        }

        return fetch(url, options);
    }
}

// === Chaos Experiment Runner ===
interface Experiment {
    name: string;
    description: string;
    hypothesis: string;
    steadyState: () => Promise<boolean>;
    action: () => Promise<void>;
    rollback: () => Promise<void>;
}

async function runExperiment(experiment: Experiment): Promise<{
    name: string;
    success: boolean;
    steadyStateBefore: boolean;
    steadyStateAfter: boolean;
    error?: string;
}> {
    console.log(\`\\nüî¨ Running experiment: \${experiment.name}\`);
    console.log(\`   Hypothesis: \${experiment.hypothesis}\`);

    const result = {
        name: experiment.name,
        success: false,
        steadyStateBefore: false,
        steadyStateAfter: false,
        error: undefined as string | undefined
    };

    try {
        // Check steady state before
        console.log('   Checking steady state before...');
        result.steadyStateBefore = await experiment.steadyState();
        if (!result.steadyStateBefore) {
            throw new Error('System not in steady state before experiment');
        }

        // Execute chaos action
        console.log('   Executing chaos action...');
        await experiment.action();

        // Wait for system to react
        await new Promise(r => setTimeout(r, 5000));

        // Check steady state after
        console.log('   Checking steady state after...');
        result.steadyStateAfter = await experiment.steadyState();
        result.success = result.steadyStateAfter;

        console.log(result.success ? '   ‚úÖ Experiment passed!' : '   ‚ùå Experiment failed!');

    } catch (error: any) {
        result.error = error.message;
        console.log(\`   ‚ùå Experiment error: \${error.message}\`);
    } finally {
        // Always rollback
        console.log('   Rolling back...');
        await experiment.rollback();
    }

    return result;
}

// === Example Experiments ===
const experiments: Experiment[] = [
    {
        name: 'Database Failure',
        description: 'Simulate database connection failure',
        hypothesis: 'The system should gracefully degrade and return cached data',
        
        async steadyState() {
            const response = await fetch('http://localhost:3000/health');
            return response.ok;
        },
        
        async action() {
            // Kill database connection
            await fetch('http://localhost:3000/chaos/kill-db', { method: 'POST' });
        },
        
        async rollback() {
            // Restore database connection
            await fetch('http://localhost:3000/chaos/restore-db', { method: 'POST' });
        }
    },
    {
        name: 'High Latency',
        description: 'Inject 5 second latency to external API calls',
        hypothesis: 'The system should timeout gracefully and show loading state',
        
        async steadyState() {
            const start = Date.now();
            const response = await fetch('http://localhost:3000/api/data');
            const duration = Date.now() - start;
            return response.ok && duration < 3000;
        },
        
        async action() {
            await fetch('http://localhost:3000/chaos/set-latency', {
                method: 'POST',
                body: JSON.stringify({ latency: 5000 })
            });
        },
        
        async rollback() {
            await fetch('http://localhost:3000/chaos/set-latency', {
                method: 'POST',
                body: JSON.stringify({ latency: 0 })
            });
        }
    }
];

// Run all experiments
async function runAllExperiments() {
    const results = [];
    for (const experiment of experiments) {
        const result = await runExperiment(experiment);
        results.push(result);
    }
    
    console.log('\\nüìä Experiment Results:');
    results.forEach(r => {
        console.log(\`   \${r.success ? '‚úÖ' : '‚ùå'} \${r.name}\`);
    });
}

export { chaosMiddleware, ChaosHttpClient, runExperiment, runAllExperiments, experiments };
`;
    }
}

export const chaosEngineering = ChaosEngineering.getInstance();
