/**
 * ðŸ’¬ ChatSystem Generator
 * 
 * Real-time chat features:
 * - Messaging, channels, reactions
 */

import { EventEmitter } from 'events';

export class ChatSystemGenerator extends EventEmitter {
    private static instance: ChatSystemGenerator;

    private constructor() { super(); }

    static getInstance(): ChatSystemGenerator {
        if (!ChatSystemGenerator.instance) {
            ChatSystemGenerator.instance = new ChatSystemGenerator();
        }
        return ChatSystemGenerator.instance;
    }

    generate(): string {
        return `// Chat System Generator
// Generated by Shadow AI

/**
 * CHAT SYSTEM GENERATOR
 * 
 * Real-time messaging with channels and reactions.
 */

// === Message Schema ===
const messageSchema = \`
model Conversation {
    id          String   @id @default(cuid())
    type        ConversationType @default(DIRECT)
    name        String?
    
    participants ConversationParticipant[]
    messages     Message[]
    
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
}

model ConversationParticipant {
    id             String   @id @default(cuid())
    
    user           User     @relation(fields: [userId], references: [id])
    userId         String
    
    conversation   Conversation @relation(fields: [conversationId], references: [id])
    conversationId String
    
    role           ParticipantRole @default(MEMBER)
    lastReadAt     DateTime?
    
    @@unique([userId, conversationId])
}

model Message {
    id             String   @id @default(cuid())
    content        String
    type           MessageType @default(TEXT)
    
    sender         User     @relation(fields: [senderId], references: [id])
    senderId       String
    
    conversation   Conversation @relation(fields: [conversationId], references: [id])
    conversationId String
    
    replyTo        Message? @relation("replies", fields: [replyToId], references: [id])
    replyToId      String?
    replies        Message[] @relation("replies")
    
    reactions      Reaction[]
    attachments    Attachment[]
    
    editedAt       DateTime?
    deletedAt      DateTime?
    
    createdAt      DateTime @default(now())
}

model Reaction {
    id        String   @id @default(cuid())
    emoji     String
    
    user      User     @relation(fields: [userId], references: [id])
    userId    String
    
    message   Message  @relation(fields: [messageId], references: [id])
    messageId String
    
    @@unique([userId, messageId, emoji])
}
\`;

// === WebSocket Handler ===
class ChatWebSocket {
    generateServer(): string {
        return \`
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { Redis } from 'ioredis';

const pubClient = new Redis(process.env.REDIS_URL);
const subClient = pubClient.duplicate();

const io = new Server({
    cors: { origin: '*' },
    adapter: createAdapter(pubClient, subClient)
});

io.use(async (socket, next) => {
    const token = socket.handshake.auth.token;
    const user = await verifyToken(token);
    if (!user) return next(new Error('Unauthorized'));
    socket.data.user = user;
    next();
});

io.on('connection', async (socket) => {
    const userId = socket.data.user.id;
    
    // Join user's conversations
    const conversations = await getUserConversations(userId);
    for (const conv of conversations) {
        socket.join(conv.id);
    }
    
    // Handle typing indicators
    socket.on('typing:start', (conversationId) => {
        socket.to(conversationId).emit('typing', {
            userId,
            conversationId
        });
    });
    
    socket.on('typing:stop', (conversationId) => {
        socket.to(conversationId).emit('typing:stop', {
            userId,
            conversationId
        });
    });
    
    // Handle messages
    socket.on('message:send', async (data) => {
        const message = await createMessage({
            conversationId: data.conversationId,
            senderId: userId,
            content: data.content,
            type: data.type || 'TEXT',
            replyToId: data.replyToId
        });
        
        io.to(data.conversationId).emit('message:new', message);
    });
    
    // Handle reactions
    socket.on('reaction:add', async ({ messageId, emoji }) => {
        const reaction = await addReaction(messageId, userId, emoji);
        const message = await getMessage(messageId);
        io.to(message.conversationId).emit('reaction:added', reaction);
    });
    
    socket.on('reaction:remove', async ({ messageId, emoji }) => {
        await removeReaction(messageId, userId, emoji);
        const message = await getMessage(messageId);
        io.to(message.conversationId).emit('reaction:removed', { messageId, userId, emoji });
    });
    
    // Handle read receipts
    socket.on('message:read', async (conversationId) => {
        await markAsRead(userId, conversationId);
        socket.to(conversationId).emit('message:read', { userId, conversationId });
    });
});
        \`;
    }
}

// === React Chat Component ===
class ChatComponent {
    generateChatUI(): string {
        return \`
export function Chat({ conversationId }: { conversationId: string }) {
    const { user } = useAuth();
    const [messages, setMessages] = useState<Message[]>([]);
    const [newMessage, setNewMessage] = useState('');
    const [typing, setTyping] = useState<string[]>([]);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        socket.emit('join', conversationId);
        
        socket.on('message:new', (message) => {
            setMessages(prev => [...prev, message]);
        });
        
        socket.on('typing', ({ userId }) => {
            setTyping(prev => [...prev, userId]);
        });
        
        socket.on('typing:stop', ({ userId }) => {
            setTyping(prev => prev.filter(id => id !== userId));
        });
        
        return () => {
            socket.emit('leave', conversationId);
        };
    }, [conversationId]);
    
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    const sendMessage = () => {
        if (!newMessage.trim()) return;
        
        socket.emit('message:send', {
            conversationId,
            content: newMessage
        });
        
        setNewMessage('');
    };
    
    return (
        <div className="chat">
            <div className="messages">
                {messages.map(msg => (
                    <MessageBubble
                        key={msg.id}
                        message={msg}
                        isOwn={msg.senderId === user.id}
                    />
                ))}
                <div ref={messagesEndRef} />
            </div>
            
            {typing.length > 0 && (
                <TypingIndicator users={typing} />
            )}
            
            <div className="input">
                <input
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    onFocus={() => socket.emit('typing:start', conversationId)}
                    onBlur={() => socket.emit('typing:stop', conversationId)}
                    onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                    placeholder="Type a message..."
                />
                <button onClick={sendMessage}>Send</button>
            </div>
        </div>
    );
}
        \`;
    }
}

export { messageSchema, ChatWebSocket, ChatComponent };
`;
    }
}

export const chatSystemGenerator = ChatSystemGenerator.getInstance();
