/**
 * ðŸ¤– ChatbotGenerator
 * 
 * AI chatbots:
 * - Conversational AI, intents, entities
 */

import { EventEmitter } from 'events';

export class ChatbotGenerator extends EventEmitter {
    private static instance: ChatbotGenerator;
    private constructor() { super(); }
    static getInstance(): ChatbotGenerator {
        if (!ChatbotGenerator.instance) {
            ChatbotGenerator.instance = new ChatbotGenerator();
        }
        return ChatbotGenerator.instance;
    }

    generate(): string {
        return `// Chatbot Generator - Conversational AI, intents, entities
// Generated by Shadow AI

import OpenAI from 'openai';

// Chatbot Engine
class ChatbotEngine {
    private openai: OpenAI;
    private systemPrompt: string;
    private conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = [];
    
    constructor(systemPrompt: string) {
        this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
        this.systemPrompt = systemPrompt;
    }
    
    async chat(userMessage: string): Promise<string> {
        this.conversationHistory.push({ role: 'user', content: userMessage });
        
        const response = await this.openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [
                { role: 'system', content: this.systemPrompt },
                ...this.conversationHistory
            ],
            temperature: 0.7,
            max_tokens: 1000
        });
        
        const assistantMessage = response.choices[0].message.content!;
        this.conversationHistory.push({ role: 'assistant', content: assistantMessage });
        
        return assistantMessage;
    }
    
    clearHistory() {
        this.conversationHistory = [];
    }
}

// Intent Classification
class IntentClassifier {
    private intents: Map<string, string[]> = new Map();
    
    addIntent(name: string, examples: string[]) {
        this.intents.set(name, examples);
    }
    
    async classify(text: string): Promise<{ intent: string; confidence: number }> {
        const allIntents = Array.from(this.intents.keys());
        
        const response = await openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [{
                role: 'system',
                content: \`Classify the user's intent. Available intents: \${allIntents.join(', ')}. Respond with JSON: {"intent": "...", "confidence": 0.0-1.0}\`
            }, {
                role: 'user',
                content: text
            }],
            response_format: { type: 'json_object' }
        });
        
        return JSON.parse(response.choices[0].message.content!);
    }
}

// Entity Extraction
class EntityExtractor {
    async extract(text: string, entityTypes: string[]): Promise<Record<string, any>> {
        const response = await openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [{
                role: 'system',
                content: \`Extract entities from the text. Entity types: \${entityTypes.join(', ')}. Respond with JSON.\`
            }, {
                role: 'user',
                content: text
            }],
            response_format: { type: 'json_object' }
        });
        
        return JSON.parse(response.choices[0].message.content!);
    }
}

// Chat Widget Component
export function ChatWidget({ botName, systemPrompt }: { botName: string; systemPrompt: string }) {
    const [messages, setMessages] = useState<Message[]>([]);
    const [input, setInput] = useState('');
    const [isOpen, setIsOpen] = useState(false);
    const chatbot = useRef(new ChatbotEngine(systemPrompt));
    
    const sendMessage = async () => {
        if (!input.trim()) return;
        
        setMessages(prev => [...prev, { role: 'user', content: input }]);
        setInput('');
        
        const response = await chatbot.current.chat(input);
        setMessages(prev => [...prev, { role: 'assistant', content: response }]);
    };
    
    return (
        <div className={\`chat-widget \${isOpen ? 'open' : ''}\`}>
            <button className="chat-toggle" onClick={() => setIsOpen(!isOpen)}>
                {isOpen ? 'Ã—' : 'ðŸ’¬'}
            </button>
            {isOpen && (
                <div className="chat-container">
                    <div className="chat-header">{botName}</div>
                    <div className="chat-messages">
                        {messages.map((m, i) => (
                            <div key={i} className={\`message \${m.role}\`}>{m.content}</div>
                        ))}
                    </div>
                    <div className="chat-input">
                        <input value={input} onChange={(e) => setInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && sendMessage()} />
                        <button onClick={sendMessage}>Send</button>
                    </div>
                </div>
            )}
        </div>
    );
}

export { ChatbotEngine, IntentClassifier, EntityExtractor };
`;
    }
}

export const chatbotGenerator = ChatbotGenerator.getInstance();
