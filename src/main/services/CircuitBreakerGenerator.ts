/**
 * ðŸ”„ CircuitBreakerGenerator
 * 
 * Circuit breaker:
 * - Failure handling, retries, fallbacks
 */

import { EventEmitter } from 'events';

export class CircuitBreakerGenerator extends EventEmitter {
    private static instance: CircuitBreakerGenerator;
    private constructor() { super(); }
    static getInstance(): CircuitBreakerGenerator {
        if (!CircuitBreakerGenerator.instance) {
            CircuitBreakerGenerator.instance = new CircuitBreakerGenerator();
        }
        return CircuitBreakerGenerator.instance;
    }

    generate(): string {
        return `// Circuit Breaker Generator - Failure handling, retries
// Generated by Shadow AI

type CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';

class CircuitBreaker {
    private state: CircuitState = 'CLOSED';
    private failures = 0;
    private successes = 0;
    private lastFailureTime: number | null = null;
    private nextAttempt: number = 0;
    
    constructor(
        private options: {
            failureThreshold: number;
            successThreshold: number;
            timeout: number;
            resetTimeout: number;
        } = {
            failureThreshold: 5,
            successThreshold: 2,
            timeout: 10000,
            resetTimeout: 30000
        }
    ) {}
    
    async execute<T>(fn: () => Promise<T>, fallback?: () => T): Promise<T> {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                if (fallback) return fallback();
                throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
        }
        
        try {
            const result = await this.callWithTimeout(fn);
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            if (fallback) return fallback();
            throw error;
        }
    }
    
    private async callWithTimeout<T>(fn: () => Promise<T>): Promise<T> {
        return Promise.race([
            fn(),
            new Promise<never>((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), this.options.timeout)
            )
        ]);
    }
    
    private onSuccess() {
        this.failures = 0;
        
        if (this.state === 'HALF_OPEN') {
            this.successes++;
            if (this.successes >= this.options.successThreshold) {
                this.state = 'CLOSED';
                this.successes = 0;
            }
        }
    }
    
    private onFailure() {
        this.failures++;
        this.lastFailureTime = Date.now();
        
        if (this.state === 'HALF_OPEN') {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.options.resetTimeout;
        } else if (this.failures >= this.options.failureThreshold) {
            this.state = 'OPEN';
            this.nextAttempt = Date.now() + this.options.resetTimeout;
        }
    }
    
    getState(): { state: CircuitState; failures: number } {
        return { state: this.state, failures: this.failures };
    }
}

// Circuit Breaker Registry
class CircuitBreakerRegistry {
    private breakers: Map<string, CircuitBreaker> = new Map();
    
    get(name: string): CircuitBreaker {
        if (!this.breakers.has(name)) {
            this.breakers.set(name, new CircuitBreaker());
        }
        return this.breakers.get(name)!;
    }
    
    getAll(): Record<string, { state: CircuitState; failures: number }> {
        const result: Record<string, any> = {};
        for (const [name, breaker] of this.breakers) {
            result[name] = breaker.getState();
        }
        return result;
    }
}

// Usage Example
const registry = new CircuitBreakerRegistry();

async function callExternalAPI() {
    const breaker = registry.get('external-api');
    
    return breaker.execute(
        () => fetch('https://api.example.com/data').then(r => r.json()),
        () => ({ cached: true, data: getCachedData() })
    );
}

export { CircuitBreaker, CircuitBreakerRegistry, callExternalAPI };
`;
    }
}

export const circuitBreakerGenerator = CircuitBreakerGenerator.getInstance();
