/**
 * ðŸ“ CodeAnalysisService
 * 
 * Code analysis for agents:
 * - AST, dependencies, complexity
 */

import { EventEmitter } from 'events';

export class CodeAnalysisService extends EventEmitter {
    private static instance: CodeAnalysisService;
    private constructor() { super(); }
    static getInstance(): CodeAnalysisService {
        if (!CodeAnalysisService.instance) {
            CodeAnalysisService.instance = new CodeAnalysisService();
        }
        return CodeAnalysisService.instance;
    }

    generate(): string {
        return `// Code Analysis Service - AST, dependencies, complexity
// Generated by Shadow AI

import * as ts from 'typescript';
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';

class CodeAnalyzer {
    // Analyze TypeScript/JavaScript file
    analyzeFile(filePath: string, content: string): FileAnalysis {
        const isTs = filePath.endsWith('.ts') || filePath.endsWith('.tsx');
        
        const ast = isTs 
            ? ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true)
            : parser.parse(content, { sourceType: 'module', plugins: ['jsx', 'typescript'] });
        
        return {
            imports: this.extractImports(ast, isTs),
            exports: this.extractExports(ast, isTs),
            functions: this.extractFunctions(ast, isTs),
            classes: this.extractClasses(ast, isTs),
            complexity: this.calculateComplexity(ast, isTs),
            dependencies: this.extractDependencies(content),
            lineCount: content.split('\\n').length
        };
    }
    
    // Extract imports
    extractImports(ast: any, isTs: boolean): Import[] {
        const imports: Import[] = [];
        
        if (isTs) {
            ts.forEachChild(ast, node => {
                if (ts.isImportDeclaration(node)) {
                    imports.push({
                        module: (node.moduleSpecifier as ts.StringLiteral).text,
                        named: [],
                        default: null
                    });
                }
            });
        }
        
        return imports;
    }
    
    // Extract function definitions
    extractFunctions(ast: any, isTs: boolean): FunctionInfo[] {
        const functions: FunctionInfo[] = [];
        
        if (isTs) {
            const visit = (node: ts.Node) => {
                if (ts.isFunctionDeclaration(node) && node.name) {
                    functions.push({
                        name: node.name.text,
                        params: node.parameters.map(p => p.name.getText()),
                        startLine: ast.getLineAndCharacterOfPosition(node.getStart()).line + 1,
                        endLine: ast.getLineAndCharacterOfPosition(node.getEnd()).line + 1,
                        async: !!node.modifiers?.some(m => m.kind === ts.SyntaxKind.AsyncKeyword)
                    });
                }
                ts.forEachChild(node, visit);
            };
            visit(ast);
        }
        
        return functions;
    }
    
    // Calculate cyclomatic complexity
    calculateComplexity(ast: any, isTs: boolean): number {
        let complexity = 1;
        
        const incrementors = ['if', 'else', 'case', 'for', 'while', 'do', 'catch', '&&', '||', '?'];
        
        const content = isTs ? ast.getText() : JSON.stringify(ast);
        
        for (const inc of incrementors) {
            const regex = new RegExp(\`\\\\b\${inc}\\\\b\`, 'g');
            const matches = content.match(regex);
            if (matches) complexity += matches.length;
        }
        
        return complexity;
    }
    
    // Analyze dependencies
    analyzeDependencies(packageJsonPath: string): DependencyGraph {
        const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
        
        return {
            dependencies: Object.keys(pkg.dependencies || {}),
            devDependencies: Object.keys(pkg.devDependencies || {}),
            peerDependencies: Object.keys(pkg.peerDependencies || {})
        };
    }
    
    // Find unused exports
    async findUnusedExports(directory: string): Promise<string[]> {
        const files = await glob(\`\${directory}/**/*.{ts,tsx,js,jsx}\`);
        const exports: Map<string, Set<string>> = new Map();
        const imports: Set<string> = new Set();
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            const analysis = this.analyzeFile(file, content);
            
            analysis.exports.forEach(e => {
                if (!exports.has(file)) exports.set(file, new Set());
                exports.get(file)!.add(e.name);
            });
            
            analysis.imports.forEach(i => {
                i.named.forEach(n => imports.add(n));
                if (i.default) imports.add(i.default);
            });
        }
        
        const unused: string[] = [];
        exports.forEach((names, file) => {
            names.forEach(name => {
                if (!imports.has(name)) unused.push(\`\${file}:\${name}\`);
            });
        });
        
        return unused;
    }
}

export { CodeAnalyzer };
`;
    }
}

export const codeAnalysisService = CodeAnalysisService.getInstance();
