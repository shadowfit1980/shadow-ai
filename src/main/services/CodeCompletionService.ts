/**
 * ðŸ’¡ CodeCompletionService
 * 
 * Code completion:
 * - Suggestions, context, ranking
 */

import { EventEmitter } from 'events';

export class CodeCompletionService extends EventEmitter {
    private static instance: CodeCompletionService;
    private constructor() { super(); }
    static getInstance(): CodeCompletionService {
        if (!CodeCompletionService.instance) {
            CodeCompletionService.instance = new CodeCompletionService();
        }
        return CodeCompletionService.instance;
    }

    generate(): string {
        return `// Code Completion Service - Suggestions, context
// Generated by Shadow AI

import OpenAI from 'openai';

class CodeCompletion {
    private openai = new OpenAI();
    
    // Get completions
    async getCompletions(context: CompletionContext): Promise<Completion[]> {
        const prompt = this.buildPrompt(context);
        
        const response = await this.openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [
                {
                    role: 'system',
                    content: \`You are a code completion engine. Given the code context, suggest the most likely continuations.
                    Return JSON array of suggestions: [{ text, kind, detail, insertText }]
                    kinds: function, variable, class, keyword, snippet, property\`
                },
                { role: 'user', content: prompt }
            ],
            max_tokens: 500
        });
        
        const suggestions = JSON.parse(response.choices[0].message.content!);
        return this.rankCompletions(suggestions, context);
    }
    
    // Get inline completion (ghost text)
    async getInlineCompletion(prefix: string, suffix: string, language: string): Promise<string> {
        const response = await this.openai.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: [
                {
                    role: 'system',
                    content: \`Complete the code. Return only the completion text, no explanation. Language: \${language}\`
                },
                {
                    role: 'user',
                    content: \`<prefix>\${prefix}</prefix><cursor><suffix>\${suffix}</suffix>\`
                }
            ],
            max_tokens: 100,
            temperature: 0
        });
        
        return response.choices[0].message.content || '';
    }
    
    // Generate function body
    async generateFunctionBody(signature: string, context: string): Promise<string> {
        const response = await this.openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages: [
                {
                    role: 'system',
                    content: 'Implement this function. Return only the function body code.'
                },
                {
                    role: 'user',
                    content: \`Signature: \${signature}\\n\\nContext:\\n\${context}\`
                }
            ]
        });
        
        return response.choices[0].message.content || '';
    }
    
    // Import suggestions
    async suggestImports(code: string, usedSymbols: string[]): Promise<ImportSuggestion[]> {
        const response = await this.openai.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: [
                {
                    role: 'system',
                    content: 'Suggest imports for these symbols. Return JSON: [{ symbol, from, isDefault }]'
                },
                {
                    role: 'user',
                    content: \`Symbols: \${usedSymbols.join(', ')}\\n\\nCode context:\\n\${code.slice(0, 1000)}\`
                }
            ]
        });
        
        return JSON.parse(response.choices[0].message.content!);
    }
    
    private buildPrompt(context: CompletionContext): string {
        return \`Language: \${context.language}
File: \${context.filePath}
Line: \${context.line}
Column: \${context.column}

Code before cursor:
\${context.prefix.slice(-500)}

Code after cursor:
\${context.suffix.slice(0, 200)}

Trigger: \${context.triggerKind}\`;
    }
    
    private rankCompletions(completions: Completion[], context: CompletionContext): Completion[] {
        // Score based on context relevance
        return completions.sort((a, b) => {
            let scoreA = 0, scoreB = 0;
            
            // Prefer matching prefix
            if (context.prefix && a.text.toLowerCase().startsWith(context.prefix.toLowerCase())) scoreA += 10;
            if (context.prefix && b.text.toLowerCase().startsWith(context.prefix.toLowerCase())) scoreB += 10;
            
            // Prefer shorter completions for inline
            if (a.text.length < b.text.length) scoreA += 2;
            
            return scoreB - scoreA;
        });
    }
}

export { CodeCompletion };
`;
    }
}

export const codeCompletionService = CodeCompletionService.getInstance();
