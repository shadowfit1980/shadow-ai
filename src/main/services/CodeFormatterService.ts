/**
 * ðŸŽ¨ CodeFormatterService
 * 
 * Code formatting:
 * - Prettier, ESLint, auto-fix
 */

import { EventEmitter } from 'events';

export class CodeFormatterService extends EventEmitter {
    private static instance: CodeFormatterService;
    private constructor() { super(); }
    static getInstance(): CodeFormatterService {
        if (!CodeFormatterService.instance) {
            CodeFormatterService.instance = new CodeFormatterService();
        }
        return CodeFormatterService.instance;
    }

    generate(): string {
        return `// Code Formatter Service - Prettier, ESLint
// Generated by Shadow AI

import prettier from 'prettier';
import { ESLint } from 'eslint';

class CodeFormatter {
    private eslint = new ESLint({ fix: true });
    
    // Format with Prettier
    async formatWithPrettier(code: string, options: prettier.Options = {}): Promise<string> {
        const defaults: prettier.Options = {
            parser: 'typescript',
            semi: true,
            singleQuote: true,
            tabWidth: 2,
            trailingComma: 'es5'
        };
        
        return prettier.format(code, { ...defaults, ...options });
    }
    
    // Lint with ESLint
    async lintWithESLint(filePath: string): Promise<LintResult> {
        const results = await this.eslint.lintFiles([filePath]);
        const result = results[0];
        
        return {
            filePath: result.filePath,
            errorCount: result.errorCount,
            warningCount: result.warningCount,
            fixableCount: result.fixableErrorCount + result.fixableWarningCount,
            messages: result.messages.map(m => ({
                line: m.line,
                column: m.column,
                severity: m.severity === 2 ? 'error' : 'warning',
                message: m.message,
                ruleId: m.ruleId
            }))
        };
    }
    
    // Auto-fix with ESLint
    async fixWithESLint(code: string, filePath = 'file.ts'): Promise<string> {
        const result = await this.eslint.lintText(code, { filePath });
        return result[0].output || code;
    }
    
    // Format file
    async formatFile(filePath: string): Promise<void> {
        const content = await fs.readFile(filePath, 'utf-8');
        const ext = path.extname(filePath);
        
        const parserMap: Record<string, string> = {
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'babel',
            '.jsx': 'babel',
            '.json': 'json',
            '.css': 'css',
            '.scss': 'scss',
            '.md': 'markdown',
            '.html': 'html'
        };
        
        const formatted = await prettier.format(content, {
            parser: parserMap[ext] || 'typescript'
        });
        
        await fs.writeFile(filePath, formatted);
    }
    
    // Check if file is formatted
    async isFormatted(code: string, parser = 'typescript'): Promise<boolean> {
        const formatted = await prettier.format(code, { parser });
        return code === formatted;
    }
    
    // Get recommended config
    getRecommendedConfig(): { prettier: any; eslint: any } {
        return {
            prettier: {
                semi: true,
                singleQuote: true,
                tabWidth: 2,
                trailingComma: 'es5',
                printWidth: 100,
                bracketSpacing: true
            },
            eslint: {
                extends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended'],
                rules: {
                    'no-unused-vars': 'warn',
                    '@typescript-eslint/explicit-function-return-type': 'off'
                }
            }
        };
    }
    
    // AI-powered code cleanup
    async aiCleanup(code: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Clean up this code: remove unused variables, simplify logic, improve naming. Return only the cleaned code.'
        }, {
            role: 'user',
            content: code
        }]);
        
        // Format the result
        return this.formatWithPrettier(response.content);
    }
}

export { CodeFormatter };
`;
    }
}

export const codeFormatterService = CodeFormatterService.getInstance();
