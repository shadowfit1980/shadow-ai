/**
 * ðŸ‘¤ Code Ownership Tracker
 * 
 * Track code ownership and blame:
 * - Who owns what code, expertise mapping
 */

import { EventEmitter } from 'events';

export class CodeOwnershipTracker extends EventEmitter {
    private static instance: CodeOwnershipTracker;

    private constructor() { super(); }

    static getInstance(): CodeOwnershipTracker {
        if (!CodeOwnershipTracker.instance) {
            CodeOwnershipTracker.instance = new CodeOwnershipTracker();
        }
        return CodeOwnershipTracker.instance;
    }

    generate(): string {
        return `// Code Ownership Tracker
// Generated by Shadow AI

/**
 * CODE OWNERSHIP TRACKER
 * 
 * Track who owns what code and identify experts for each area.
 */

interface FileOwnership {
    path: string;
    primaryOwner: string;
    contributors: Contributor[];
    lastModified: Date;
    linesOfCode: number;
    complexity: number;
    coverage: number;
}

interface Contributor {
    name: string;
    email: string;
    commits: number;
    linesAdded: number;
    linesRemoved: number;
    lastContribution: Date;
    percentage: number;
}

interface TeamExpertise {
    member: string;
    areas: {
        path: string;
        expertise: 'owner' | 'expert' | 'contributor' | 'familiar';
        lastActive: Date;
    }[];
}

// === Ownership Analyzer ===
class OwnershipAnalyzer {
    async analyzeRepository(repoPath: string): Promise<OwnershipReport> {
        const files = await glob(\`\${repoPath}/**/*.{ts,tsx,js,jsx,py,go,rs}\`);
        const ownership: FileOwnership[] = [];
        
        for (const file of files) {
            const relativePath = file.replace(repoPath + '/', '');
            const fileOwnership = await this.analyzeFile(repoPath, relativePath);
            ownership.push(fileOwnership);
        }
        
        return {
            repository: repoPath,
            analyzedAt: new Date(),
            files: ownership,
            teamExpertise: this.calculateExpertise(ownership),
            busFactorRisk: this.calculateBusFactor(ownership),
            orphanedCode: ownership.filter(f => f.contributors.length === 1 && f.linesOfCode > 500)
        };
    }
    
    private async analyzeFile(repoPath: string, relativePath: string): Promise<FileOwnership> {
        // Get git blame
        const blameOutput = await this.exec(
            \`cd \${repoPath} && git blame --line-porcelain \${relativePath}\`
        );
        
        const authorLines = this.parseBlame(blameOutput);
        const contributors = this.aggregateContributors(authorLines);
        
        // Get file stats
        const logOutput = await this.exec(
            \`cd \${repoPath} && git log --format="%an|%ae|%ai" --numstat \${relativePath}\`
        );
        
        return {
            path: relativePath,
            primaryOwner: contributors[0]?.name || 'unknown',
            contributors,
            lastModified: await this.getLastModified(repoPath, relativePath),
            linesOfCode: Object.values(authorLines).reduce((a, b) => a + b, 0),
            complexity: await this.calculateComplexity(repoPath + '/' + relativePath),
            coverage: await this.getCoverage(relativePath)
        };
    }
    
    private calculateExpertise(ownership: FileOwnership[]): TeamExpertise[] {
        const memberMap = new Map<string, TeamExpertise['areas']>();
        
        for (const file of ownership) {
            for (const contrib of file.contributors) {
                if (!memberMap.has(contrib.name)) {
                    memberMap.set(contrib.name, []);
                }
                
                const expertise = this.determineExpertise(contrib, file);
                memberMap.get(contrib.name)!.push({
                    path: file.path,
                    expertise,
                    lastActive: contrib.lastContribution
                });
            }
        }
        
        return Array.from(memberMap.entries()).map(([member, areas]) => ({
            member,
            areas
        }));
    }
    
    private determineExpertise(contrib: Contributor, file: FileOwnership): 'owner' | 'expert' | 'contributor' | 'familiar' {
        if (contrib.name === file.primaryOwner) return 'owner';
        if (contrib.percentage > 30) return 'expert';
        if (contrib.commits > 5) return 'contributor';
        return 'familiar';
    }
    
    private calculateBusFactor(ownership: FileOwnership[]): BusFactorAnalysis {
        const critical: string[] = [];
        const atRisk: string[] = [];
        
        for (const file of ownership) {
            if (file.contributors.length === 1) {
                if (file.complexity > 50 || file.linesOfCode > 1000) {
                    critical.push(file.path);
                } else {
                    atRisk.push(file.path);
                }
            } else if (file.contributors[0].percentage > 80) {
                atRisk.push(file.path);
            }
        }
        
        return {
            busFactor: this.estimateBusFactor(ownership),
            criticalFiles: critical,
            atRiskFiles: atRisk,
            recommendations: this.generateRecommendations(critical, atRisk)
        };
    }
}

// === CODEOWNERS Generator ===
class CodeOwnersGenerator {
    async generateCodeowners(ownership: FileOwnership[]): Promise<string> {
        let codeowners = '# CODEOWNERS - Auto-generated by Shadow AI\\n\\n';
        
        // Group by directory
        const byDir = this.groupByDirectory(ownership);
        
        for (const [dir, files] of Object.entries(byDir)) {
            const primaryOwner = this.determineDirOwner(files);
            codeowners += \`\${dir}/ @\${primaryOwner}\\n\`;
        }
        
        codeowners += '\\n# Specific files\\n';
        
        for (const file of ownership.filter(f => f.complexity > 50)) {
            const owners = file.contributors
                .filter(c => c.percentage > 20)
                .map(c => '@' + c.name)
                .join(' ');
            codeowners += \`\${file.path} \${owners}\\n\`;
        }
        
        return codeowners;
    }
}

// === Review Assignment ===
class ReviewAssigner {
    async suggestReviewers(changedFiles: string[], ownership: FileOwnership[]): Promise<string[]> {
        const reviewerScores = new Map<string, number>();
        
        for (const file of changedFiles) {
            const fileOwnership = ownership.find(f => f.path === file);
            if (!fileOwnership) continue;
            
            for (const contrib of fileOwnership.contributors) {
                const current = reviewerScores.get(contrib.name) || 0;
                const score = this.calculateReviewScore(contrib, fileOwnership);
                reviewerScores.set(contrib.name, current + score);
            }
        }
        
        return Array.from(reviewerScores.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([name]) => name);
    }
}

export { OwnershipAnalyzer, CodeOwnersGenerator, ReviewAssigner };
`;
    }
}

export const codeOwnershipTracker = CodeOwnershipTracker.getInstance();
