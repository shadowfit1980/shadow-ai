/**
 * ðŸ”€ CodeRefactoringService
 * 
 * Code refactoring:
 * - Rename, extract, inline
 */

import { EventEmitter } from 'events';

export class CodeRefactoringService extends EventEmitter {
    private static instance: CodeRefactoringService;
    private constructor() { super(); }
    static getInstance(): CodeRefactoringService {
        if (!CodeRefactoringService.instance) {
            CodeRefactoringService.instance = new CodeRefactoringService();
        }
        return CodeRefactoringService.instance;
    }

    generate(): string {
        return `// Code Refactoring Service - Rename, extract, inline
// Generated by Shadow AI

class CodeRefactorer {
    // Rename symbol across files
    async renameSymbol(oldName: string, newName: string, directory: string): Promise<RefactorResult> {
        const files = await glob(\`\${directory}/**/*.{ts,tsx,js,jsx}\`);
        const changes: FileChange[] = [];
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            // Use regex with word boundaries
            const regex = new RegExp(\`\\\\b\${oldName}\\\\b\`, 'g');
            
            if (regex.test(content)) {
                const newContent = content.replace(regex, newName);
                changes.push({ file, oldContent: content, newContent });
            }
        }
        
        return { changes, affectedFiles: changes.length };
    }
    
    // Extract function
    async extractFunction(filePath: string, startLine: number, endLine: number, functionName: string): Promise<string> {
        const content = await fs.readFile(filePath, 'utf-8');
        const lines = content.split('\\n');
        
        const extractedLines = lines.slice(startLine - 1, endLine);
        const extractedCode = extractedLines.join('\\n');
        
        // Analyze for variables used
        const variables = this.findVariables(extractedCode);
        const params = variables.filter(v => !this.isDeclaredInCode(v, extractedCode));
        
        const newFunction = \`function \${functionName}(\${params.join(', ')}) {
    \${extractedCode.split('\\n').map(l => '    ' + l).join('\\n')}
}\`;
        
        // Replace original code with function call
        lines.splice(startLine - 1, endLine - startLine + 1, \`\${functionName}(\${params.join(', ')});\`);
        
        // Add function definition
        lines.push('', newFunction);
        
        return lines.join('\\n');
    }
    
    // Inline function
    async inlineFunction(filePath: string, functionName: string): Promise<string> {
        const content = await fs.readFile(filePath, 'utf-8');
        
        // Find function definition
        const funcRegex = new RegExp(\`function \${functionName}\\\\s*\\\\([^)]*\\\\)\\\\s*{([^}]*)}\`, 's');
        const match = content.match(funcRegex);
        
        if (!match) throw new Error(\`Function \${functionName} not found\`);
        
        const body = match[1].trim();
        
        // Replace all calls with body
        const callRegex = new RegExp(\`\${functionName}\\\\s*\\\\([^)]*\\\\)\`, 'g');
        let result = content.replace(callRegex, body);
        
        // Remove function definition
        result = result.replace(funcRegex, '');
        
        return result;
    }
    
    // Convert to async/await
    async convertToAsync(filePath: string): Promise<string> {
        const content = await fs.readFile(filePath, 'utf-8');
        
        // Convert .then() chains to async/await
        let result = content;
        
        // Pattern: somePromise.then(result => ...)
        const thenPattern = /(\w+)\\.then\\(\\s*(\\w+)\\s*=>\\s*{([^}]*)}\\)/g;
        
        result = result.replace(thenPattern, (match, promise, param, body) => {
            return \`const \${param} = await \${promise};\\n\${body}\`;
        });
        
        return result;
    }
    
    // Add error handling
    async addErrorHandling(filePath: string): Promise<string> {
        const content = await fs.readFile(filePath, 'utf-8');
        
        // Find await statements not in try-catch
        const lines = content.split('\\n');
        let result = '';
        let inTryCatch = false;
        
        for (const line of lines) {
            if (line.includes('try {')) inTryCatch = true;
            if (line.includes('} catch')) inTryCatch = false;
            
            if (line.includes('await ') && !inTryCatch) {
                result += \`try {\\n    \${line}\\n} catch (error) {\\n    console.error('Error:', error);\\n    throw error;\\n}\\n\`;
            } else {
                result += line + '\\n';
            }
        }
        
        return result;
    }
    
    private findVariables(code: string): string[] {
        const varRegex = /\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b/g;
        const matches = code.matchAll(varRegex);
        return [...new Set(Array.from(matches).map(m => m[1]))];
    }
    
    private isDeclaredInCode(variable: string, code: string): boolean {
        const declareRegex = new RegExp(\`(const|let|var)\\\\s+\${variable}\\\\b\`);
        return declareRegex.test(code);
    }
}

export { CodeRefactorer };
`;
    }
}

export const codeRefactoringService = CodeRefactoringService.getInstance();
