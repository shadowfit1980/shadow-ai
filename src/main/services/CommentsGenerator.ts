/**
 * ðŸ’¬ CommentsGenerator
 * 
 * Comments system:
 * - Threads, mentions, reactions
 */

import { EventEmitter } from 'events';

export class CommentsGenerator extends EventEmitter {
    private static instance: CommentsGenerator;
    private constructor() { super(); }
    static getInstance(): CommentsGenerator {
        if (!CommentsGenerator.instance) {
            CommentsGenerator.instance = new CommentsGenerator();
        }
        return CommentsGenerator.instance;
    }

    generate(): string {
        return `// Comments Generator - Threads, mentions, reactions
// Generated by Shadow AI

// Comment Schema
model Comment {
    id        String    @id @default(cuid())
    content   String
    authorId  String
    author    User      @relation(fields: [authorId], references: [id])
    parentId  String?
    parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
    replies   Comment[] @relation("CommentReplies")
    itemId    String
    itemType  String
    reactions Reaction[]
    mentions  Mention[]
    edited    Boolean   @default(false)
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
}

model Reaction {
    id        String   @id @default(cuid())
    emoji     String
    userId    String
    commentId String
    comment   Comment  @relation(fields: [commentId], references: [id])
    @@unique([userId, commentId, emoji])
}

// Comment Service
class CommentService {
    async createComment(data: { content: string; authorId: string; itemId: string; itemType: string; parentId?: string }) {
        const mentions = this.extractMentions(data.content);
        
        const comment = await prisma.comment.create({
            data: {
                content: data.content,
                authorId: data.authorId,
                itemId: data.itemId,
                itemType: data.itemType,
                parentId: data.parentId,
                mentions: {
                    createMany: {
                        data: mentions.map(userId => ({ userId }))
                    }
                }
            },
            include: { author: true, reactions: true }
        });
        
        // Notify mentioned users
        for (const userId of mentions) {
            await this.notifyMention(userId, comment);
        }
        
        return comment;
    }
    
    async getComments(itemId: string, itemType: string) {
        return prisma.comment.findMany({
            where: { itemId, itemType, parentId: null },
            include: {
                author: true,
                reactions: true,
                replies: {
                    include: { author: true, reactions: true },
                    orderBy: { createdAt: 'asc' }
                }
            },
            orderBy: { createdAt: 'desc' }
        });
    }
    
    async addReaction(commentId: string, userId: string, emoji: string) {
        return prisma.reaction.upsert({
            where: { userId_commentId_emoji: { userId, commentId, emoji } },
            create: { userId, commentId, emoji },
            update: {}
        });
    }
    
    async removeReaction(commentId: string, userId: string, emoji: string) {
        return prisma.reaction.delete({
            where: { userId_commentId_emoji: { userId, commentId, emoji } }
        });
    }
    
    private extractMentions(content: string): string[] {
        const matches = content.match(/@\\[(\\w+)\\]\\((\\w+)\\)/g) || [];
        return matches.map(m => m.match(/\\((\\w+)\\)/)?.[1]).filter(Boolean) as string[];
    }
}

// Comment Component
export function CommentThread({ itemId, itemType }: { itemId: string; itemType: string }) {
    const { data: comments } = useQuery(['comments', itemId], () => getComments(itemId, itemType));
    const [replyTo, setReplyTo] = useState<string | null>(null);
    
    return (
        <div className="comments">
            <CommentForm itemId={itemId} itemType={itemType} parentId={null} />
            
            {comments?.map(comment => (
                <CommentItem
                    key={comment.id}
                    comment={comment}
                    onReply={() => setReplyTo(comment.id)}
                />
            ))}
        </div>
    );
}

export { CommentService, CommentThread };
`;
    }
}

export const commentsGenerator = CommentsGenerator.getInstance();
