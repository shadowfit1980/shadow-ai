/**
 * ðŸ”§ ConfigHotReloadGenerator
 * 
 * Config hot reload:
 * - Live config, feature flags
 */

import { EventEmitter } from 'events';

export class ConfigHotReloadGenerator extends EventEmitter {
    private static instance: ConfigHotReloadGenerator;
    private constructor() { super(); }
    static getInstance(): ConfigHotReloadGenerator {
        if (!ConfigHotReloadGenerator.instance) {
            ConfigHotReloadGenerator.instance = new ConfigHotReloadGenerator();
        }
        return ConfigHotReloadGenerator.instance;
    }

    generate(): string {
        return `// Config Hot Reload Generator - Live config, feature flags
// Generated by Shadow AI

class ConfigService {
    private config: Map<string, any> = new Map();
    private subscribers: Map<string, Set<(value: any) => void>> = new Map();
    private pollInterval: NodeJS.Timer | null = null;
    
    async init() {
        await this.refresh();
        
        // Poll for changes every 30 seconds
        this.pollInterval = setInterval(() => this.refresh(), 30000);
    }
    
    async refresh() {
        const configs = await prisma.config.findMany();
        
        for (const cfg of configs) {
            const oldValue = this.config.get(cfg.key);
            const newValue = cfg.value;
            
            this.config.set(cfg.key, newValue);
            
            // Notify subscribers if changed
            if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
                this.notify(cfg.key, newValue);
            }
        }
    }
    
    get<T>(key: string, defaultValue?: T): T {
        return this.config.has(key) ? this.config.get(key) : defaultValue;
    }
    
    async set(key: string, value: any) {
        await prisma.config.upsert({
            where: { key },
            create: { key, value },
            update: { value }
        });
        
        this.config.set(key, value);
        this.notify(key, value);
    }
    
    subscribe(key: string, callback: (value: any) => void) {
        if (!this.subscribers.has(key)) {
            this.subscribers.set(key, new Set());
        }
        this.subscribers.get(key)!.add(callback);
        
        // Return unsubscribe function
        return () => {
            this.subscribers.get(key)?.delete(callback);
        };
    }
    
    private notify(key: string, value: any) {
        const subs = this.subscribers.get(key);
        if (subs) {
            for (const callback of subs) {
                try { callback(value); } catch (e) { console.error(e); }
            }
        }
    }
    
    destroy() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
        }
    }
}

// React Hook
export function useConfig<T>(key: string, defaultValue: T): T {
    const [value, setValue] = useState<T>(() => configService.get(key, defaultValue));
    
    useEffect(() => {
        return configService.subscribe(key, setValue);
    }, [key]);
    
    return value;
}

export { ConfigService, useConfig };
`;
    }
}

export const configHotReloadGenerator = ConfigHotReloadGenerator.getInstance();
