/**
 * ðŸ”„ ContentModerationGenerator
 * 
 * Content moderation:
 * - AI moderation, flagging, review
 */

import { EventEmitter } from 'events';

export class ContentModerationGenerator extends EventEmitter {
    private static instance: ContentModerationGenerator;
    private constructor() { super(); }
    static getInstance(): ContentModerationGenerator {
        if (!ContentModerationGenerator.instance) {
            ContentModerationGenerator.instance = new ContentModerationGenerator();
        }
        return ContentModerationGenerator.instance;
    }

    generate(): string {
        return `// Content Moderation Generator - AI moderation, flagging
// Generated by Shadow AI

import OpenAI from 'openai';

class ContentModerationService {
    private openai = new OpenAI();
    
    async moderate(content: string): Promise<ModerationResult> {
        const response = await this.openai.moderations.create({ input: content });
        const result = response.results[0];
        
        return {
            flagged: result.flagged,
            categories: result.categories,
            scores: result.category_scores
        };
    }
    
    async moderateImage(imageUrl: string): Promise<ModerationResult> {
        const response = await this.openai.chat.completions.create({
            model: 'gpt-4-vision-preview',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Analyze this image for inappropriate content. Return a JSON with: { flagged: boolean, reason: string | null, categories: string[] }' },
                    { type: 'image_url', image_url: { url: imageUrl } }
                ]
            }]
        });
        
        return JSON.parse(response.choices[0].message.content!);
    }
    
    async flagForReview(contentId: string, reason: string) {
        await prisma.moderationQueue.create({
            data: { contentId, reason, status: 'PENDING' }
        });
    }
    
    async getQueue(status?: string) {
        return prisma.moderationQueue.findMany({
            where: status ? { status } : undefined,
            orderBy: { createdAt: 'asc' }
        });
    }
    
    async approve(contentId: string, moderatorId: string) {
        await prisma.moderationQueue.update({
            where: { contentId },
            data: { status: 'APPROVED', moderatorId, reviewedAt: new Date() }
        });
    }
    
    async reject(contentId: string, moderatorId: string, reason: string) {
        await prisma.moderationQueue.update({
            where: { contentId },
            data: { status: 'REJECTED', moderatorId, reviewedAt: new Date(), rejectionReason: reason }
        });
        
        // Delete or hide content
        await prisma.content.update({
            where: { id: contentId },
            data: { status: 'HIDDEN' }
        });
    }
}

export { ContentModerationService };
`;
    }
}

export const contentModerationGenerator = ContentModerationGenerator.getInstance();
