/**
 * ðŸ“‹ ContextualClipboardService
 * 
 * Smart clipboard with context:
 * - Transform paste, detect intent
 */

import { EventEmitter } from 'events';

export class ContextualClipboardService extends EventEmitter {
    private static instance: ContextualClipboardService;
    private constructor() { super(); }
    static getInstance(): ContextualClipboardService {
        if (!ContextualClipboardService.instance) {
            ContextualClipboardService.instance = new ContextualClipboardService();
        }
        return ContextualClipboardService.instance;
    }

    generate(): string {
        return `// Contextual Clipboard Service - Smart paste
// Generated by Shadow AI

interface ClipboardEntry {
    id: string;
    content: string;
    type: 'code' | 'text' | 'url' | 'image' | 'json' | 'unknown';
    sourceLanguage?: string;
    sourceApp?: string;
    timestamp: number;
    metadata: Record<string, any>;
}

class ContextualClipboard {
    private history: ClipboardEntry[] = [];
    private maxHistory = 50;
    
    // Record clipboard content
    record(content: string, sourceApp?: string): ClipboardEntry {
        const entry: ClipboardEntry = {
            id: crypto.randomUUID(),
            content,
            type: this.detectType(content),
            sourceLanguage: this.detectLanguage(content),
            sourceApp,
            timestamp: Date.now(),
            metadata: {}
        };
        
        this.history.unshift(entry);
        if (this.history.length > this.maxHistory) {
            this.history.pop();
        }
        
        return entry;
    }
    
    // Smart paste - transform based on target context
    async smartPaste(content: string, targetContext: TargetContext): Promise<string> {
        const sourceType = this.detectType(content);
        const sourceLang = this.detectLanguage(content);
        
        // Same language, just paste
        if (sourceLang === targetContext.language) {
            return content;
        }
        
        // Transform as needed
        const response = await llm.chat([{
            role: 'system',
            content: \`Transform this content for pasting into \${targetContext.language} code.
            Current cursor position: line \${targetContext.line}, inside \${targetContext.scope}.
            Make it fit naturally. Only return the transformed code, no explanation.\`
        }, {
            role: 'user',
            content
        }]);
        
        return response.content;
    }
    
    // Detect paste intent
    async detectIntent(content: string, context: TargetContext): Promise<PasteIntent> {
        const response = await llm.chat([{
            role: 'system',
            content: \`What is the user's likely intent for pasting this content here?
            Target: \${context.language} file at line \${context.line}
            
            Return JSON: { intent: 'insert' | 'replace' | 'refactor' | 'convert', suggestion: string }\`
        }, {
            role: 'user',
            content
        }]);
        
        return JSON.parse(response.content);
    }
    
    // Multi-paste with automatic formatting
    async multiPaste(entries: string[], context: TargetContext): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Combine and format these clipboard entries for pasting into \${context.language}.
            Keep them organized and properly formatted.\`
        }, {
            role: 'user',
            content: entries.join('\\n---\\n')
        }]);
        
        return response.content;
    }
    
    // Convert formats (e.g., JSON to interface)
    async convertFormat(content: string, targetFormat: string): Promise<string> {
        const sourceType = this.detectType(content);
        
        const conversions: Record<string, Record<string, string>> = {
            json: {
                typescript: 'Convert this JSON to a TypeScript interface',
                python: 'Convert this JSON to a Python dataclass',
                go: 'Convert this JSON to a Go struct',
                rust: 'Convert this JSON to a Rust struct'
            },
            csv: {
                json: 'Convert this CSV to JSON array',
                sql: 'Convert this CSV to SQL INSERT statements',
                markdown: 'Convert this CSV to a Markdown table'
            },
            sql: {
                json: 'Convert this SQL result to JSON',
                csv: 'Convert this SQL to CSV format'
            }
        };
        
        const prompt = conversions[sourceType]?.[targetFormat] || \`Convert this to \${targetFormat}\`;
        
        const response = await llm.chat([{
            role: 'system',
            content: prompt
        }, {
            role: 'user',
            content
        }]);
        
        return response.content;
    }
    
    // Get clipboard history
    getHistory(): ClipboardEntry[] {
        return this.history;
    }
    
    // Search history
    searchHistory(query: string): ClipboardEntry[] {
        const lowerQuery = query.toLowerCase();
        return this.history.filter(e => 
            e.content.toLowerCase().includes(lowerQuery)
        );
    }
    
    // Get entry by ID
    getEntry(id: string): ClipboardEntry | undefined {
        return this.history.find(e => e.id === id);
    }
    
    // Clear history
    clearHistory(): void {
        this.history = [];
    }
    
    private detectType(content: string): ClipboardEntry['type'] {
        if (this.isUrl(content)) return 'url';
        if (this.isJson(content)) return 'json';
        if (this.isCode(content)) return 'code';
        return 'text';
    }
    
    private detectLanguage(content: string): string | undefined {
        // Simple heuristics
        if (content.includes('function ') && content.includes('const ')) return 'javascript';
        if (content.includes('def ') && content.includes(':')) return 'python';
        if (content.includes('func ') && content.includes('package ')) return 'go';
        if (content.includes('fn ') && content.includes('let ')) return 'rust';
        if (content.includes('interface ') && content.includes(':')) return 'typescript';
        if (content.includes('public class ')) return 'java';
        return undefined;
    }
    
    private isUrl(content: string): boolean {
        return /^https?:\\/\\//i.test(content.trim());
    }
    
    private isJson(content: string): boolean {
        try {
            JSON.parse(content);
            return true;
        } catch {
            return false;
        }
    }
    
    private isCode(content: string): boolean {
        const codeIndicators = ['{', '}', '()', '=>', 'function', 'class', 'const ', 'let ', 'var ', 'def ', 'fn '];
        return codeIndicators.some(ind => content.includes(ind));
    }
}

export { ContextualClipboard };
`;
    }
}

export const contextualClipboardService = ContextualClipboardService.getInstance();
