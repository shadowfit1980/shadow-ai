/**
 * ðŸ“ Contract Testing Generator
 * 
 * Generate contract tests:
 * - Pact consumer/provider
 */

import { EventEmitter } from 'events';

export class ContractTestingGenerator extends EventEmitter {
    private static instance: ContractTestingGenerator;

    private constructor() { super(); }

    static getInstance(): ContractTestingGenerator {
        if (!ContractTestingGenerator.instance) {
            ContractTestingGenerator.instance = new ContractTestingGenerator();
        }
        return ContractTestingGenerator.instance;
    }

    generate(): string {
        return `// Contract Testing with Pact
// Generated by Shadow AI

// === Consumer Test ===
import { PactV3, MatchersV3 } from '@pact-foundation/pact';
import { UserService } from './UserService';

const { like, eachLike, string, integer, boolean, timestamp } = MatchersV3;

const provider = new PactV3({
    consumer: 'FrontendApp',
    provider: 'UserAPI',
    dir: './pacts'
});

describe('User API Consumer Contract', () => {
    describe('GET /api/users', () => {
        it('returns a list of users', async () => {
            // Arrange: Define expected interaction
            provider
                .given('users exist')
                .uponReceiving('a request for all users')
                .withRequest({
                    method: 'GET',
                    path: '/api/users',
                    headers: {
                        Accept: 'application/json'
                    }
                })
                .willRespondWith({
                    status: 200,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: eachLike({
                        id: string('123'),
                        name: string('John Doe'),
                        email: string('john@example.com'),
                        createdAt: timestamp("yyyy-MM-dd'T'HH:mm:ss.SSSXXX", '2024-01-01T00:00:00.000Z')
                    })
                });

            // Act & Assert
            await provider.executeTest(async (mockService) => {
                const userService = new UserService(mockService.url);
                const users = await userService.getUsers();

                expect(users).toHaveLength(1);
                expect(users[0]).toHaveProperty('id');
                expect(users[0]).toHaveProperty('name');
            });
        });
    });

    describe('GET /api/users/:id', () => {
        it('returns a single user', async () => {
            provider
                .given('user with id 123 exists')
                .uponReceiving('a request for user 123')
                .withRequest({
                    method: 'GET',
                    path: '/api/users/123'
                })
                .willRespondWith({
                    status: 200,
                    body: like({
                        id: '123',
                        name: 'John Doe',
                        email: 'john@example.com',
                        role: 'user',
                        active: boolean(true)
                    })
                });

            await provider.executeTest(async (mockService) => {
                const userService = new UserService(mockService.url);
                const user = await userService.getUser('123');

                expect(user.id).toBe('123');
            });
        });

        it('returns 404 for non-existent user', async () => {
            provider
                .given('user with id 999 does not exist')
                .uponReceiving('a request for user 999')
                .withRequest({
                    method: 'GET',
                    path: '/api/users/999'
                })
                .willRespondWith({
                    status: 404,
                    body: {
                        error: string('User not found')
                    }
                });

            await provider.executeTest(async (mockService) => {
                const userService = new UserService(mockService.url);
                await expect(userService.getUser('999')).rejects.toThrow('User not found');
            });
        });
    });

    describe('POST /api/users', () => {
        it('creates a new user', async () => {
            provider
                .uponReceiving('a request to create a user')
                .withRequest({
                    method: 'POST',
                    path: '/api/users',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: {
                        name: 'Jane Doe',
                        email: 'jane@example.com'
                    }
                })
                .willRespondWith({
                    status: 201,
                    body: like({
                        id: string('456'),
                        name: 'Jane Doe',
                        email: 'jane@example.com'
                    })
                });

            await provider.executeTest(async (mockService) => {
                const userService = new UserService(mockService.url);
                const user = await userService.createUser({ name: 'Jane Doe', email: 'jane@example.com' });

                expect(user).toHaveProperty('id');
                expect(user.name).toBe('Jane Doe');
            });
        });
    });
});

// === Provider Verification ===
import { Verifier } from '@pact-foundation/pact';
import { app } from './app'; // Your Express app

describe('User API Provider Verification', () => {
    let server: any;

    beforeAll(async () => {
        server = app.listen(3001);
    });

    afterAll(() => {
        server.close();
    });

    it('validates the expectations of FrontendApp', async () => {
        const verifier = new Verifier({
            providerBaseUrl: 'http://localhost:3001',
            pactUrls: ['./pacts/FrontendApp-UserAPI.json'],
            // Or from Pact Broker
            // pactBrokerUrl: 'https://your-pact-broker.com',
            // pactBrokerToken: process.env.PACT_BROKER_TOKEN,
            // consumerVersionSelectors: [{ mainBranch: true }],
            
            // State handlers
            stateHandlers: {
                'users exist': async () => {
                    await db.user.createMany({
                        data: [{ id: '123', name: 'John Doe', email: 'john@example.com' }]
                    });
                },
                'user with id 123 exists': async () => {
                    await db.user.create({
                        data: { id: '123', name: 'John Doe', email: 'john@example.com' }
                    });
                },
                'user with id 999 does not exist': async () => {
                    await db.user.deleteMany({ where: { id: '999' } });
                }
            },

            beforeEach: async () => {
                await db.user.deleteMany(); // Clean up before each test
            },

            publishVerificationResult: process.env.CI === 'true',
            providerVersion: process.env.GIT_COMMIT
        });

        await verifier.verifyProvider();
    });
});

export { provider };
`;
    }
}

export const contractTestingGenerator = ContractTestingGenerator.getInstance();
