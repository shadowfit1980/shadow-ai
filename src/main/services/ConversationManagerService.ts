/**
 * üìù ConversationManagerService
 * 
 * Conversation management:
 * - History, context, threads
 */

import { EventEmitter } from 'events';

export class ConversationManagerService extends EventEmitter {
    private static instance: ConversationManagerService;
    private constructor() { super(); }
    static getInstance(): ConversationManagerService {
        if (!ConversationManagerService.instance) {
            ConversationManagerService.instance = new ConversationManagerService();
        }
        return ConversationManagerService.instance;
    }

    generate(): string {
        return `// Conversation Manager Service - History, context
// Generated by Shadow AI

class ConversationManager {
    private conversations: Map<string, Conversation> = new Map();
    
    // Create new conversation
    create(metadata?: Record<string, any>): string {
        const id = crypto.randomUUID();
        
        this.conversations.set(id, {
            id,
            messages: [],
            metadata: metadata || {},
            createdAt: Date.now(),
            updatedAt: Date.now()
        });
        
        return id;
    }
    
    // Add message
    addMessage(conversationId: string, role: 'user' | 'assistant' | 'system', content: string): void {
        const conv = this.conversations.get(conversationId);
        if (!conv) throw new Error(\`Conversation not found: \${conversationId}\`);
        
        conv.messages.push({
            id: crypto.randomUUID(),
            role,
            content,
            timestamp: Date.now()
        });
        
        conv.updatedAt = Date.now();
    }
    
    // Get messages
    getMessages(conversationId: string): Message[] {
        const conv = this.conversations.get(conversationId);
        return conv?.messages || [];
    }
    
    // Get context window
    getContextWindow(conversationId: string, maxTokens: number): Message[] {
        const messages = this.getMessages(conversationId);
        const result: Message[] = [];
        let tokens = 0;
        
        // Start from most recent
        for (let i = messages.length - 1; i >= 0; i--) {
            const msgTokens = this.estimateTokens(messages[i].content);
            if (tokens + msgTokens > maxTokens) break;
            result.unshift(messages[i]);
            tokens += msgTokens;
        }
        
        return result;
    }
    
    // Summarize conversation
    async summarize(conversationId: string): Promise<string> {
        const messages = this.getMessages(conversationId);
        
        const response = await llm.chat([{
            role: 'system',
            content: 'Summarize this conversation concisely.'
        }, {
            role: 'user',
            content: messages.map(m => \`\${m.role}: \${m.content}\`).join('\\n')
        }]);
        
        return response.content;
    }
    
    // Fork conversation
    fork(conversationId: string, fromMessageIndex?: number): string {
        const original = this.conversations.get(conversationId);
        if (!original) throw new Error('Conversation not found');
        
        const newId = this.create({ forkedFrom: conversationId });
        const newConv = this.conversations.get(newId)!;
        
        const messages = fromMessageIndex !== undefined
            ? original.messages.slice(0, fromMessageIndex)
            : [...original.messages];
        
        newConv.messages = messages.map(m => ({ ...m, id: crypto.randomUUID() }));
        
        return newId;
    }
    
    // Delete conversation
    delete(conversationId: string): void {
        this.conversations.delete(conversationId);
    }
    
    // List conversations
    list(): ConversationSummary[] {
        return Array.from(this.conversations.values()).map(c => ({
            id: c.id,
            messageCount: c.messages.length,
            createdAt: c.createdAt,
            updatedAt: c.updatedAt,
            metadata: c.metadata
        }));
    }
    
    private estimateTokens(text: string): number {
        return Math.ceil(text.length / 4);
    }
}

export { ConversationManager };
`;
    }
}

export const conversationManagerService = ConversationManagerService.getInstance();
