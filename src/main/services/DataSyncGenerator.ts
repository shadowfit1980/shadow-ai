/**
 * ðŸ”„ DataSyncGenerator
 * 
 * Data synchronization:
 * - Offline-first, conflict resolution
 */

import { EventEmitter } from 'events';

export class DataSyncGenerator extends EventEmitter {
    private static instance: DataSyncGenerator;
    private constructor() { super(); }
    static getInstance(): DataSyncGenerator {
        if (!DataSyncGenerator.instance) {
            DataSyncGenerator.instance = new DataSyncGenerator();
        }
        return DataSyncGenerator.instance;
    }

    generate(): string {
        return `// Data Sync Generator - Offline-first, conflict resolution
// Generated by Shadow AI

class DataSyncService {
    private pendingChanges: Change[] = [];
    
    async sync() {
        const localChanges = await this.getLocalChanges();
        const serverChanges = await this.fetchServerChanges();
        
        const { toApply, conflicts } = this.mergeChanges(localChanges, serverChanges);
        
        for (const change of toApply) {
            await this.applyChange(change);
        }
        
        if (conflicts.length > 0) {
            await this.resolveConflicts(conflicts);
        }
        
        await this.pushLocalChanges(localChanges);
    }
    
    private mergeChanges(local: Change[], server: Change[]) {
        const conflicts: Conflict[] = [];
        const toApply: Change[] = [];
        
        for (const serverChange of server) {
            const localChange = local.find(l => l.id === serverChange.id);
            
            if (!localChange) {
                toApply.push(serverChange);
            } else if (localChange.timestamp < serverChange.timestamp) {
                conflicts.push({ local: localChange, server: serverChange });
            }
        }
        
        return { toApply, conflicts };
    }
    
    private async resolveConflicts(conflicts: Conflict[]) {
        for (const conflict of conflicts) {
            // Last-write-wins by default
            await this.applyChange(conflict.server);
        }
    }
}

// React Hook
export function useSyncedData<T>(key: string, initialValue: T) {
    const [data, setData] = useState(initialValue);
    const [syncing, setSyncing] = useState(false);
    
    const sync = async () => {
        setSyncing(true);
        await syncService.sync();
        setSyncing(false);
    };
    
    return { data, setData, sync, syncing };
}

export { DataSyncService, useSyncedData };
`;
    }
}

export const dataSyncGenerator = DataSyncGenerator.getInstance();
