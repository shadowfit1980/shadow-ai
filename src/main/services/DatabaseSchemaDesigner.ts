/**
 * üóÑÔ∏è Database Schema Designer
 * 
 * Visual schema design:
 * - ER diagrams to SQL/NoSQL schemas
 */

import { EventEmitter } from 'events';

export class DatabaseSchemaDesigner extends EventEmitter {
    private static instance: DatabaseSchemaDesigner;

    private constructor() { super(); }

    static getInstance(): DatabaseSchemaDesigner {
        if (!DatabaseSchemaDesigner.instance) {
            DatabaseSchemaDesigner.instance = new DatabaseSchemaDesigner();
        }
        return DatabaseSchemaDesigner.instance;
    }

    generate(): string {
        return `// Database Schema Designer
// Generated by Shadow AI

/**
 * DATABASE SCHEMA DESIGNER
 * 
 * Design database schemas visually and generate SQL/Prisma/TypeORM code.
 */

interface Entity {
    name: string;
    tableName: string;
    columns: Column[];
    indexes: Index[];
    relations: Relation[];
}

interface Column {
    name: string;
    type: string;
    nullable: boolean;
    primary: boolean;
    unique: boolean;
    default?: any;
    references?: { table: string; column: string };
}

interface Relation {
    type: 'one-to-one' | 'one-to-many' | 'many-to-many';
    targetEntity: string;
    foreignKey?: string;
    throughTable?: string;
}

// === Schema Generator ===
class SchemaGenerator {
    async generateFromDescription(description: string): Promise<Entity[]> {
        const prompt = \`
            Design a database schema for:
            "\${description}"
            
            Generate:
            1. All entities with appropriate tables
            2. Columns with correct data types
            3. Primary keys and foreign keys
            4. Indexes for common queries
            5. Relationships between entities
            
            Use best practices:
            - Proper normalization (3NF)
            - Meaningful naming conventions
            - Appropriate constraints
            
            Return as JSON array of entities.
        \`;
        
        const response = await this.llm.complete(prompt);
        return JSON.parse(response);
    }
    
    generateSQL(entities: Entity[], dialect: 'postgresql' | 'mysql' | 'sqlite'): string {
        let sql = '';
        
        for (const entity of entities) {
            sql += \`CREATE TABLE \${entity.tableName} (\\n\`;
            
            const columnDefs = entity.columns.map(col => {
                let def = \`  \${col.name} \${this.mapType(col.type, dialect)}\`;
                if (col.primary) def += ' PRIMARY KEY';
                if (!col.nullable) def += ' NOT NULL';
                if (col.unique) def += ' UNIQUE';
                if (col.default !== undefined) def += \` DEFAULT \${this.formatDefault(col.default)}\`;
                return def;
            });
            
            sql += columnDefs.join(',\\n');
            sql += '\\n);\\n\\n';
            
            // Add indexes
            for (const index of entity.indexes) {
                sql += \`CREATE INDEX idx_\${entity.tableName}_\${index.columns.join('_')} ON \${entity.tableName} (\${index.columns.join(', ')});\\n\`;
            }
            
            sql += '\\n';
        }
        
        // Add foreign keys
        for (const entity of entities) {
            for (const col of entity.columns) {
                if (col.references) {
                    sql += \`ALTER TABLE \${entity.tableName} ADD CONSTRAINT fk_\${entity.tableName}_\${col.name} FOREIGN KEY (\${col.name}) REFERENCES \${col.references.table}(\${col.references.column});\\n\`;
                }
            }
        }
        
        return sql;
    }
    
    generatePrisma(entities: Entity[]): string {
        let schema = \`generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

\`;
        
        for (const entity of entities) {
            schema += \`model \${entity.name} {\\n\`;
            
            for (const col of entity.columns) {
                let line = \`  \${col.name} \${this.toPrismaType(col.type)}\`;
                if (col.primary) line += ' @id @default(autoincrement())';
                if (!col.nullable) line += '';
                else line = line.replace(col.type, col.type + '?');
                if (col.unique) line += ' @unique';
                if (col.default !== undefined) line += \` @default(\${this.formatPrismaDefault(col.default)})\`;
                schema += line + '\\n';
            }
            
            // Add relations
            for (const rel of entity.relations) {
                if (rel.type === 'one-to-many') {
                    schema += \`  \${rel.targetEntity.toLowerCase()}s \${rel.targetEntity}[]\\n\`;
                } else if (rel.type === 'many-to-many') {
                    schema += \`  \${rel.targetEntity.toLowerCase()}s \${rel.targetEntity}[]\\n\`;
                }
            }
            
            schema += \`  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

\`;
        }
        
        return schema;
    }
    
    generateTypeORM(entities: Entity[]): string {
        let code = '';
        
        for (const entity of entities) {
            code += \`import { Entity, PrimaryGeneratedColumn, Column, OneToMany, ManyToOne } from 'typeorm';

@Entity('\${entity.tableName}')
export class \${entity.name} {
\`;
            
            for (const col of entity.columns) {
                if (col.primary) {
                    code += \`  @PrimaryGeneratedColumn()
  \${col.name}: number;

\`;
                } else {
                    code += \`  @Column({ type: '\${col.type}'\${col.nullable ? ', nullable: true' : ''} })
  \${col.name}: \${this.toTsType(col.type)};

\`;
                }
            }
            
            code += \`}

\`;
        }
        
        return code;
    }
    
    private mapType(type: string, dialect: string): string {
        const typeMap: Record<string, Record<string, string>> = {
            postgresql: {
                'string': 'VARCHAR(255)',
                'text': 'TEXT',
                'int': 'INTEGER',
                'bigint': 'BIGINT',
                'float': 'REAL',
                'decimal': 'DECIMAL(10,2)',
                'boolean': 'BOOLEAN',
                'date': 'DATE',
                'datetime': 'TIMESTAMP',
                'json': 'JSONB',
                'uuid': 'UUID'
            },
            mysql: {
                'string': 'VARCHAR(255)',
                'text': 'TEXT',
                'int': 'INT',
                'bigint': 'BIGINT',
                'float': 'FLOAT',
                'decimal': 'DECIMAL(10,2)',
                'boolean': 'TINYINT(1)',
                'date': 'DATE',
                'datetime': 'DATETIME',
                'json': 'JSON',
                'uuid': 'CHAR(36)'
            }
        };
        
        return typeMap[dialect]?.[type] || type.toUpperCase();
    }
}

// === ER Diagram Generator ===
class ERDiagramGenerator {
    generateMermaid(entities: Entity[]): string {
        let diagram = 'erDiagram\\n';
        
        // Add entities
        for (const entity of entities) {
            diagram += \`  \${entity.name} {\\n\`;
            for (const col of entity.columns) {
                const pk = col.primary ? 'PK' : '';
                const fk = col.references ? 'FK' : '';
                diagram += \`    \${col.type} \${col.name} \${pk}\${fk}\\n\`;
            }
            diagram += \`  }\\n\`;
        }
        
        // Add relationships
        for (const entity of entities) {
            for (const rel of entity.relations) {
                const cardinality = {
                    'one-to-one': '||--||',
                    'one-to-many': '||--o{',
                    'many-to-many': '}o--o{'
                }[rel.type];
                
                diagram += \`  \${entity.name} \${cardinality} \${rel.targetEntity} : ""\`;
            }
        }
        
        return diagram;
    }
}

export { SchemaGenerator, ERDiagramGenerator };
`;
    }
}

export const databaseSchemaDesigner = DatabaseSchemaDesigner.getInstance();
