/**
 * ðŸ”§ DependencyAnalyzerService
 * 
 * Dependency analysis:
 * - Updates, vulnerabilities, licenses
 */

import { EventEmitter } from 'events';

export class DependencyAnalyzerService extends EventEmitter {
    private static instance: DependencyAnalyzerService;
    private constructor() { super(); }
    static getInstance(): DependencyAnalyzerService {
        if (!DependencyAnalyzerService.instance) {
            DependencyAnalyzerService.instance = new DependencyAnalyzerService();
        }
        return DependencyAnalyzerService.instance;
    }

    generate(): string {
        return `// Dependency Analyzer Service - Updates, vulnerabilities
// Generated by Shadow AI

class DependencyAnalyzer {
    // Check for outdated packages
    async checkOutdated(directory: string): Promise<OutdatedPackage[]> {
        const { stdout } = await execAsync('npm outdated --json', { cwd: directory });
        
        try {
            const outdated = JSON.parse(stdout);
            return Object.entries(outdated).map(([name, info]: [string, any]) => ({
                name,
                current: info.current,
                wanted: info.wanted,
                latest: info.latest,
                type: info.type
            }));
        } catch {
            return [];
        }
    }
    
    // Audit for vulnerabilities
    async auditVulnerabilities(directory: string): Promise<Vulnerability[]> {
        const { stdout } = await execAsync('npm audit --json', { cwd: directory });
        
        try {
            const audit = JSON.parse(stdout);
            const vulnerabilities: Vulnerability[] = [];
            
            for (const [name, vuln] of Object.entries(audit.vulnerabilities || {})) {
                vulnerabilities.push({
                    name,
                    severity: (vuln as any).severity,
                    via: (vuln as any).via,
                    fixAvailable: (vuln as any).fixAvailable
                });
            }
            
            return vulnerabilities;
        } catch {
            return [];
        }
    }
    
    // Check licenses
    async checkLicenses(directory: string): Promise<LicenseInfo[]> {
        const pkg = await fs.readJson(path.join(directory, 'package.json'));
        const deps = { ...pkg.dependencies, ...pkg.devDependencies };
        const licenses: LicenseInfo[] = [];
        
        for (const name of Object.keys(deps)) {
            try {
                const depPkg = await fs.readJson(
                    path.join(directory, 'node_modules', name, 'package.json')
                );
                
                licenses.push({
                    package: name,
                    license: depPkg.license || 'Unknown',
                    compatible: this.isLicenseCompatible(depPkg.license)
                });
            } catch {
                licenses.push({ package: name, license: 'Unknown', compatible: false });
            }
        }
        
        return licenses;
    }
    
    private isLicenseCompatible(license: string): boolean {
        const compatible = ['MIT', 'ISC', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 'CC0-1.0'];
        return compatible.includes(license);
    }
    
    // Suggest updates
    async suggestUpdates(directory: string): Promise<UpdateSuggestion[]> {
        const outdated = await this.checkOutdated(directory);
        const suggestions: UpdateSuggestion[] = [];
        
        for (const pkg of outdated) {
            const breaking = this.isBreakingChange(pkg.current, pkg.latest);
            
            suggestions.push({
                package: pkg.name,
                current: pkg.current,
                suggested: breaking ? pkg.wanted : pkg.latest,
                reason: breaking 
                    ? 'Major version change may have breaking changes' 
                    : 'Safe to update',
                safe: !breaking
            });
        }
        
        return suggestions;
    }
    
    private isBreakingChange(current: string, latest: string): boolean {
        const currentMajor = parseInt(current.split('.')[0]);
        const latestMajor = parseInt(latest.split('.')[0]);
        return latestMajor > currentMajor;
    }
    
    // Generate dependency graph
    async generateGraph(directory: string): Promise<DependencyNode> {
        const pkg = await fs.readJson(path.join(directory, 'package.json'));
        
        const buildNode = async (name: string, visited = new Set<string>()): Promise<DependencyNode> => {
            if (visited.has(name)) return { name, circular: true };
            visited.add(name);
            
            try {
                const depPkg = await fs.readJson(
                    path.join(directory, 'node_modules', name, 'package.json')
                );
                
                const deps = Object.keys(depPkg.dependencies || {});
                const children = await Promise.all(deps.map(d => buildNode(d, new Set(visited))));
                
                return { name, version: depPkg.version, children };
            } catch {
                return { name };
            }
        };
        
        const deps = Object.keys({ ...pkg.dependencies });
        const children = await Promise.all(deps.map(d => buildNode(d)));
        
        return { name: pkg.name, version: pkg.version, children };
    }
}

export { DependencyAnalyzer };
`;
    }
}

export const dependencyAnalyzerService = DependencyAnalyzerService.getInstance();
