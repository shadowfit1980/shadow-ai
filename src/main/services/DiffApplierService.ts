/**
 * ðŸ”„ DiffApplierService
 * 
 * Diff application:
 * - Patches, merge, conflict resolution
 */

import { EventEmitter } from 'events';

export class DiffApplierService extends EventEmitter {
    private static instance: DiffApplierService;
    private constructor() { super(); }
    static getInstance(): DiffApplierService {
        if (!DiffApplierService.instance) {
            DiffApplierService.instance = new DiffApplierService();
        }
        return DiffApplierService.instance;
    }

    generate(): string {
        return `// Diff Applier Service - Patches, merge
// Generated by Shadow AI

import { diffLines, applyPatch, createPatch } from 'diff';

class DiffApplier {
    // Create diff between two texts
    createDiff(oldText: string, newText: string, filename = 'file'): string {
        return createPatch(filename, oldText, newText);
    }
    
    // Apply patch to text
    applyPatch(text: string, patch: string): string | false {
        return applyPatch(text, patch);
    }
    
    // Get line-by-line diff
    getLineDiff(oldText: string, newText: string): LineDiff[] {
        const changes = diffLines(oldText, newText);
        
        return changes.map(change => ({
            value: change.value,
            added: change.added || false,
            removed: change.removed || false
        }));
    }
    
    // Apply edit to file
    async applyEdit(filePath: string, edit: Edit): Promise<void> {
        const content = await fs.readFile(filePath, 'utf-8');
        const lines = content.split('\\n');
        
        // Apply edit based on type
        let newLines: string[];
        
        switch (edit.type) {
            case 'replace':
                newLines = [
                    ...lines.slice(0, edit.startLine - 1),
                    edit.newContent,
                    ...lines.slice(edit.endLine)
                ];
                break;
            case 'insert':
                newLines = [
                    ...lines.slice(0, edit.startLine),
                    edit.newContent,
                    ...lines.slice(edit.startLine)
                ];
                break;
            case 'delete':
                newLines = [
                    ...lines.slice(0, edit.startLine - 1),
                    ...lines.slice(edit.endLine)
                ];
                break;
            default:
                newLines = lines;
        }
        
        await fs.writeFile(filePath, newLines.join('\\n'));
    }
    
    // Parse unified diff
    parseDiff(diff: string): ParsedDiff {
        const lines = diff.split('\\n');
        const hunks: Hunk[] = [];
        let currentHunk: Hunk | null = null;
        
        for (const line of lines) {
            if (line.startsWith('@@')) {
                const match = line.match(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);
                if (match) {
                    currentHunk = {
                        oldStart: parseInt(match[1]),
                        oldLines: parseInt(match[2]),
                        newStart: parseInt(match[3]),
                        newLines: parseInt(match[4]),
                        lines: []
                    };
                    hunks.push(currentHunk);
                }
            } else if (currentHunk) {
                currentHunk.lines.push(line);
            }
        }
        
        return { hunks };
    }
    
    // Intelligent merge with AI
    async aiMerge(original: string, ours: string, theirs: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Merge these three versions of code. Original is the base. Combine changes from "ours" and "theirs". Return only the merged code.'
        }, {
            role: 'user',
            content: \`Original:\\n\${original}\\n\\nOurs:\\n\${ours}\\n\\nTheirs:\\n\${theirs}\`
        }]);
        
        return response.content;
    }
    
    // Validate patch can be applied
    validatePatch(text: string, patch: string): { valid: boolean; reason?: string } {
        try {
            const result = applyPatch(text, patch);
            return { valid: result !== false };
        } catch (error) {
            return { valid: false, reason: error.message };
        }
    }
}

export { DiffApplier };
`;
    }
}

export const diffApplierService = DiffApplierService.getInstance();
