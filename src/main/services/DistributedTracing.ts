/**
 * ðŸ” Distributed Tracing Generator
 * 
 * Generate observability patterns:
 * - OpenTelemetry, Jaeger
 */

import { EventEmitter } from 'events';

export class DistributedTracing extends EventEmitter {
    private static instance: DistributedTracing;

    private constructor() { super(); }

    static getInstance(): DistributedTracing {
        if (!DistributedTracing.instance) {
            DistributedTracing.instance = new DistributedTracing();
        }
        return DistributedTracing.instance;
    }

    generate(): string {
        return `// Distributed Tracing with OpenTelemetry
// Generated by Shadow AI

// === OpenTelemetry Setup ===
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const sdk = new NodeSDK({
    resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: 'my-service',
        [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
        [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV
    }),
    
    traceExporter: new OTLPTraceExporter({
        url: 'http://jaeger:4318/v1/traces'
    }),
    
    metricReader: new PeriodicExportingMetricReader({
        exporter: new OTLPMetricExporter({
            url: 'http://prometheus:4318/v1/metrics'
        }),
        exportIntervalMillis: 10000
    }),
    
    instrumentations: [
        getNodeAutoInstrumentations({
            '@opentelemetry/instrumentation-express': { enabled: true },
            '@opentelemetry/instrumentation-http': { enabled: true },
            '@opentelemetry/instrumentation-pg': { enabled: true },
            '@opentelemetry/instrumentation-redis': { enabled: true },
            '@opentelemetry/instrumentation-grpc': { enabled: true }
        })
    ]
});

sdk.start();
process.on('SIGTERM', () => sdk.shutdown());

// === Manual Instrumentation ===
import { trace, SpanStatusCode, context, propagation } from '@opentelemetry/api';

const tracer = trace.getTracer('my-service');

// Create custom span
async function processOrder(orderId: string) {
    return tracer.startActiveSpan('processOrder', async (span) => {
        try {
            span.setAttribute('order.id', orderId);
            
            // Child span for database
            await tracer.startActiveSpan('db.getOrder', async (dbSpan) => {
                const order = await db.order.findUnique({ where: { id: orderId } });
                dbSpan.setAttribute('db.rows_affected', 1);
                dbSpan.end();
                return order;
            });
            
            // Child span for payment
            await tracer.startActiveSpan('payment.process', async (paymentSpan) => {
                paymentSpan.addEvent('payment_initiated');
                const result = await paymentService.charge(order);
                paymentSpan.setAttribute('payment.status', result.status);
                paymentSpan.addEvent('payment_completed');
                paymentSpan.end();
                return result;
            });
            
            span.setStatus({ code: SpanStatusCode.OK });
        } catch (error: any) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
            span.recordException(error);
            throw error;
        } finally {
            span.end();
        }
    });
}

// === Context Propagation ===
// Outgoing HTTP request
async function callExternalService(url: string, data: object) {
    return tracer.startActiveSpan('external.call', async (span) => {
        const headers: Record<string, string> = { 'Content-Type': 'application/json' };
        
        // Inject trace context into headers
        propagation.inject(context.active(), headers);
        
        span.setAttribute('http.url', url);
        
        const response = await fetch(url, {
            method: 'POST',
            headers,
            body: JSON.stringify(data)
        });
        
        span.setAttribute('http.status_code', response.status);
        span.end();
        
        return response.json();
    });
}

// Extract context from incoming request (Express middleware)
function tracingMiddleware(req, res, next) {
    const extractedContext = propagation.extract(context.active(), req.headers);
    
    context.with(extractedContext, () => {
        const span = tracer.startSpan(\`\${req.method} \${req.path}\`, {
            attributes: {
                'http.method': req.method,
                'http.url': req.url,
                'http.user_agent': req.headers['user-agent']
            }
        });
        
        // Store span for later
        req.span = span;
        
        res.on('finish', () => {
            span.setAttribute('http.status_code', res.statusCode);
            span.setStatus({ code: res.statusCode < 400 ? SpanStatusCode.OK : SpanStatusCode.ERROR });
            span.end();
        });
        
        next();
    });
}

// === Jaeger Docker Compose ===
/* docker-compose.yml
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # UI
      - "4317:4317"    # OTLP gRPC
      - "4318:4318"    # OTLP HTTP
    environment:
      COLLECTOR_OTLP_ENABLED: true
*/

// === Custom Metrics ===
import { metrics } from '@opentelemetry/api';

const meter = metrics.getMeter('my-service');

const requestCounter = meter.createCounter('http_requests_total', {
    description: 'Total HTTP requests'
});

const requestDuration = meter.createHistogram('http_request_duration_ms', {
    description: 'HTTP request duration'
});

function metricsMiddleware(req, res, next) {
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - start;
        const labels = { method: req.method, path: req.path, status: res.statusCode };
        
        requestCounter.add(1, labels);
        requestDuration.record(duration, labels);
    });
    
    next();
}

export { sdk, tracer, processOrder, callExternalService, tracingMiddleware, metricsMiddleware };
`;
    }
}

export const distributedTracing = DistributedTracing.getInstance();
