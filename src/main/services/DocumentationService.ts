/**
 * ðŸ“š DocumentationService
 * 
 * Documentation generation:
 * - JSDoc, README, API docs
 */

import { EventEmitter } from 'events';

export class DocumentationService extends EventEmitter {
    private static instance: DocumentationService;
    private constructor() { super(); }
    static getInstance(): DocumentationService {
        if (!DocumentationService.instance) {
            DocumentationService.instance = new DocumentationService();
        }
        return DocumentationService.instance;
    }

    generate(): string {
        return `// Documentation Service - JSDoc, README, API docs
// Generated by Shadow AI

class DocGenerator {
    // Generate JSDoc for function
    async generateJSDoc(functionCode: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Generate comprehensive JSDoc for this function. Include:
            - @description
            - @param for each parameter
            - @returns
            - @throws if applicable
            - @example
            Return only the JSDoc comment.\`
        }, {
            role: 'user',
            content: functionCode
        }]);
        
        return response.content;
    }
    
    // Generate README
    async generateREADME(projectInfo: ProjectInfo): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Generate a comprehensive README.md for this project. Include:
            - Title and description
            - Installation
            - Usage
            - API reference
            - Contributing
            - License
            Use markdown formatting.\`
        }, {
            role: 'user',
            content: JSON.stringify(projectInfo)
        }]);
        
        return response.content;
    }
    
    // Generate API documentation
    async generateAPIDocs(endpoints: Endpoint[]): Promise<string> {
        let docs = '# API Documentation\\n\\n';
        
        for (const endpoint of endpoints) {
            docs += \`## \${endpoint.method} \${endpoint.path}\\n\\n\`;
            docs += \`\${endpoint.description}\\n\\n\`;
            
            if (endpoint.parameters.length > 0) {
                docs += '### Parameters\\n\\n';
                docs += '| Name | Type | Required | Description |\\n';
                docs += '|------|------|----------|-------------|\\n';
                
                for (const param of endpoint.parameters) {
                    docs += \`| \${param.name} | \${param.type} | \${param.required ? 'Yes' : 'No'} | \${param.description} |\\n\`;
                }
                docs += '\\n';
            }
            
            docs += '### Response\\n\\n';
            docs += \`\\\`\\\`\\\`json\\n\${JSON.stringify(endpoint.response, null, 2)}\\n\\\`\\\`\\\`\\n\\n\`;
        }
        
        return docs;
    }
    
    // Generate inline comments
    async addInlineComments(code: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Add helpful inline comments to explain complex logic. Keep comments concise but informative. Return the code with comments.'
        }, {
            role: 'user',
            content: code
        }]);
        
        return response.content;
    }
    
    // Generate changelog entry
    async generateChangelog(commits: Commit[]): Promise<string> {
        const grouped = this.groupCommits(commits);
        let changelog = \`## [\${this.getNextVersion()}] - \${new Date().toISOString().split('T')[0]}\\n\\n\`;
        
        if (grouped.features.length > 0) {
            changelog += '### Features\\n\\n';
            grouped.features.forEach(c => changelog += \`- \${c.message}\\n\`);
            changelog += '\\n';
        }
        
        if (grouped.fixes.length > 0) {
            changelog += '### Bug Fixes\\n\\n';
            grouped.fixes.forEach(c => changelog += \`- \${c.message}\\n\`);
            changelog += '\\n';
        }
        
        return changelog;
    }
    
    private groupCommits(commits: Commit[]) {
        return {
            features: commits.filter(c => c.message.startsWith('feat')),
            fixes: commits.filter(c => c.message.startsWith('fix')),
            docs: commits.filter(c => c.message.startsWith('docs')),
            other: commits.filter(c => !['feat', 'fix', 'docs'].some(p => c.message.startsWith(p)))
        };
    }
    
    // Generate type documentation
    async generateTypeDoc(typeDefinition: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Generate documentation for this TypeScript type/interface. Explain each property.'
        }, {
            role: 'user',
            content: typeDefinition
        }]);
        
        return response.content;
    }
}

export { DocGenerator };
`;
    }
}

export const documentationService = DocumentationService.getInstance();
