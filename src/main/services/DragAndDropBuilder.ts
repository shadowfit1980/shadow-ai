/**
 * üé® Drag and Drop Builder
 * 
 * No-code component building:
 * - Visual editor, generates clean code
 */

import { EventEmitter } from 'events';

export class DragAndDropBuilder extends EventEmitter {
    private static instance: DragAndDropBuilder;

    private constructor() { super(); }

    static getInstance(): DragAndDropBuilder {
        if (!DragAndDropBuilder.instance) {
            DragAndDropBuilder.instance = new DragAndDropBuilder();
        }
        return DragAndDropBuilder.instance;
    }

    generate(): string {
        return `// Drag and Drop Builder
// Generated by Shadow AI

/**
 * DRAG AND DROP BUILDER
 * 
 * Visual component builder that generates clean, production-ready code.
 * Like Webflow but outputs React/Vue components.
 */

// === Component Library ===
interface DraggableComponent {
    id: string;
    type: string;
    category: 'layout' | 'input' | 'display' | 'navigation' | 'media';
    icon: string;
    defaultProps: Record<string, any>;
    schema: PropSchema[];
}

const componentLibrary: DraggableComponent[] = [
    // Layout
    { id: 'container', type: 'Container', category: 'layout', icon: 'üì¶', 
      defaultProps: { display: 'flex', direction: 'column', padding: '16px' },
      schema: [
        { name: 'display', type: 'select', options: ['flex', 'grid', 'block'] },
        { name: 'direction', type: 'select', options: ['row', 'column'] },
        { name: 'gap', type: 'number', default: 8 }
      ]
    },
    { id: 'grid', type: 'Grid', category: 'layout', icon: 'üìê',
      defaultProps: { columns: 2, gap: '16px' },
      schema: [
        { name: 'columns', type: 'number', min: 1, max: 12 },
        { name: 'gap', type: 'string' }
      ]
    },
    
    // Input
    { id: 'button', type: 'Button', category: 'input', icon: 'üîò',
      defaultProps: { variant: 'primary', text: 'Click me' },
      schema: [
        { name: 'text', type: 'string' },
        { name: 'variant', type: 'select', options: ['primary', 'secondary', 'outline'] },
        { name: 'onClick', type: 'action' }
      ]
    },
    { id: 'input', type: 'TextInput', category: 'input', icon: 'üìù',
      defaultProps: { placeholder: 'Enter text...', type: 'text' },
      schema: [
        { name: 'placeholder', type: 'string' },
        { name: 'type', type: 'select', options: ['text', 'email', 'password', 'number'] },
        { name: 'required', type: 'boolean' }
      ]
    },
    
    // Display
    { id: 'text', type: 'Text', category: 'display', icon: 'üìÑ',
      defaultProps: { content: 'Hello World', tag: 'p' },
      schema: [
        { name: 'content', type: 'string' },
        { name: 'tag', type: 'select', options: ['h1', 'h2', 'h3', 'p', 'span'] }
      ]
    },
    { id: 'card', type: 'Card', category: 'display', icon: 'üÉè',
      defaultProps: { title: 'Card Title', shadow: 'md' },
      schema: [
        { name: 'title', type: 'string' },
        { name: 'shadow', type: 'select', options: ['sm', 'md', 'lg'] }
      ]
    },
    
    // Navigation
    { id: 'link', type: 'Link', category: 'navigation', icon: 'üîó',
      defaultProps: { href: '#', text: 'Link' },
      schema: [
        { name: 'href', type: 'string' },
        { name: 'text', type: 'string' },
        { name: 'external', type: 'boolean' }
      ]
    }
];

// === Canvas State ===
interface CanvasNode {
    id: string;
    componentId: string;
    props: Record<string, any>;
    styles: Record<string, any>;
    children: CanvasNode[];
    parentId: string | null;
}

class CanvasState {
    private nodes: Map<string, CanvasNode> = new Map();
    private rootId: string = 'root';
    private history: CanvasNode[][] = [];
    private historyIndex = -1;
    
    addNode(componentId: string, parentId: string, position: number): CanvasNode {
        const component = componentLibrary.find(c => c.id === componentId);
        if (!component) throw new Error(\`Component not found: \${componentId}\`);
        
        const node: CanvasNode = {
            id: crypto.randomUUID(),
            componentId,
            props: { ...component.defaultProps },
            styles: {},
            children: [],
            parentId
        };
        
        this.nodes.set(node.id, node);
        
        if (parentId) {
            const parent = this.nodes.get(parentId);
            parent?.children.splice(position, 0, node);
        }
        
        this.saveHistory();
        return node;
    }
    
    moveNode(nodeId: string, newParentId: string, position: number): void {
        const node = this.nodes.get(nodeId);
        if (!node) return;
        
        // Remove from old parent
        if (node.parentId) {
            const oldParent = this.nodes.get(node.parentId);
            if (oldParent) {
                oldParent.children = oldParent.children.filter(c => c.id !== nodeId);
            }
        }
        
        // Add to new parent
        node.parentId = newParentId;
        const newParent = this.nodes.get(newParentId);
        newParent?.children.splice(position, 0, node);
        
        this.saveHistory();
    }
    
    updateProps(nodeId: string, props: Partial<Record<string, any>>): void {
        const node = this.nodes.get(nodeId);
        if (node) {
            node.props = { ...node.props, ...props };
            this.saveHistory();
        }
    }
    
    updateStyles(nodeId: string, styles: Partial<Record<string, any>>): void {
        const node = this.nodes.get(nodeId);
        if (node) {
            node.styles = { ...node.styles, ...styles };
            this.saveHistory();
        }
    }
    
    undo(): void {
        if (this.historyIndex > 0) {
            this.historyIndex--;
            this.restoreFromHistory();
        }
    }
    
    redo(): void {
        if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.restoreFromHistory();
        }
    }
}

// === Code Generator ===
class ReactCodeGenerator {
    generate(canvas: CanvasState): string {
        const root = canvas.getRoot();
        
        let imports = new Set<string>();
        const componentCode = this.generateNode(root, imports);
        
        return \`
import React from 'react';
\${Array.from(imports).map(i => \`import { \${i} } from './components';\`).join('\\n')}

export default function GeneratedPage() {
    return (
        \${componentCode}
    );
}
        \`.trim();
    }
    
    private generateNode(node: CanvasNode, imports: Set<string>): string {
        const component = componentLibrary.find(c => c.id === node.componentId);
        if (!component) return '';
        
        imports.add(component.type);
        
        const propsStr = Object.entries(node.props)
            .filter(([_, v]) => v !== undefined && v !== component.defaultProps[_])
            .map(([k, v]) => typeof v === 'string' ? \`\${k}="\${v}"\` : \`\${k}={\${JSON.stringify(v)}}\`)
            .join(' ');
        
        const styleStr = Object.keys(node.styles).length > 0
            ? \`style={\${JSON.stringify(node.styles)}}\`
            : '';
        
        const children = node.children
            .map(child => this.generateNode(child, imports))
            .join('\\n');
        
        if (children) {
            return \`<\${component.type} \${propsStr} \${styleStr}>\\n\${children}\\n</\${component.type}>\`;
        }
        
        return \`<\${component.type} \${propsStr} \${styleStr} />\`;
    }
}

export { componentLibrary, CanvasState, ReactCodeGenerator };
`;
    }
}

export const dragAndDropBuilder = DragAndDropBuilder.getInstance();
