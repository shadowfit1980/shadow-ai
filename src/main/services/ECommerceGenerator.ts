/**
 * ðŸ›’ E-Commerce Generator
 * 
 * E-commerce features:
 * - Cart, checkout, inventory, orders
 */

import { EventEmitter } from 'events';

export class ECommerceGenerator extends EventEmitter {
    private static instance: ECommerceGenerator;

    private constructor() { super(); }

    static getInstance(): ECommerceGenerator {
        if (!ECommerceGenerator.instance) {
            ECommerceGenerator.instance = new ECommerceGenerator();
        }
        return ECommerceGenerator.instance;
    }

    generate(): string {
        return `// E-Commerce Generator
// Generated by Shadow AI

/**
 * E-COMMERCE GENERATOR
 * 
 * Complete e-commerce system with cart, checkout, inventory.
 */

// === Shopping Cart ===
class ShoppingCart {
    generateCartContext(): string {
        return \`
// Cart Context with Zustand
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface CartItem {
    id: string;
    productId: string;
    name: string;
    price: number;
    quantity: number;
    image: string;
    variant?: { size?: string; color?: string };
}

interface CartStore {
    items: CartItem[];
    addItem: (item: Omit<CartItem, 'id' | 'quantity'>) => void;
    removeItem: (id: string) => void;
    updateQuantity: (id: string, quantity: number) => void;
    clearCart: () => void;
    total: number;
    itemCount: number;
}

export const useCart = create<CartStore>()(
    persist(
        (set, get) => ({
            items: [],
            
            addItem: (item) => {
                const items = get().items;
                const existing = items.find(i => 
                    i.productId === item.productId && 
                    JSON.stringify(i.variant) === JSON.stringify(item.variant)
                );
                
                if (existing) {
                    set({
                        items: items.map(i =>
                            i.id === existing.id
                                ? { ...i, quantity: i.quantity + 1 }
                                : i
                        )
                    });
                } else {
                    set({
                        items: [...items, { ...item, id: crypto.randomUUID(), quantity: 1 }]
                    });
                }
            },
            
            removeItem: (id) => {
                set({ items: get().items.filter(i => i.id !== id) });
            },
            
            updateQuantity: (id, quantity) => {
                if (quantity <= 0) {
                    set({ items: get().items.filter(i => i.id !== id) });
                } else {
                    set({
                        items: get().items.map(i =>
                            i.id === id ? { ...i, quantity } : i
                        )
                    });
                }
            },
            
            clearCart: () => set({ items: [] }),
            
            get total() {
                return get().items.reduce((sum, item) => sum + item.price * item.quantity, 0);
            },
            
            get itemCount() {
                return get().items.reduce((sum, item) => sum + item.quantity, 0);
            }
        }),
        { name: 'cart-storage' }
    )
);
        \`;
    }
}

// === Checkout Flow ===
class CheckoutFlow {
    generateCheckoutAPI(): string {
        return \`
// Checkout API
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function createCheckoutSession(items: CartItem[], customerId?: string) {
    // Validate inventory
    for (const item of items) {
        const product = await prisma.product.findUnique({
            where: { id: item.productId }
        });
        
        if (!product || product.stock < item.quantity) {
            throw new Error(\\\`Insufficient stock for \\\${item.name}\\\`);
        }
    }
    
    // Create Stripe session
    const session = await stripe.checkout.sessions.create({
        mode: 'payment',
        customer: customerId,
        line_items: items.map(item => ({
            price_data: {
                currency: 'usd',
                product_data: {
                    name: item.name,
                    images: [item.image]
                },
                unit_amount: Math.round(item.price * 100)
            },
            quantity: item.quantity
        })),
        success_url: process.env.NEXT_PUBLIC_URL + '/checkout/success?session_id={CHECKOUT_SESSION_ID}',
        cancel_url: process.env.NEXT_PUBLIC_URL + '/cart',
        metadata: {
            items: JSON.stringify(items.map(i => ({ id: i.productId, qty: i.quantity })))
        }
    });
    
    return { sessionId: session.id, url: session.url };
}

export async function handleWebhook(event: Stripe.Event) {
    if (event.type === 'checkout.session.completed') {
        const session = event.data.object as Stripe.Checkout.Session;
        const items = JSON.parse(session.metadata!.items);
        
        // Create order
        const order = await prisma.order.create({
            data: {
                userId: session.customer as string,
                status: 'processing',
                total: session.amount_total! / 100,
                items: {
                    create: items.map((item: any) => ({
                        productId: item.id,
                        quantity: item.qty
                    }))
                }
            }
        });
        
        // Update inventory
        for (const item of items) {
            await prisma.product.update({
                where: { id: item.id },
                data: { stock: { decrement: item.qty } }
            });
        }
        
        // Send confirmation email
        await sendOrderConfirmation(order);
    }
}
        \`;
    }
}

// === Inventory Management ===
class InventoryManagement {
    generateInventorySystem(): string {
        return \`
// Inventory Management
export async function updateStock(productId: string, quantity: number, reason: string) {
    const product = await prisma.product.update({
        where: { id: productId },
        data: { stock: { increment: quantity } }
    });
    
    // Log inventory change
    await prisma.inventoryLog.create({
        data: {
            productId,
            quantityChanged: quantity,
            newStock: product.stock,
            reason
        }
    });
    
    // Check low stock alert
    if (product.stock <= product.lowStockThreshold) {
        await notifyLowStock(product);
    }
    
    return product;
}

export async function reserveStock(items: { productId: string; quantity: number }[]) {
    const reservationId = crypto.randomUUID();
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes
    
    for (const item of items) {
        await prisma.stockReservation.create({
            data: {
                id: reservationId,
                productId: item.productId,
                quantity: item.quantity,
                expiresAt
            }
        });
    }
    
    return reservationId;
}
        \`;
    }
}

export { ShoppingCart, CheckoutFlow, InventoryManagement };
`;
    }
}

export const eCommerceGenerator = ECommerceGenerator.getInstance();
