/**
 * ⚛️ Electron Patterns Generator
 * 
 * Generate Electron code:
 * - IPC, security, packaging
 */

import { EventEmitter } from 'events';

export class ElectronPatterns extends EventEmitter {
    private static instance: ElectronPatterns;

    private constructor() { super(); }

    static getInstance(): ElectronPatterns {
        if (!ElectronPatterns.instance) {
            ElectronPatterns.instance = new ElectronPatterns();
        }
        return ElectronPatterns.instance;
    }

    generateMain(): string {
        return `// Electron Main Process
// Generated by Shadow AI

import { app, BrowserWindow, ipcMain, dialog, shell, Menu, Tray, nativeTheme } from 'electron';
import { autoUpdater } from 'electron-updater';
import Store from 'electron-store';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const store = new Store();
let mainWindow: BrowserWindow | null = null;
let tray: Tray | null = null;

// Security: Disable remote module
app.disableHardwareAcceleration();

async function createWindow() {
    mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        minWidth: 800,
        minHeight: 600,
        show: false,
        titleBarStyle: 'hiddenInset',
        trafficLightPosition: { x: 15, y: 15 },
        webPreferences: {
            preload: path.join(__dirname, 'preload.js'),
            nodeIntegration: false,
            contextIsolation: true,
            sandbox: true,
            webSecurity: true
        }
    });

    // Restore window state
    const bounds = store.get('windowBounds');
    if (bounds) mainWindow.setBounds(bounds);

    // Load app
    if (process.env.NODE_ENV === 'development') {
        mainWindow.loadURL('http://localhost:5173');
        mainWindow.webContents.openDevTools();
    } else {
        mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
    }

    // Show when ready
    mainWindow.once('ready-to-show', () => {
        mainWindow?.show();
        checkForUpdates();
    });

    // Save window state
    mainWindow.on('close', () => {
        if (mainWindow) store.set('windowBounds', mainWindow.getBounds());
    });

    mainWindow.on('closed', () => {
        mainWindow = null;
    });

    // Security: Prevent navigation
    mainWindow.webContents.on('will-navigate', (event, url) => {
        if (!url.startsWith('http://localhost') && !url.startsWith('file://')) {
            event.preventDefault();
            shell.openExternal(url);
        }
    });
}

// IPC Handlers
ipcMain.handle('dialog:open', async (_, options) => {
    const result = await dialog.showOpenDialog(mainWindow!, options);
    return result.filePaths;
});

ipcMain.handle('dialog:save', async (_, options) => {
    const result = await dialog.showSaveDialog(mainWindow!, options);
    return result.filePath;
});

ipcMain.handle('store:get', (_, key) => store.get(key));
ipcMain.handle('store:set', (_, key, value) => store.set(key, value));
ipcMain.handle('store:delete', (_, key) => store.delete(key));

ipcMain.handle('app:getPath', (_, name) => app.getPath(name));
ipcMain.handle('app:getVersion', () => app.getVersion());

ipcMain.on('window:minimize', () => mainWindow?.minimize());
ipcMain.on('window:maximize', () => mainWindow?.isMaximized() ? mainWindow.unmaximize() : mainWindow?.maximize());
ipcMain.on('window:close', () => mainWindow?.close());

// Theme
ipcMain.handle('theme:get', () => nativeTheme.themeSource);
ipcMain.handle('theme:set', (_, theme) => nativeTheme.themeSource = theme);

nativeTheme.on('updated', () => {
    mainWindow?.webContents.send('theme:changed', nativeTheme.shouldUseDarkColors);
});

// Auto updater
function checkForUpdates() {
    if (process.env.NODE_ENV !== 'development') {
        autoUpdater.checkForUpdatesAndNotify();
    }
}

autoUpdater.on('update-available', () => {
    mainWindow?.webContents.send('update:available');
});

autoUpdater.on('update-downloaded', () => {
    mainWindow?.webContents.send('update:downloaded');
    dialog.showMessageBox(mainWindow!, {
        type: 'info',
        title: 'Update Ready',
        message: 'A new version is ready. Restart to update?',
        buttons: ['Restart', 'Later']
    }).then(({ response }) => {
        if (response === 0) autoUpdater.quitAndInstall();
    });
});

// Tray
function createTray() {
    tray = new Tray(path.join(__dirname, '../assets/tray@2x.png'));
    
    const contextMenu = Menu.buildFromTemplate([
        { label: 'Show App', click: () => mainWindow?.show() },
        { type: 'separator' },
        { label: 'Quit', click: () => app.quit() }
    ]);
    
    tray.setToolTip('My App');
    tray.setContextMenu(contextMenu);
    
    tray.on('double-click', () => mainWindow?.show());
}

// App lifecycle
app.whenReady().then(() => {
    createWindow();
    createTray();
    
    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') app.quit();
});

// Security headers
app.on('web-contents-created', (_, contents) => {
    contents.setWindowOpenHandler(({ url }) => {
        shell.openExternal(url);
        return { action: 'deny' };
    });
});
`;
    }

    generatePreload(): string {
        return `// Electron Preload Script (Secure Bridge)
// Generated by Shadow AI

import { contextBridge, ipcRenderer } from 'electron';

// Expose protected methods in the main world
contextBridge.exposeInMainWorld('electronAPI', {
    // Dialog
    openFile: (options?: Electron.OpenDialogOptions) => 
        ipcRenderer.invoke('dialog:open', options),
    saveFile: (options?: Electron.SaveDialogOptions) =>
        ipcRenderer.invoke('dialog:save', options),
    
    // Store
    store: {
        get: (key: string) => ipcRenderer.invoke('store:get', key),
        set: (key: string, value: any) => ipcRenderer.invoke('store:set', key, value),
        delete: (key: string) => ipcRenderer.invoke('store:delete', key)
    },
    
    // App info
    getPath: (name: string) => ipcRenderer.invoke('app:getPath', name),
    getVersion: () => ipcRenderer.invoke('app:getVersion'),
    
    // Window controls
    window: {
        minimize: () => ipcRenderer.send('window:minimize'),
        maximize: () => ipcRenderer.send('window:maximize'),
        close: () => ipcRenderer.send('window:close')
    },
    
    // Theme
    theme: {
        get: () => ipcRenderer.invoke('theme:get'),
        set: (theme: 'system' | 'light' | 'dark') => ipcRenderer.invoke('theme:set', theme),
        onChanged: (callback: (isDark: boolean) => void) => {
            const handler = (_: any, isDark: boolean) => callback(isDark);
            ipcRenderer.on('theme:changed', handler);
            return () => ipcRenderer.removeListener('theme:changed', handler);
        }
    },
    
    // Updates
    updates: {
        onAvailable: (callback: () => void) => {
            ipcRenderer.on('update:available', callback);
            return () => ipcRenderer.removeListener('update:available', callback);
        },
        onDownloaded: (callback: () => void) => {
            ipcRenderer.on('update:downloaded', callback);
            return () => ipcRenderer.removeListener('update:downloaded', callback);
        }
    }
});

// Type declaration for renderer
declare global {
    interface Window {
        electronAPI: {
            openFile: (options?: Electron.OpenDialogOptions) => Promise<string[]>;
            saveFile: (options?: Electron.SaveDialogOptions) => Promise<string | undefined>;
            store: {
                get: (key: string) => Promise<any>;
                set: (key: string, value: any) => Promise<void>;
                delete: (key: string) => Promise<void>;
            };
            getPath: (name: string) => Promise<string>;
            getVersion: () => Promise<string>;
            window: {
                minimize: () => void;
                maximize: () => void;
                close: () => void;
            };
            theme: {
                get: () => Promise<'system' | 'light' | 'dark'>;
                set: (theme: 'system' | 'light' | 'dark') => Promise<void>;
                onChanged: (callback: (isDark: boolean) => void) => () => void;
            };
        };
    }
}
`;
    }
}

export const electronPatterns = ElectronPatterns.getInstance();
