/**
 * ‚ù§Ô∏è EmotionalIntelligenceService
 * 
 * Developer mood detection:
 * - Frustration, context-aware assistance
 */

import { EventEmitter } from 'events';

export class EmotionalIntelligenceService extends EventEmitter {
    private static instance: EmotionalIntelligenceService;
    private constructor() { super(); }
    static getInstance(): EmotionalIntelligenceService {
        if (!EmotionalIntelligenceService.instance) {
            EmotionalIntelligenceService.instance = new EmotionalIntelligenceService();
        }
        return EmotionalIntelligenceService.instance;
    }

    generate(): string {
        return `// Emotional Intelligence Service - Developer mood detection
// Generated by Shadow AI

class EmotionalIntelligence {
    private moodHistory: MoodEntry[] = [];
    private typingMetrics: TypingMetrics = { speed: [], deletions: [], pauses: [] };
    
    // Analyze developer state
    async analyzeDeveloperState(signals: DeveloperSignals): Promise<DeveloperState> {
        const mood = await this.detectMood(signals);
        const engagement = await this.measureEngagement(signals);
        const frustration = await this.detectFrustration(signals);
        
        const state: DeveloperState = {
            mood,
            engagement,
            frustration,
            suggestedAction: await this.suggestAction(mood, frustration),
            timestamp: Date.now()
        };
        
        this.moodHistory.push({ state, timestamp: Date.now() });
        
        return state;
    }
    
    private async detectMood(signals: DeveloperSignals): Promise<Mood> {
        let moodScore = 50; // Neutral baseline
        
        // Typing speed analysis
        if (signals.typingSpeed < 20) moodScore -= 10; // Slow = thinking or frustrated
        if (signals.typingSpeed > 80) moodScore += 5; // Fast = in flow
        
        // Error frequency
        if (signals.errorRate > 0.3) moodScore -= 15;
        if (signals.errorRate < 0.1) moodScore += 10;
        
        // Undo frequency
        if (signals.undoFrequency > 5) moodScore -= 10; // Many undos = struggling
        
        // Time on same line
        if (signals.timeOnSameLine > 300000) moodScore -= 20; // 5+ minutes = stuck
        
        // Voice tone if available
        if (signals.voiceTone) {
            if (signals.voiceTone === 'frustrated') moodScore -= 25;
            if (signals.voiceTone === 'excited') moodScore += 15;
        }
        
        if (moodScore >= 70) return 'happy';
        if (moodScore >= 40) return 'neutral';
        if (moodScore >= 20) return 'stressed';
        return 'frustrated';
    }
    
    private async detectFrustration(signals: DeveloperSignals): Promise<FrustrationLevel> {
        const indicators = [
            signals.undoFrequency > 5,
            signals.errorRate > 0.3,
            signals.sameErrorCount > 3,
            signals.timeOnSameLine > 300000,
            signals.typingSpeed < 15,
            signals.isDeleting && signals.deletionRate > 0.5
        ];
        
        const score = indicators.filter(Boolean).length;
        
        if (score >= 4) return { level: 'high', score, shouldIntervene: true };
        if (score >= 2) return { level: 'medium', score, shouldIntervene: false };
        return { level: 'low', score, shouldIntervene: false };
    }
    
    private async suggestAction(mood: Mood, frustration: FrustrationLevel): Promise<SuggestedAction> {
        if (frustration.shouldIntervene) {
            return {
                type: 'offer_help',
                message: "You seem stuck ‚Äî want me to take over this part?",
                options: ['Take over', 'Give hints', 'Explain the error', 'Take a break']
            };
        }
        
        if (mood === 'stressed') {
            return {
                type: 'gentle_support',
                message: "Complex problem! Here's what I'd suggest...",
                options: ['Show approach', 'Simplify task', 'Pair with me']
            };
        }
        
        if (mood === 'happy') {
            return {
                type: 'encourage',
                message: "Nice work! You're in the flow! üî•",
                options: null
            };
        }
        
        return { type: 'observe', message: null, options: null };
    }
    
    // Proactive assistance
    async proactiveAssist(context: CodeContext, state: DeveloperState): Promise<Assistance | null> {
        if (state.frustration.shouldIntervene) {
            // Analyze the current code problem
            const response = await llm.chat([{
                role: 'system',
                content: \`The developer is frustrated with this code. Analyze why and provide empathetic, helpful assistance.
                Be encouraging and offer concrete solutions.\`
            }, {
                role: 'user',
                content: \`Code: \${context.currentCode}\n\nRecent errors: \${JSON.stringify(context.recentErrors)}\`
            }]);
            
            return {
                type: 'takeover_offer',
                content: response.content,
                tonality: 'empathetic'
            };
        }
        
        return null;
    }
    
    // Track typing patterns
    trackTyping(event: TypingEvent): void {
        this.typingMetrics.speed.push(event.wpm);
        
        if (event.isDelete) {
            this.typingMetrics.deletions.push(event.timestamp);
        }
        
        if (event.pauseDuration > 3000) {
            this.typingMetrics.pauses.push(event.pauseDuration);
        }
    }
    
    // Get mood trends
    getMoodTrends(period: 'day' | 'week' | 'month'): MoodTrend {
        const since = this.getPeriodStart(period);
        const relevant = this.moodHistory.filter(m => m.timestamp >= since);
        
        return {
            averageMood: this.calculateAverageMood(relevant),
            frustrationPeaks: relevant.filter(m => m.state.frustration.level === 'high'),
            productivity: this.calculateProductivity(relevant)
        };
    }
    
    // Celebrate achievements
    celebrate(achievement: string): void {
        this.emit('celebrate', { achievement, message: \`üéâ \${achievement}! Great job!\` });
    }
}

export { EmotionalIntelligence };
`;
    }
}

export const emotionalIntelligenceService = EmotionalIntelligenceService.getInstance();
