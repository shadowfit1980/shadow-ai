/**
 * ðŸ› Error Tracking Generator
 * 
 * Generate error tracking:
 * - Sentry integration
 */

import { EventEmitter } from 'events';

export class ErrorTracking extends EventEmitter {
    private static instance: ErrorTracking;

    private constructor() { super(); }

    static getInstance(): ErrorTracking {
        if (!ErrorTracking.instance) {
            ErrorTracking.instance = new ErrorTracking();
        }
        return ErrorTracking.instance;
    }

    generate(): string {
        return `// Error Tracking with Sentry
// Generated by Shadow AI

import * as Sentry from '@sentry/node';
import { nodeProfilingIntegration } from '@sentry/profiling-node';

// Initialize Sentry
Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV || 'development',
    release: process.env.APP_VERSION || '1.0.0',
    
    // Performance monitoring
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    profilesSampleRate: 0.1,
    
    integrations: [
        nodeProfilingIntegration(),
        new Sentry.Integrations.Http({ tracing: true }),
        new Sentry.Integrations.Express({ router: true }),
        new Sentry.Integrations.Prisma({ client: prisma }),
        new Sentry.Integrations.Postgres()
    ],
    
    // Filter sensitive data
    beforeSend(event, hint) {
        // Don't send in development
        if (process.env.NODE_ENV === 'development') return null;
        
        // Filter out expected errors
        const error = hint.originalException;
        if (error instanceof NotFoundError) return null;
        if (error instanceof ValidationError) return null;
        
        // Scrub sensitive data
        if (event.request?.headers) {
            delete event.request.headers['authorization'];
            delete event.request.headers['cookie'];
        }
        if (event.request?.data) {
            const data = event.request.data;
            if (typeof data === 'object') {
                delete data.password;
                delete data.token;
            }
        }
        
        return event;
    },
    
    // Add custom tags
    beforeSendTransaction(event) {
        event.tags = event.tags || {};
        event.tags.service = 'api';
        return event;
    }
});

// Express integration
import express from 'express';
const app = express();

// Request handler - must be first
app.use(Sentry.Handlers.requestHandler());

// Tracing handler - must be before routes
app.use(Sentry.Handlers.tracingHandler());

// Your routes here
app.get('/', (req, res) => {
    res.send('Hello');
});

// Error handler - must be after routes
app.use(Sentry.Handlers.errorHandler({
    shouldHandleError(error) {
        // Only report server errors
        return error.status >= 500;
    }
}));

// Custom error wrapper
function captureError(error: Error, context?: Record<string, any>) {
    Sentry.withScope(scope => {
        if (context) {
            Object.entries(context).forEach(([key, value]) => {
                scope.setTag(key, String(value));
            });
        }
        Sentry.captureException(error);
    });
}

// User context
function setUserContext(user: { id: string; email: string; name?: string }) {
    Sentry.setUser({
        id: user.id,
        email: user.email,
        username: user.name
    });
}

// Breadcrumbs
function addBreadcrumb(message: string, category: string, data?: Record<string, any>) {
    Sentry.addBreadcrumb({
        message,
        category,
        level: 'info',
        data,
        timestamp: Date.now() / 1000
    });
}

// Transaction for custom spans
async function withTransaction<T>(name: string, fn: () => Promise<T>): Promise<T> {
    return Sentry.startSpan({ name, op: 'function' }, async (span) => {
        try {
            return await fn();
        } catch (error) {
            span.setStatus({ code: 2, message: (error as Error).message });
            throw error;
        }
    });
}

// Cron job monitoring
async function monitorCronJob(name: string, fn: () => Promise<void>) {
    const checkInId = Sentry.captureCheckIn({
        monitorSlug: name,
        status: 'in_progress'
    });

    try {
        await fn();
        Sentry.captureCheckIn({
            checkInId,
            monitorSlug: name,
            status: 'ok'
        });
    } catch (error) {
        Sentry.captureCheckIn({
            checkInId,
            monitorSlug: name,
            status: 'error'
        });
        throw error;
    }
}

// React Error Boundary
const SentryErrorBoundary = Sentry.ErrorBoundary;

// React component
function App() {
    return (
        <SentryErrorBoundary fallback={<ErrorFallback />} showDialog>
            <YourApp />
        </SentryErrorBoundary>
    );
}

export { 
    captureError, 
    setUserContext, 
    addBreadcrumb, 
    withTransaction, 
    monitorCronJob,
    SentryErrorBoundary 
};
`;
    }
}

export const errorTracking = ErrorTracking.getInstance();
