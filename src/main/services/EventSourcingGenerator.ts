/**
 * üìù Event Sourcing Generator
 * 
 * Generate event sourcing patterns:
 * - CQRS, Event Store
 */

import { EventEmitter } from 'events';

export class EventSourcingGenerator extends EventEmitter {
    private static instance: EventSourcingGenerator;

    private constructor() { super(); }

    static getInstance(): EventSourcingGenerator {
        if (!EventSourcingGenerator.instance) {
            EventSourcingGenerator.instance = new EventSourcingGenerator();
        }
        return EventSourcingGenerator.instance;
    }

    generate(): string {
        return `// Event Sourcing & CQRS
// Generated by Shadow AI

// === Event Store ===
interface DomainEvent {
    id: string;
    aggregateId: string;
    aggregateType: string;
    type: string;
    version: number;
    payload: any;
    metadata: {
        timestamp: Date;
        userId?: string;
        correlationId?: string;
    };
}

class EventStore {
    constructor(private db: PrismaClient) {}

    async append(event: Omit<DomainEvent, 'id'>): Promise<DomainEvent> {
        // Optimistic concurrency check
        const lastEvent = await this.db.event.findFirst({
            where: { aggregateId: event.aggregateId },
            orderBy: { version: 'desc' }
        });

        if (lastEvent && lastEvent.version >= event.version) {
            throw new Error('Concurrency conflict: Event version already exists');
        }

        const saved = await this.db.event.create({
            data: {
                id: crypto.randomUUID(),
                ...event,
                metadata: event.metadata as any
            }
        });

        // Publish to event bus
        await eventBus.publish(saved);

        return saved as DomainEvent;
    }

    async getEvents(aggregateId: string, fromVersion = 0): Promise<DomainEvent[]> {
        return this.db.event.findMany({
            where: {
                aggregateId,
                version: { gte: fromVersion }
            },
            orderBy: { version: 'asc' }
        });
    }

    async getEventsByType(type: string, after?: Date): Promise<DomainEvent[]> {
        return this.db.event.findMany({
            where: {
                type,
                ...(after && { 'metadata.timestamp': { gte: after } })
            },
            orderBy: { 'metadata.timestamp': 'asc' }
        });
    }
}

// === Aggregate Root ===
abstract class AggregateRoot {
    protected version = 0;
    private uncommittedEvents: DomainEvent[] = [];

    abstract get id(): string;

    protected apply(event: DomainEvent) {
        this.when(event);
        this.version = event.version;
    }

    protected abstract when(event: DomainEvent): void;

    protected raise(type: string, payload: any) {
        const event: DomainEvent = {
            id: crypto.randomUUID(),
            aggregateId: this.id,
            aggregateType: this.constructor.name,
            type,
            version: this.version + 1,
            payload,
            metadata: { timestamp: new Date() }
        };

        this.apply(event);
        this.uncommittedEvents.push(event);
    }

    getUncommittedEvents(): DomainEvent[] {
        return [...this.uncommittedEvents];
    }

    clearUncommittedEvents() {
        this.uncommittedEvents = [];
    }

    loadFromHistory(events: DomainEvent[]) {
        events.forEach(event => this.apply(event));
    }
}

// === Example: Order Aggregate ===
class Order extends AggregateRoot {
    private _id: string;
    private status: 'created' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
    private items: { productId: string; quantity: number; price: number }[] = [];
    private customerId: string;

    get id() { return this._id; }

    static create(id: string, customerId: string): Order {
        const order = new Order();
        order.raise('OrderCreated', { id, customerId });
        return order;
    }

    addItem(productId: string, quantity: number, price: number) {
        if (this.status !== 'created') throw new Error('Cannot modify confirmed order');
        this.raise('ItemAdded', { productId, quantity, price });
    }

    confirm() {
        if (this.status !== 'created') throw new Error('Order already processed');
        if (this.items.length === 0) throw new Error('Cannot confirm empty order');
        this.raise('OrderConfirmed', { total: this.calculateTotal() });
    }

    cancel(reason: string) {
        if (this.status === 'delivered') throw new Error('Cannot cancel delivered order');
        this.raise('OrderCancelled', { reason });
    }

    protected when(event: DomainEvent) {
        switch (event.type) {
            case 'OrderCreated':
                this._id = event.payload.id;
                this.customerId = event.payload.customerId;
                this.status = 'created';
                break;
            case 'ItemAdded':
                this.items.push(event.payload);
                break;
            case 'OrderConfirmed':
                this.status = 'confirmed';
                break;
            case 'OrderCancelled':
                this.status = 'cancelled';
                break;
        }
    }

    private calculateTotal() {
        return this.items.reduce((sum, item) => sum + item.quantity * item.price, 0);
    }
}

// === Repository ===
class OrderRepository {
    constructor(private eventStore: EventStore) {}

    async save(order: Order) {
        const events = order.getUncommittedEvents();
        for (const event of events) {
            await this.eventStore.append(event);
        }
        order.clearUncommittedEvents();
    }

    async getById(id: string): Promise<Order | null> {
        const events = await this.eventStore.getEvents(id);
        if (events.length === 0) return null;

        const order = new Order();
        order.loadFromHistory(events);
        return order;
    }
}

// === CQRS: Read Model (Projection) ===
class OrderProjection {
    constructor(private db: PrismaClient) {}

    async handle(event: DomainEvent) {
        switch (event.type) {
            case 'OrderCreated':
                await this.db.orderReadModel.create({
                    data: {
                        id: event.aggregateId,
                        customerId: event.payload.customerId,
                        status: 'created',
                        total: 0,
                        itemCount: 0,
                        createdAt: event.metadata.timestamp
                    }
                });
                break;

            case 'ItemAdded':
                await this.db.orderReadModel.update({
                    where: { id: event.aggregateId },
                    data: {
                        itemCount: { increment: 1 },
                        total: { increment: event.payload.quantity * event.payload.price }
                    }
                });
                break;

            case 'OrderConfirmed':
                await this.db.orderReadModel.update({
                    where: { id: event.aggregateId },
                    data: { status: 'confirmed', confirmedAt: event.metadata.timestamp }
                });
                break;
        }
    }
}

// === Command Handler ===
class CreateOrderHandler {
    constructor(
        private orderRepo: OrderRepository,
        private eventBus: EventBus
    ) {}

    async handle(command: { customerId: string; items: any[] }) {
        const order = Order.create(crypto.randomUUID(), command.customerId);
        
        for (const item of command.items) {
            order.addItem(item.productId, item.quantity, item.price);
        }

        await this.orderRepo.save(order);

        return order.id;
    }
}

// === Query Handler ===
class GetOrdersHandler {
    constructor(private db: PrismaClient) {}

    async handle(query: { customerId?: string; status?: string }) {
        return this.db.orderReadModel.findMany({
            where: {
                ...(query.customerId && { customerId: query.customerId }),
                ...(query.status && { status: query.status })
            },
            orderBy: { createdAt: 'desc' }
        });
    }
}

export { EventStore, AggregateRoot, Order, OrderRepository, OrderProjection };
`;
    }
}

export const eventSourcingGenerator = EventSourcingGenerator.getInstance();
