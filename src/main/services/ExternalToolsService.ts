/**
 * ðŸ”Œ ExternalToolsService
 * 
 * External tool integration:
 * - MCP, APIs, webhooks
 */

import { EventEmitter } from 'events';

export class ExternalToolsService extends EventEmitter {
    private static instance: ExternalToolsService;
    private constructor() { super(); }
    static getInstance(): ExternalToolsService {
        if (!ExternalToolsService.instance) {
            ExternalToolsService.instance = new ExternalToolsService();
        }
        return ExternalToolsService.instance;
    }

    generate(): string {
        return `// External Tools Service - MCP, APIs, webhooks
// Generated by Shadow AI

class ExternalTools {
    private tools: Map<string, ExternalTool> = new Map();
    
    // Register external tool
    register(tool: ExternalTool): void {
        this.tools.set(tool.name, tool);
    }
    
    // Call external API
    async callAPI(toolName: string, params: any): Promise<any> {
        const tool = this.tools.get(toolName);
        if (!tool) throw new Error(\`Tool not found: \${toolName}\`);
        
        const url = this.buildUrl(tool.endpoint, params);
        
        const response = await fetch(url, {
            method: tool.method || 'GET',
            headers: {
                'Content-Type': 'application/json',
                ...(tool.auth && { 'Authorization': \`Bearer \${tool.auth.token}\` })
            },
            body: tool.method !== 'GET' ? JSON.stringify(params) : undefined
        });
        
        if (!response.ok) {
            throw new Error(\`API error: \${response.status} \${response.statusText}\`);
        }
        
        return response.json();
    }
    
    // MCP protocol support
    async callMCP(server: string, method: string, params: any): Promise<any> {
        const mcpRequest = {
            jsonrpc: '2.0',
            id: crypto.randomUUID(),
            method,
            params
        };
        
        const response = await fetch(server, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(mcpRequest)
        });
        
        const result = await response.json();
        
        if (result.error) {
            throw new Error(result.error.message);
        }
        
        return result.result;
    }
    
    // Webhook trigger
    async triggerWebhook(url: string, payload: any): Promise<void> {
        await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    }
    
    // Get tools as OpenAI function definitions
    getToolDefinitions(): any[] {
        return Array.from(this.tools.values()).map(tool => ({
            type: 'function',
            function: {
                name: tool.name,
                description: tool.description,
                parameters: tool.parameters
            }
        }));
    }
    
    // Execute tool call
    async execute(name: string, params: any): Promise<any> {
        const tool = this.tools.get(name);
        if (!tool) throw new Error(\`Tool not found: \${name}\`);
        
        if (tool.type === 'api') {
            return this.callAPI(name, params);
        }
        
        if (tool.type === 'mcp') {
            return this.callMCP(tool.endpoint, tool.method || name, params);
        }
        
        if (tool.handler) {
            return tool.handler(params);
        }
        
        throw new Error(\`Cannot execute tool: \${name}\`);
    }
    
    // List registered tools
    list(): string[] {
        return Array.from(this.tools.keys());
    }
    
    private buildUrl(template: string, params: Record<string, any>): string {
        let url = template;
        
        for (const [key, value] of Object.entries(params)) {
            url = url.replace(\`:\${key}\`, encodeURIComponent(String(value)));
        }
        
        return url;
    }
}

export { ExternalTools };
`;
    }
}

export const externalToolsService = ExternalToolsService.getInstance();
