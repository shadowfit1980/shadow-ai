/**
 * ðŸš© Feature Flags Generator
 * 
 * Generate feature flag systems:
 * - LaunchDarkly, custom flags
 */

import { EventEmitter } from 'events';

export class FeatureFlagGenerator extends EventEmitter {
    private static instance: FeatureFlagGenerator;

    private constructor() { super(); }

    static getInstance(): FeatureFlagGenerator {
        if (!FeatureFlagGenerator.instance) {
            FeatureFlagGenerator.instance = new FeatureFlagGenerator();
        }
        return FeatureFlagGenerator.instance;
    }

    generate(): string {
        return `// Feature Flags
// Generated by Shadow AI

// === Custom Implementation ===
interface Flag {
    key: string;
    enabled: boolean;
    rolloutPercentage?: number;
    allowedUsers?: string[];
    allowedGroups?: string[];
    variants?: Record<string, any>;
}

class FeatureFlagService {
    private flags: Map<string, Flag> = new Map();
    private userId?: string;
    private userGroups: string[] = [];

    setUser(userId: string, groups: string[] = []) {
        this.userId = userId;
        this.userGroups = groups;
    }

    async loadFlags() {
        const response = await fetch('/api/feature-flags');
        const flags: Flag[] = await response.json();
        flags.forEach(flag => this.flags.set(flag.key, flag));
    }

    isEnabled(key: string): boolean {
        const flag = this.flags.get(key);
        if (!flag) return false;
        if (!flag.enabled) return false;

        // Check user allowlist
        if (flag.allowedUsers?.length && this.userId) {
            if (flag.allowedUsers.includes(this.userId)) return true;
        }

        // Check group allowlist
        if (flag.allowedGroups?.length) {
            if (flag.allowedGroups.some(g => this.userGroups.includes(g))) return true;
        }

        // Rollout percentage
        if (flag.rolloutPercentage !== undefined && this.userId) {
            const hash = this.hashUser(this.userId + key);
            return hash < flag.rolloutPercentage;
        }

        return flag.enabled;
    }

    getVariant<T>(key: string, defaultValue: T): T {
        const flag = this.flags.get(key);
        if (!flag?.variants || !this.isEnabled(key)) return defaultValue;
        return flag.variants.default || defaultValue;
    }

    private hashUser(str: string): number {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(hash % 100);
    }
}

const featureFlags = new FeatureFlagService();

// React Hook
function useFeatureFlag(key: string): boolean {
    const [enabled, setEnabled] = useState(false);
    
    useEffect(() => {
        setEnabled(featureFlags.isEnabled(key));
    }, [key]);
    
    return enabled;
}

// React Component
function Feature({ flag, children, fallback = null }) {
    const enabled = useFeatureFlag(flag);
    return enabled ? children : fallback;
}

// Usage
function App() {
    return (
        <div>
            <Feature flag="new-dashboard">
                <NewDashboard />
            </Feature>
            
            <Feature flag="beta-features" fallback={<OldFeatures />}>
                <BetaFeatures />
            </Feature>
        </div>
    );
}

// === LaunchDarkly Integration ===
import { LDClient, LDFlagSet } from 'launchdarkly-js-client-sdk';

let ldClient: LDClient;

async function initLaunchDarkly(userId: string, userAttributes?: Record<string, any>) {
    const context = {
        kind: 'user',
        key: userId,
        ...userAttributes
    };
    
    ldClient = LDClient.initialize(process.env.LAUNCHDARKLY_CLIENT_ID!, context);
    await ldClient.waitForInitialization();
}

function getLDFlag(key: string, defaultValue: boolean): boolean {
    return ldClient?.variation(key, defaultValue) ?? defaultValue;
}

// React provider
import { LDProvider, useFlags, useLDClient } from 'launchdarkly-react-client-sdk';

function App() {
    return (
        <LDProvider clientSideID={process.env.NEXT_PUBLIC_LD_CLIENT_ID!} context={{ kind: 'user', key: 'anonymous' }}>
            <MyApp />
        </LDProvider>
    );
}

function MyComponent() {
    const { newFeature, experimentVariant } = useFlags();
    const ldClient = useLDClient();
    
    // Track event
    ldClient?.track('button-click', { value: 1 });
    
    return newFeature ? <NewFeature /> : <OldFeature />;
}

export { featureFlags, useFeatureFlag, Feature, initLaunchDarkly, getLDFlag };
`;
    }
}

export const featureFlagGenerator = FeatureFlagGenerator.getInstance();
