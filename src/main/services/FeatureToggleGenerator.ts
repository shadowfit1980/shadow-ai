/**
 * ðŸ”§ FeatureToggleGenerator
 * 
 * Feature toggles:
 * - Flags, rollouts, A/B testing
 */

import { EventEmitter } from 'events';

export class FeatureToggleGenerator extends EventEmitter {
    private static instance: FeatureToggleGenerator;
    private constructor() { super(); }
    static getInstance(): FeatureToggleGenerator {
        if (!FeatureToggleGenerator.instance) {
            FeatureToggleGenerator.instance = new FeatureToggleGenerator();
        }
        return FeatureToggleGenerator.instance;
    }

    generate(): string {
        return `// Feature Toggle Generator - Flags, rollouts, A/B testing
// Generated by Shadow AI

// Feature Flag Schema
model FeatureFlag {
    id          String   @id @default(cuid())
    key         String   @unique
    name        String
    description String?
    enabled     Boolean  @default(false)
    rolloutPercentage Int @default(100)
    rules       Json?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
}

// Feature Flag Service
class FeatureFlagService {
    private cache: Map<string, FeatureFlag> = new Map();
    
    async isEnabled(key: string, context?: { userId?: string; email?: string; attributes?: Record<string, any> }): Promise<boolean> {
        const flag = await this.getFlag(key);
        if (!flag) return false;
        if (!flag.enabled) return false;
        
        // Check rules
        if (flag.rules) {
            if (!await this.evaluateRules(flag.rules, context)) return false;
        }
        
        // Check rollout percentage
        if (flag.rolloutPercentage < 100 && context?.userId) {
            const hash = this.hashUserId(context.userId, key);
            if (hash > flag.rolloutPercentage) return false;
        }
        
        return true;
    }
    
    private async evaluateRules(rules: any, context?: any): Promise<boolean> {
        if (!rules || !context) return true;
        
        for (const rule of rules) {
            const value = context.attributes?.[rule.attribute] || context[rule.attribute];
            
            switch (rule.operator) {
                case 'equals': if (value !== rule.value) return false; break;
                case 'contains': if (!value?.includes(rule.value)) return false; break;
                case 'in': if (!rule.value.includes(value)) return false; break;
                case 'startsWith': if (!value?.startsWith(rule.value)) return false; break;
            }
        }
        
        return true;
    }
    
    private hashUserId(userId: string, flagKey: string): number {
        const str = userId + flagKey;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(hash) % 100;
    }
    
    async getFlag(key: string): Promise<FeatureFlag | null> {
        if (this.cache.has(key)) return this.cache.get(key)!;
        
        const flag = await prisma.featureFlag.findUnique({ where: { key } });
        if (flag) this.cache.set(key, flag);
        return flag;
    }
    
    async setFlag(key: string, enabled: boolean) {
        const flag = await prisma.featureFlag.update({
            where: { key },
            data: { enabled }
        });
        this.cache.set(key, flag);
        return flag;
    }
    
    async setRollout(key: string, percentage: number) {
        const flag = await prisma.featureFlag.update({
            where: { key },
            data: { rolloutPercentage: percentage }
        });
        this.cache.set(key, flag);
        return flag;
    }
}

// React Hook
export function useFeatureFlag(key: string): boolean {
    const [enabled, setEnabled] = useState(false);
    const { user } = useUser();
    
    useEffect(() => {
        checkFeatureFlag(key, { userId: user?.id }).then(setEnabled);
    }, [key, user?.id]);
    
    return enabled;
}

// Feature Gate Component
export function FeatureGate({ flag, children, fallback }: { flag: string; children: React.ReactNode; fallback?: React.ReactNode }) {
    const enabled = useFeatureFlag(flag);
    return enabled ? <>{children}</> : <>{fallback}</>;
}

export { FeatureFlagService, useFeatureFlag, FeatureGate };
`;
    }
}

export const featureToggleGenerator = FeatureToggleGenerator.getInstance();
