/**
 * üìÅ FileSystemService
 * 
 * File system operations:
 * - Read, write, watch, search
 */

import { EventEmitter } from 'events';

export class FileSystemService extends EventEmitter {
    private static instance: FileSystemService;
    private constructor() { super(); }
    static getInstance(): FileSystemService {
        if (!FileSystemService.instance) {
            FileSystemService.instance = new FileSystemService();
        }
        return FileSystemService.instance;
    }

    generate(): string {
        return `// File System Service - Read, write, watch, search
// Generated by Shadow AI

import * as fs from 'fs/promises';
import * as path from 'path';
import chokidar from 'chokidar';
import { glob } from 'glob';

class FileSystem {
    // Read file
    async readFile(filePath: string): Promise<string> {
        return fs.readFile(filePath, 'utf-8');
    }
    
    // Write file
    async writeFile(filePath: string, content: string): Promise<void> {
        await fs.mkdir(path.dirname(filePath), { recursive: true });
        await fs.writeFile(filePath, content);
    }
    
    // Append to file
    async appendFile(filePath: string, content: string): Promise<void> {
        await fs.appendFile(filePath, content);
    }
    
    // Delete file
    async deleteFile(filePath: string): Promise<void> {
        await fs.unlink(filePath);
    }
    
    // Check if exists
    async exists(filePath: string): Promise<boolean> {
        try {
            await fs.access(filePath);
            return true;
        } catch {
            return false;
        }
    }
    
    // List directory
    async listDir(dirPath: string, recursive = false): Promise<FileInfo[]> {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const files: FileInfo[] = [];
        
        for (const entry of entries) {
            const fullPath = path.join(dirPath, entry.name);
            const stat = await fs.stat(fullPath);
            
            files.push({
                name: entry.name,
                path: fullPath,
                isDirectory: entry.isDirectory(),
                size: stat.size,
                modified: stat.mtime
            });
            
            if (recursive && entry.isDirectory()) {
                files.push(...await this.listDir(fullPath, true));
            }
        }
        
        return files;
    }
    
    // Search files
    async search(directory: string, pattern: string): Promise<string[]> {
        return glob(pattern, { cwd: directory, absolute: true });
    }
    
    // Watch directory
    watch(directory: string, callback: (event: string, path: string) => void): () => void {
        const watcher = chokidar.watch(directory, {
            persistent: true,
            ignoreInitial: true
        });
        
        watcher
            .on('add', (path) => callback('add', path))
            .on('change', (path) => callback('change', path))
            .on('unlink', (path) => callback('delete', path));
        
        return () => watcher.close();
    }
    
    // Copy file
    async copy(src: string, dest: string): Promise<void> {
        await fs.copyFile(src, dest);
    }
    
    // Move file
    async move(src: string, dest: string): Promise<void> {
        await fs.rename(src, dest);
    }
    
    // Create directory
    async mkdir(dirPath: string): Promise<void> {
        await fs.mkdir(dirPath, { recursive: true });
    }
    
    // Get file stats
    async stats(filePath: string): Promise<fs.Stats> {
        return fs.stat(filePath);
    }
    
    // Read JSON
    async readJson<T>(filePath: string): Promise<T> {
        const content = await this.readFile(filePath);
        return JSON.parse(content);
    }
    
    // Write JSON
    async writeJson(filePath: string, data: any, pretty = true): Promise<void> {
        const content = pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
        await this.writeFile(filePath, content);
    }
    
    // Find and replace in files
    async findAndReplace(directory: string, pattern: string, find: string | RegExp, replace: string): Promise<number> {
        const files = await this.search(directory, pattern);
        let count = 0;
        
        for (const file of files) {
            const content = await this.readFile(file);
            const newContent = content.replace(find, replace);
            
            if (content !== newContent) {
                await this.writeFile(file, newContent);
                count++;
            }
        }
        
        return count;
    }
    
    // Get project structure
    async getProjectStructure(directory: string, maxDepth = 4): Promise<TreeNode> {
        const name = path.basename(directory);
        const files = await this.listDir(directory);
        
        const node: TreeNode = { name, path: directory, children: [] };
        
        for (const file of files) {
            if (file.isDirectory && maxDepth > 0) {
                node.children!.push(await this.getProjectStructure(file.path, maxDepth - 1));
            } else {
                node.children!.push({ name: file.name, path: file.path });
            }
        }
        
        return node;
    }
}

export { FileSystem };
`;
    }
}

export const fileSystemService = FileSystemService.getInstance();
