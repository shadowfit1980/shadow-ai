/**
 * üìÅ File Upload Generator
 * 
 * Generate file upload systems:
 * - S3, Cloudinary, local
 */

import { EventEmitter } from 'events';

export class FileUploadGenerator extends EventEmitter {
    private static instance: FileUploadGenerator;

    private constructor() { super(); }

    static getInstance(): FileUploadGenerator {
        if (!FileUploadGenerator.instance) {
            FileUploadGenerator.instance = new FileUploadGenerator();
        }
        return FileUploadGenerator.instance;
    }

    generateS3Upload(): string {
        return `// S3 File Upload
// Generated by Shadow AI

import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { Upload } from '@aws-sdk/lib-storage';
import crypto from 'crypto';
import path from 'path';

const s3 = new S3Client({ region: process.env.AWS_REGION });
const BUCKET = process.env.S3_BUCKET!;

interface UploadResult {
    key: string;
    url: string;
    size: number;
    contentType: string;
}

// Generate unique key
function generateKey(filename: string, folder = 'uploads'): string {
    const ext = path.extname(filename);
    const hash = crypto.randomBytes(16).toString('hex');
    const date = new Date().toISOString().split('T')[0];
    return \`\${folder}/\${date}/\${hash}\${ext}\`;
}

// Upload file (buffer)
async function uploadFile(
    buffer: Buffer,
    filename: string,
    contentType: string,
    folder = 'uploads'
): Promise<UploadResult> {
    const key = generateKey(filename, folder);

    await s3.send(new PutObjectCommand({
        Bucket: BUCKET,
        Key: key,
        Body: buffer,
        ContentType: contentType,
        ACL: 'private'
    }));

    return {
        key,
        url: \`https://\${BUCKET}.s3.amazonaws.com/\${key}\`,
        size: buffer.length,
        contentType
    };
}

// Upload stream (large files)
async function uploadStream(
    stream: NodeJS.ReadableStream,
    filename: string,
    contentType: string,
    onProgress?: (progress: number) => void
): Promise<UploadResult> {
    const key = generateKey(filename);

    const upload = new Upload({
        client: s3,
        params: {
            Bucket: BUCKET,
            Key: key,
            Body: stream,
            ContentType: contentType
        }
    });

    upload.on('httpUploadProgress', (progress) => {
        if (onProgress && progress.loaded && progress.total) {
            onProgress((progress.loaded / progress.total) * 100);
        }
    });

    await upload.done();

    return { key, url: \`https://\${BUCKET}.s3.amazonaws.com/\${key}\`, size: 0, contentType };
}

// Generate presigned upload URL (direct upload from client)
async function getUploadUrl(filename: string, contentType: string, expiresIn = 3600) {
    const key = generateKey(filename);

    const url = await getSignedUrl(s3, new PutObjectCommand({
        Bucket: BUCKET,
        Key: key,
        ContentType: contentType
    }), { expiresIn });

    return { url, key };
}

// Generate presigned download URL
async function getDownloadUrl(key: string, expiresIn = 3600) {
    return getSignedUrl(s3, new GetObjectCommand({
        Bucket: BUCKET,
        Key: key
    }), { expiresIn });
}

// Delete file
async function deleteFile(key: string) {
    await s3.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }));
}

// Express middleware (with multer)
import multer from 'multer';
import multerS3 from 'multer-s3';

const upload = multer({
    storage: multerS3({
        s3: s3 as any,
        bucket: BUCKET,
        acl: 'private',
        contentType: multerS3.AUTO_CONTENT_TYPE,
        key: (req, file, cb) => {
            cb(null, generateKey(file.originalname));
        }
    }),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
    fileFilter: (req, file, cb) => {
        const allowed = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
        if (allowed.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});

export { uploadFile, uploadStream, getUploadUrl, getDownloadUrl, deleteFile, upload };
`;
    }

    generateCloudinary(): string {
        return `// Cloudinary Upload
// Generated by Shadow AI

import { v2 as cloudinary } from 'cloudinary';
import { Readable } from 'stream';

cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET
});

interface UploadOptions {
    folder?: string;
    transformation?: any[];
    tags?: string[];
    publicId?: string;
}

async function uploadImage(
    source: string | Buffer,
    options: UploadOptions = {}
): Promise<{ url: string; publicId: string; width: number; height: number }> {
    const result = await new Promise<any>((resolve, reject) => {
        const uploadOptions = {
            folder: options.folder || 'uploads',
            transformation: options.transformation,
            tags: options.tags,
            public_id: options.publicId,
            resource_type: 'image' as const
        };

        if (Buffer.isBuffer(source)) {
            const stream = cloudinary.uploader.upload_stream(uploadOptions, (error, result) => {
                if (error) reject(error);
                else resolve(result);
            });
            Readable.from(source).pipe(stream);
        } else {
            cloudinary.uploader.upload(source, uploadOptions, (error, result) => {
                if (error) reject(error);
                else resolve(result);
            });
        }
    });

    return {
        url: result.secure_url,
        publicId: result.public_id,
        width: result.width,
        height: result.height
    };
}

// Generate optimized URL
function getOptimizedUrl(publicId: string, options: { width?: number; height?: number; format?: string } = {}) {
    return cloudinary.url(publicId, {
        fetch_format: 'auto',
        quality: 'auto',
        width: options.width,
        height: options.height,
        crop: 'fill',
        format: options.format
    });
}

// Generate thumbnail
function getThumbnail(publicId: string, size = 150) {
    return cloudinary.url(publicId, {
        width: size,
        height: size,
        crop: 'thumb',
        gravity: 'face',
        fetch_format: 'auto',
        quality: 'auto'
    });
}

// Delete image
async function deleteImage(publicId: string) {
    await cloudinary.uploader.destroy(publicId);
}

// React component for upload
const uploadWidget = \`
import { useCallback } from 'react';

function CloudinaryUpload({ onUpload }) {
    const handleClick = useCallback(() => {
        const widget = window.cloudinary.createUploadWidget({
            cloudName: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
            uploadPreset: 'unsigned_preset',
            sources: ['local', 'url', 'camera'],
            multiple: false,
            maxFiles: 1,
            maxFileSize: 5000000,
            cropping: true
        }, (error, result) => {
            if (result.event === 'success') {
                onUpload(result.info);
            }
        });
        widget.open();
    }, [onUpload]);

    return <button onClick={handleClick}>Upload Image</button>;
}
\`;

export { uploadImage, getOptimizedUrl, getThumbnail, deleteImage };
`;
    }
}

export const fileUploadGenerator = FileUploadGenerator.getInstance();
