/**
 * ðŸ“Š FormAnalyticsGenerator
 * 
 * Form analytics:
 * - Submissions, conversion, abandonment
 */

import { EventEmitter } from 'events';

export class FormAnalyticsGenerator extends EventEmitter {
    private static instance: FormAnalyticsGenerator;
    private constructor() { super(); }
    static getInstance(): FormAnalyticsGenerator {
        if (!FormAnalyticsGenerator.instance) {
            FormAnalyticsGenerator.instance = new FormAnalyticsGenerator();
        }
        return FormAnalyticsGenerator.instance;
    }

    generate(): string {
        return `// Form Analytics Generator - Submissions, conversion
// Generated by Shadow AI

// Form Analytics Schema
model FormSession {
    id           String   @id @default(cuid())
    formId       String
    sessionId    String
    startedAt    DateTime @default(now())
    completedAt  DateTime?
    abandoned    Boolean  @default(false)
    abandonedAt  DateTime?
    lastFieldId  String?
    fieldTimes   Json     // { fieldId: timeSpentMs }
    deviceInfo   Json?
}

// Form Analytics Service
class FormAnalyticsService {
    async startSession(formId: string, sessionId: string) {
        return prisma.formSession.create({
            data: { formId, sessionId }
        });
    }
    
    async trackFieldInteraction(sessionId: string, fieldId: string, timeSpent: number) {
        const session = await prisma.formSession.findUnique({ where: { id: sessionId } });
        const fieldTimes = session?.fieldTimes as Record<string, number> || {};
        fieldTimes[fieldId] = (fieldTimes[fieldId] || 0) + timeSpent;
        
        return prisma.formSession.update({
            where: { id: sessionId },
            data: { fieldTimes, lastFieldId: fieldId }
        });
    }
    
    async completeSession(sessionId: string) {
        return prisma.formSession.update({
            where: { id: sessionId },
            data: { completedAt: new Date() }
        });
    }
    
    async markAbandoned(sessionId: string) {
        return prisma.formSession.update({
            where: { id: sessionId },
            data: { abandoned: true, abandonedAt: new Date() }
        });
    }
    
    async getFormStats(formId: string, dateRange: { from: Date; to: Date }) {
        const sessions = await prisma.formSession.findMany({
            where: {
                formId,
                startedAt: { gte: dateRange.from, lte: dateRange.to }
            }
        });
        
        const total = sessions.length;
        const completed = sessions.filter(s => s.completedAt).length;
        const abandoned = sessions.filter(s => s.abandoned).length;
        
        return {
            total,
            completed,
            abandoned,
            conversionRate: total > 0 ? (completed / total) * 100 : 0,
            abandonmentRate: total > 0 ? (abandoned / total) * 100 : 0
        };
    }
    
    async getAbandonmentByField(formId: string) {
        const abandonedSessions = await prisma.formSession.findMany({
            where: { formId, abandoned: true }
        });
        
        const fieldCounts: Record<string, number> = {};
        for (const session of abandonedSessions) {
            if (session.lastFieldId) {
                fieldCounts[session.lastFieldId] = (fieldCounts[session.lastFieldId] || 0) + 1;
            }
        }
        
        return Object.entries(fieldCounts)
            .map(([fieldId, count]) => ({ fieldId, count }))
            .sort((a, b) => b.count - a.count);
    }
    
    async getAverageFieldTime(formId: string) {
        const sessions = await prisma.formSession.findMany({
            where: { formId, completedAt: { not: null } }
        });
        
        const fieldTotals: Record<string, { total: number; count: number }> = {};
        
        for (const session of sessions) {
            const times = session.fieldTimes as Record<string, number>;
            for (const [fieldId, time] of Object.entries(times)) {
                if (!fieldTotals[fieldId]) fieldTotals[fieldId] = { total: 0, count: 0 };
                fieldTotals[fieldId].total += time;
                fieldTotals[fieldId].count += 1;
            }
        }
        
        return Object.entries(fieldTotals).map(([fieldId, { total, count }]) => ({
            fieldId,
            averageTime: total / count
        }));
    }
}

// React Hook for Form Analytics
export function useFormAnalytics(formId: string) {
    const sessionRef = useRef<string | null>(null);
    const fieldStartRef = useRef<{ fieldId: string; startTime: number } | null>(null);
    
    useEffect(() => {
        // Start session
        startFormSession(formId).then(session => {
            sessionRef.current = session.id;
        });
        
        // Track abandonment on page leave
        return () => {
            if (sessionRef.current) {
                markFormAbandoned(sessionRef.current);
            }
        };
    }, [formId]);
    
    const trackFieldFocus = (fieldId: string) => {
        fieldStartRef.current = { fieldId, startTime: Date.now() };
    };
    
    const trackFieldBlur = (fieldId: string) => {
        if (fieldStartRef.current?.fieldId === fieldId && sessionRef.current) {
            const timeSpent = Date.now() - fieldStartRef.current.startTime;
            trackFieldInteraction(sessionRef.current, fieldId, timeSpent);
        }
    };
    
    const trackSubmit = () => {
        if (sessionRef.current) {
            completeFormSession(sessionRef.current);
            sessionRef.current = null;
        }
    };
    
    return { trackFieldFocus, trackFieldBlur, trackSubmit };
}

export { FormAnalyticsService, useFormAnalytics };
`;
    }
}

export const formAnalyticsGenerator = FormAnalyticsGenerator.getInstance();
