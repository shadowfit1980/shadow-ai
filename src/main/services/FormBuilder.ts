/**
 * ðŸ“ Form Builder Generator
 * 
 * Generate form systems:
 * - React Hook Form, Formik, validation
 */

import { EventEmitter } from 'events';

export class FormBuilder extends EventEmitter {
    private static instance: FormBuilder;

    private constructor() { super(); }

    static getInstance(): FormBuilder {
        if (!FormBuilder.instance) {
            FormBuilder.instance = new FormBuilder();
        }
        return FormBuilder.instance;
    }

    generateReactHookForm(): string {
        return `// React Hook Form
// Generated by Shadow AI

import { useForm, useFieldArray, Controller, FormProvider, useFormContext } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Schema
const userSchema = z.object({
    name: z.string().min(2, 'Name must be at least 2 characters'),
    email: z.string().email('Invalid email address'),
    password: z.string().min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Must contain uppercase')
        .regex(/[0-9]/, 'Must contain number'),
    confirmPassword: z.string(),
    age: z.number().min(18, 'Must be 18 or older'),
    role: z.enum(['user', 'admin', 'moderator']),
    skills: z.array(z.object({
        name: z.string(),
        level: z.number().min(1).max(5)
    })).min(1, 'Add at least one skill'),
    acceptTerms: z.boolean().refine(val => val === true, 'Must accept terms'),
}).refine(data => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword']
});

type UserFormData = z.infer<typeof userSchema>;

// Form Component
function UserForm({ onSubmit }: { onSubmit: (data: UserFormData) => void }) {
    const methods = useForm<UserFormData>({
        resolver: zodResolver(userSchema),
        defaultValues: {
            name: '',
            email: '',
            password: '',
            confirmPassword: '',
            age: 18,
            role: 'user',
            skills: [{ name: '', level: 1 }],
            acceptTerms: false
        },
        mode: 'onChange'
    });

    const { register, handleSubmit, control, formState: { errors, isSubmitting, isValid } } = methods;
    const { fields, append, remove } = useFieldArray({ control, name: 'skills' });

    return (
        <FormProvider {...methods}>
            <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                {/* Text Input */}
                <div>
                    <label htmlFor="name">Name</label>
                    <input id="name" {...register('name')} className="input" />
                    {errors.name && <span className="error">{errors.name.message}</span>}
                </div>

                {/* Email */}
                <div>
                    <label htmlFor="email">Email</label>
                    <input id="email" type="email" {...register('email')} className="input" />
                    {errors.email && <span className="error">{errors.email.message}</span>}
                </div>

                {/* Password */}
                <div>
                    <label htmlFor="password">Password</label>
                    <input id="password" type="password" {...register('password')} className="input" />
                    {errors.password && <span className="error">{errors.password.message}</span>}
                </div>

                {/* Number with Controller */}
                <Controller
                    name="age"
                    control={control}
                    render={({ field }) => (
                        <div>
                            <label>Age</label>
                            <input type="number" {...field} onChange={e => field.onChange(+e.target.value)} />
                            {errors.age && <span className="error">{errors.age.message}</span>}
                        </div>
                    )}
                />

                {/* Select */}
                <div>
                    <label htmlFor="role">Role</label>
                    <select id="role" {...register('role')}>
                        <option value="user">User</option>
                        <option value="admin">Admin</option>
                        <option value="moderator">Moderator</option>
                    </select>
                </div>

                {/* Dynamic Fields */}
                <div>
                    <label>Skills</label>
                    {fields.map((field, index) => (
                        <div key={field.id} className="flex gap-2">
                            <input {...register(\`skills.\${index}.name\`)} placeholder="Skill name" />
                            <input type="number" {...register(\`skills.\${index}.level\`, { valueAsNumber: true })} min={1} max={5} />
                            <button type="button" onClick={() => remove(index)}>Remove</button>
                        </div>
                    ))}
                    <button type="button" onClick={() => append({ name: '', level: 1 })}>Add Skill</button>
                </div>

                {/* Checkbox */}
                <div>
                    <label>
                        <input type="checkbox" {...register('acceptTerms')} />
                        Accept terms and conditions
                    </label>
                    {errors.acceptTerms && <span className="error">{errors.acceptTerms.message}</span>}
                </div>

                <button type="submit" disabled={isSubmitting || !isValid}>
                    {isSubmitting ? 'Submitting...' : 'Submit'}
                </button>
            </form>
        </FormProvider>
    );
}

// Reusable Input Component
function FormInput({ name, label, type = 'text', ...props }) {
    const { register, formState: { errors } } = useFormContext();
    const error = errors[name];

    return (
        <div className="form-group">
            <label htmlFor={name}>{label}</label>
            <input id={name} type={type} {...register(name)} {...props} />
            {error && <span className="error">{error.message}</span>}
        </div>
    );
}

export { userSchema, UserForm, FormInput };
`;
    }

    generateFormik(): string {
        return `// Formik Form
// Generated by Shadow AI

import { Formik, Form, Field, FieldArray, ErrorMessage, useField, useFormikContext } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object({
    name: Yup.string().min(2).required('Required'),
    email: Yup.string().email('Invalid email').required('Required'),
    password: Yup.string().min(8).required('Required'),
    confirmPassword: Yup.string()
        .oneOf([Yup.ref('password')], 'Passwords must match')
        .required('Required'),
    skills: Yup.array().of(
        Yup.object({ name: Yup.string().required(), level: Yup.number().min(1).max(5) })
    ).min(1)
});

function FormikForm() {
    return (
        <Formik
            initialValues={{ name: '', email: '', password: '', confirmPassword: '', skills: [{ name: '', level: 1 }] }}
            validationSchema={validationSchema}
            onSubmit={async (values, { setSubmitting, resetForm }) => {
                await submitToAPI(values);
                setSubmitting(false);
                resetForm();
            }}
        >
            {({ values, isSubmitting, isValid, dirty }) => (
                <Form>
                    <Field name="name" placeholder="Name" />
                    <ErrorMessage name="name" component="span" className="error" />

                    <Field name="email" type="email" placeholder="Email" />
                    <ErrorMessage name="email" component="span" className="error" />

                    <FieldArray name="skills">
                        {({ push, remove }) => (
                            <div>
                                {values.skills.map((_, index) => (
                                    <div key={index}>
                                        <Field name={\`skills.\${index}.name\`} placeholder="Skill" />
                                        <Field name={\`skills.\${index}.level\`} type="number" />
                                        <button type="button" onClick={() => remove(index)}>X</button>
                                    </div>
                                ))}
                                <button type="button" onClick={() => push({ name: '', level: 1 })}>Add</button>
                            </div>
                        )}
                    </FieldArray>

                    <button type="submit" disabled={isSubmitting || !isValid || !dirty}>
                        Submit
                    </button>
                </Form>
            )}
        </Formik>
    );
}

export { FormikForm };
`;
    }
}

export const formBuilder = FormBuilder.getInstance();
