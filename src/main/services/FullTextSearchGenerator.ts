/**
 * ðŸ” FullTextSearchGenerator
 * 
 * Full-text search:
 * - Elasticsearch, PostgreSQL, indexing
 */

import { EventEmitter } from 'events';

export class FullTextSearchGenerator extends EventEmitter {
    private static instance: FullTextSearchGenerator;
    private constructor() { super(); }
    static getInstance(): FullTextSearchGenerator {
        if (!FullTextSearchGenerator.instance) {
            FullTextSearchGenerator.instance = new FullTextSearchGenerator();
        }
        return FullTextSearchGenerator.instance;
    }

    generate(): string {
        return `// Full Text Search Generator - Elasticsearch, PostgreSQL
// Generated by Shadow AI

import { Client } from '@elastic/elasticsearch';

class ElasticsearchService {
    private client: Client;
    
    constructor() {
        this.client = new Client({ node: process.env.ELASTICSEARCH_URL });
    }
    
    async createIndex(indexName: string, mappings: any) {
        await this.client.indices.create({
            index: indexName,
            mappings
        });
    }
    
    async index(indexName: string, id: string, document: any) {
        await this.client.index({
            index: indexName,
            id,
            document
        });
    }
    
    async search(indexName: string, query: string, options?: { from?: number; size?: number }) {
        const result = await this.client.search({
            index: indexName,
            query: {
                multi_match: {
                    query,
                    fields: ['title^2', 'content', 'tags'],
                    fuzziness: 'AUTO'
                }
            },
            from: options?.from || 0,
            size: options?.size || 10,
            highlight: {
                fields: { content: {} }
            }
        });
        
        return {
            total: result.hits.total,
            hits: result.hits.hits.map(hit => ({
                id: hit._id,
                score: hit._score,
                source: hit._source,
                highlight: hit.highlight
            }))
        };
    }
    
    async delete(indexName: string, id: string) {
        await this.client.delete({ index: indexName, id });
    }
    
    async bulk(operations: any[]) {
        await this.client.bulk({ operations });
    }
}

// PostgreSQL Full-Text Search
class PostgresSearchService {
    async search(table: string, query: string, columns: string[]) {
        const tsQuery = query.split(' ').join(' & ');
        const tsVector = columns.map(c => \`coalesce(\${c}, '')\`).join(" || ' ' || ");
        
        return prisma.$queryRaw\`
            SELECT *, ts_rank(to_tsvector('english', \${Prisma.raw(tsVector)}), to_tsquery('english', \${tsQuery})) as rank
            FROM \${Prisma.raw(table)}
            WHERE to_tsvector('english', \${Prisma.raw(tsVector)}) @@ to_tsquery('english', \${tsQuery})
            ORDER BY rank DESC
            LIMIT 20
        \`;
    }
    
    async createSearchIndex(table: string, columns: string[]) {
        const indexName = \`\${table}_search_idx\`;
        const tsVector = columns.map(c => \`coalesce(\${c}, '')\`).join(" || ' ' || ");
        
        await prisma.$executeRaw\`
            CREATE INDEX IF NOT EXISTS \${Prisma.raw(indexName)}
            ON \${Prisma.raw(table)}
            USING GIN(to_tsvector('english', \${Prisma.raw(tsVector)}))
        \`;
    }
}

// Search Component
export function SearchBox({ onSearch }: { onSearch: (query: string) => void }) {
    const [query, setQuery] = useState('');
    const debouncedQuery = useDebounce(query, 300);
    
    useEffect(() => {
        if (debouncedQuery) onSearch(debouncedQuery);
    }, [debouncedQuery]);
    
    return (
        <div className="search-box">
            <input
                type="search"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Search..."
            />
        </div>
    );
}

export { ElasticsearchService, PostgresSearchService, SearchBox };
`;
    }
}

export const fullTextSearchGenerator = FullTextSearchGenerator.getInstance();
