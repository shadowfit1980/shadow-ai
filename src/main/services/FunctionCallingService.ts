/**
 * ðŸ§© FunctionCallingService
 * 
 * LLM function calling:
 * - Schemas, execution, validation
 */

import { EventEmitter } from 'events';

export class FunctionCallingService extends EventEmitter {
    private static instance: FunctionCallingService;
    private constructor() { super(); }
    static getInstance(): FunctionCallingService {
        if (!FunctionCallingService.instance) {
            FunctionCallingService.instance = new FunctionCallingService();
        }
        return FunctionCallingService.instance;
    }

    generate(): string {
        return `// Function Calling Service - Schemas, execution
// Generated by Shadow AI

import OpenAI from 'openai';
import Ajv from 'ajv';

const ajv = new Ajv();

interface FunctionDefinition {
    name: string;
    description: string;
    parameters: {
        type: 'object';
        properties: Record<string, any>;
        required?: string[];
    };
    handler: (params: any) => Promise<any>;
}

class FunctionCalling {
    private openai = new OpenAI();
    private functions: Map<string, FunctionDefinition> = new Map();
    
    // Register function
    register(fn: FunctionDefinition): void {
        // Pre-compile schema validator
        ajv.compile(fn.parameters);
        this.functions.set(fn.name, fn);
    }
    
    // Get OpenAI tools format
    getTools(): any[] {
        return Array.from(this.functions.values()).map(fn => ({
            type: 'function',
            function: {
                name: fn.name,
                description: fn.description,
                parameters: fn.parameters
            }
        }));
    }
    
    // Execute function calls from LLM response
    async execute(toolCalls: any[]): Promise<ToolResult[]> {
        const results: ToolResult[] = [];
        
        for (const call of toolCalls) {
            const fn = this.functions.get(call.function.name);
            
            if (!fn) {
                results.push({
                    tool_call_id: call.id,
                    role: 'tool',
                    content: JSON.stringify({ error: \`Unknown function: \${call.function.name}\` })
                });
                continue;
            }
            
            try {
                const params = JSON.parse(call.function.arguments);
                
                // Validate parameters
                const valid = ajv.validate(fn.parameters, params);
                if (!valid) {
                    throw new Error(\`Invalid parameters: \${ajv.errorsText()}\`);
                }
                
                const result = await fn.handler(params);
                
                results.push({
                    tool_call_id: call.id,
                    role: 'tool',
                    content: JSON.stringify(result)
                });
            } catch (error) {
                results.push({
                    tool_call_id: call.id,
                    role: 'tool',
                    content: JSON.stringify({ error: error.message })
                });
            }
        }
        
        return results;
    }
    
    // Run conversation with function calling
    async chat(messages: any[], maxTurns = 5): Promise<{ messages: any[]; result: string }> {
        const allMessages = [...messages];
        
        for (let turn = 0; turn < maxTurns; turn++) {
            const response = await this.openai.chat.completions.create({
                model: 'gpt-4-turbo-preview',
                messages: allMessages,
                tools: this.getTools(),
                tool_choice: 'auto'
            });
            
            const message = response.choices[0].message;
            allMessages.push(message);
            
            // Check if done
            if (!message.tool_calls || message.tool_calls.length === 0) {
                return { messages: allMessages, result: message.content || '' };
            }
            
            // Execute functions
            const results = await this.execute(message.tool_calls);
            allMessages.push(...results);
        }
        
        return { messages: allMessages, result: 'Max turns reached' };
    }
    
    // Parallel function execution
    async executeParallel(toolCalls: any[]): Promise<ToolResult[]> {
        return Promise.all(toolCalls.map(async (call) => {
            const fn = this.functions.get(call.function.name);
            
            if (!fn) {
                return {
                    tool_call_id: call.id,
                    role: 'tool' as const,
                    content: JSON.stringify({ error: 'Unknown function' })
                };
            }
            
            try {
                const params = JSON.parse(call.function.arguments);
                const result = await fn.handler(params);
                
                return {
                    tool_call_id: call.id,
                    role: 'tool' as const,
                    content: JSON.stringify(result)
                };
            } catch (error) {
                return {
                    tool_call_id: call.id,
                    role: 'tool' as const,
                    content: JSON.stringify({ error: error.message })
                };
            }
        }));
    }
}

export { FunctionCalling, FunctionDefinition };
`;
    }
}

export const functionCallingService = FunctionCallingService.getInstance();
