/**
 * üåê GeoLocationGenerator
 * 
 * Geolocation features:
 * - Maps, geocoding, distance, polygons
 */

import { EventEmitter } from 'events';

export class GeoLocationGenerator extends EventEmitter {
    private static instance: GeoLocationGenerator;
    private constructor() { super(); }
    static getInstance(): GeoLocationGenerator {
        if (!GeoLocationGenerator.instance) {
            GeoLocationGenerator.instance = new GeoLocationGenerator();
        }
        return GeoLocationGenerator.instance;
    }

    generate(): string {
        return `// GeoLocation Generator - Maps, geocoding, distance, polygons
// Generated by Shadow AI

// Geolocation Hook
export function useGeolocation() {
    const [location, setLocation] = useState<GeolocationPosition | null>(null);
    const [error, setError] = useState<GeolocationPositionError | null>(null);
    
    useEffect(() => {
        if (!navigator.geolocation) {
            setError({ code: 0, message: 'Geolocation not supported' } as any);
            return;
        }
        
        const watchId = navigator.geolocation.watchPosition(
            setLocation,
            setError,
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
        
        return () => navigator.geolocation.clearWatch(watchId);
    }, []);
    
    return { location, error };
}

// Distance Calculation
export function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371e3; // Earth's radius in meters
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
    
    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    
    return R * c; // Distance in meters
}

// Geocoding
class GeocodingService {
    async geocode(address: string) {
        const response = await fetch(
            \`https://maps.googleapis.com/maps/api/geocode/json?address=\${encodeURIComponent(address)}&key=\${process.env.GOOGLE_MAPS_KEY}\`
        );
        const data = await response.json();
        
        if (data.results.length > 0) {
            const { lat, lng } = data.results[0].geometry.location;
            return { lat, lng, formattedAddress: data.results[0].formatted_address };
        }
        return null;
    }
    
    async reverseGeocode(lat: number, lng: number) {
        const response = await fetch(
            \`https://maps.googleapis.com/maps/api/geocode/json?latlng=\${lat},\${lng}&key=\${process.env.GOOGLE_MAPS_KEY}\`
        );
        const data = await response.json();
        return data.results[0]?.formatted_address || null;
    }
}

// Map Component
export function MapView({ center, markers }: { center: [number, number]; markers: Marker[] }) {
    return (
        <MapContainer center={center} zoom={13}>
            <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
            {markers.map((m, i) => (
                <Marker key={i} position={[m.lat, m.lng]}>
                    <Popup>{m.label}</Popup>
                </Marker>
            ))}
        </MapContainer>
    );
}

export { GeocodingService, MapView };
`;
    }
}

export const geoLocationGenerator = GeoLocationGenerator.getInstance();
