/**
 * ðŸŒ³ GitOperationsService
 * 
 * Git operations:
 * - Commits, branches, PRs
 */

import { EventEmitter } from 'events';

export class GitOperationsService extends EventEmitter {
    private static instance: GitOperationsService;
    private constructor() { super(); }
    static getInstance(): GitOperationsService {
        if (!GitOperationsService.instance) {
            GitOperationsService.instance = new GitOperationsService();
        }
        return GitOperationsService.instance;
    }

    generate(): string {
        return `// Git Operations Service - Commits, branches, PRs
// Generated by Shadow AI

import { execSync, exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

class GitOperations {
    private cwd: string;
    
    constructor(cwd: string) {
        this.cwd = cwd;
    }
    
    // Get current branch
    async getCurrentBranch(): Promise<string> {
        const { stdout } = await execAsync('git branch --show-current', { cwd: this.cwd });
        return stdout.trim();
    }
    
    // Get status
    async getStatus(): Promise<GitStatus> {
        const { stdout } = await execAsync('git status --porcelain', { cwd: this.cwd });
        const lines = stdout.trim().split('\\n').filter(Boolean);
        
        return {
            staged: lines.filter(l => l.startsWith('A ') || l.startsWith('M ')),
            unstaged: lines.filter(l => l.startsWith(' M') || l.startsWith(' D')),
            untracked: lines.filter(l => l.startsWith('??'))
        };
    }
    
    // Stage files
    async stage(files: string[]): Promise<void> {
        await execAsync(\`git add \${files.join(' ')}\`, { cwd: this.cwd });
    }
    
    // Commit with auto-generated message
    async smartCommit(files: string[]): Promise<string> {
        await this.stage(files);
        
        // Get diff for message generation
        const { stdout: diff } = await execAsync('git diff --cached', { cwd: this.cwd });
        
        const message = await this.generateCommitMessage(diff);
        
        await execAsync(\`git commit -m "\${message}"\`, { cwd: this.cwd });
        
        return message;
    }
    
    // Generate commit message
    async generateCommitMessage(diff: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Generate a conventional commit message for this diff. Format: type(scope): description
            Types: feat, fix, docs, style, refactor, test, chore
            Keep it under 72 characters.\`
        }, {
            role: 'user',
            content: diff.slice(0, 3000)
        }]);
        
        return response.content.trim();
    }
    
    // Create branch
    async createBranch(name: string, checkout = true): Promise<void> {
        const cmd = checkout ? \`git checkout -b \${name}\` : \`git branch \${name}\`;
        await execAsync(cmd, { cwd: this.cwd });
    }
    
    // Get diff
    async getDiff(base?: string): Promise<string> {
        const cmd = base ? \`git diff \${base}\` : 'git diff';
        const { stdout } = await execAsync(cmd, { cwd: this.cwd });
        return stdout;
    }
    
    // Get log
    async getLog(count = 10): Promise<Commit[]> {
        const { stdout } = await execAsync(
            \`git log -\${count} --pretty=format:'{"hash":"%H","message":"%s","author":"%an","date":"%ai"}'\`,
            { cwd: this.cwd }
        );
        
        return stdout.trim().split('\\n').map(line => JSON.parse(line));
    }
    
    // Push changes
    async push(force = false): Promise<void> {
        const cmd = force ? 'git push --force-with-lease' : 'git push';
        await execAsync(cmd, { cwd: this.cwd });
    }
    
    // Pull changes
    async pull(rebase = true): Promise<void> {
        const cmd = rebase ? 'git pull --rebase' : 'git pull';
        await execAsync(cmd, { cwd: this.cwd });
    }
    
    // Stash
    async stash(message?: string): Promise<void> {
        const cmd = message ? \`git stash push -m "\${message}"\` : 'git stash';
        await execAsync(cmd, { cwd: this.cwd });
    }
    
    // Pop stash
    async stashPop(): Promise<void> {
        await execAsync('git stash pop', { cwd: this.cwd });
    }
    
    // Resolve conflicts with AI
    async resolveConflicts(filePath: string): Promise<string> {
        const content = await fs.readFile(filePath, 'utf-8');
        
        const response = await llm.chat([{
            role: 'system',
            content: 'Resolve the git merge conflicts in this file. Choose the best resolution and explain why.'
        }, {
            role: 'user',
            content: content
        }]);
        
        return response.content;
    }
}

export { GitOperations };
`;
    }
}

export const gitOperationsService = GitOperationsService.getInstance();
