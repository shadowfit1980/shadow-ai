/**
 * ðŸŽ® Godot Exporter
 * 
 * Export games to Godot 4 GDScript:
 * - Scene tree structure
 * - GDScript code generation
 * - Resource files
 */

import { EventEmitter } from 'events';

export class GodotExporter extends EventEmitter {
    private static instance: GodotExporter;

    private constructor() { super(); }

    static getInstance(): GodotExporter {
        if (!GodotExporter.instance) {
            GodotExporter.instance = new GodotExporter();
        }
        return GodotExporter.instance;
    }

    exportToGodot(gameDef: any): { scenes: any[]; scripts: any[]; project: string } {
        return {
            scenes: this.generateScenes(gameDef),
            scripts: this.generateScripts(gameDef),
            project: this.generateProjectFile(gameDef)
        };
    }

    private generateScenes(gameDef: any): any[] {
        return [{
            name: 'main.tscn',
            content: `[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/main.gd" id="1"]

[node name="Main" type="Node2D"]
script = ExtResource("1")

[node name="Player" type="CharacterBody2D" parent="."]
position = Vector2(400, 300)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Player"]
shape = CircleShape2D.new()

[node name="Sprite2D" type="Sprite2D" parent="Player"]
`
        }];
    }

    private generateScripts(gameDef: any): any[] {
        const scripts = [];

        // Main game script
        scripts.push({
            name: 'scripts/main.gd',
            content: `extends Node2D

# Game variables
var score: int = 0
var game_over: bool = false

func _ready() -> void:
    print("Game Started!")

func _process(delta: float) -> void:
    if game_over:
        return
    
    # Game logic here
    pass
`
        });

        // Player script
        scripts.push({
            name: 'scripts/player.gd',
            content: `extends CharacterBody2D

@export var speed: float = 300.0
@export var jump_force: float = -400.0

var gravity: float = 980.0

func _physics_process(delta: float) -> void:
    # Gravity
    if not is_on_floor():
        velocity.y += gravity * delta
    
    # Jump
    if Input.is_action_just_pressed("ui_accept") and is_on_floor():
        velocity.y = jump_force
    
    # Horizontal movement
    var direction := Input.get_axis("ui_left", "ui_right")
    if direction:
        velocity.x = direction * speed
    else:
        velocity.x = move_toward(velocity.x, 0, speed)
    
    move_and_slide()
`
        });

        return scripts;
    }

    private generateProjectFile(gameDef: any): string {
        const name = gameDef.name || 'GameProject';
        return `; Engine configuration file.
; It's best generated by the editor.

config_version=5

[application]
config/name="${name}"
run/main_scene="res://scenes/main.tscn"
config/features=PackedStringArray("4.2", "Forward Plus")

[input]
ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"echo":false,"script":null)]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"echo":false,"script":null)]
}

[rendering]
renderer/rendering_method="gl_compatibility"
`;
    }

    generateGodotPlayerScript(): string {
        return `extends CharacterBody2D

# Movement
@export var speed: float = 300.0
@export var acceleration: float = 2000.0
@export var friction: float = 1500.0
@export var jump_force: float = -450.0
@export var gravity: float = 980.0

# State
var is_jumping: bool = false
var can_double_jump: bool = true

func _physics_process(delta: float) -> void:
    apply_gravity(delta)
    handle_jump()
    handle_movement(delta)
    move_and_slide()

func apply_gravity(delta: float) -> void:
    if not is_on_floor():
        velocity.y += gravity * delta
    else:
        is_jumping = false
        can_double_jump = true

func handle_jump() -> void:
    if Input.is_action_just_pressed("jump"):
        if is_on_floor():
            velocity.y = jump_force
            is_jumping = true
        elif can_double_jump:
            velocity.y = jump_force * 0.8
            can_double_jump = false

func handle_movement(delta: float) -> void:
    var direction := Input.get_axis("move_left", "move_right")
    
    if direction != 0:
        velocity.x = move_toward(velocity.x, direction * speed, acceleration * delta)
    else:
        velocity.x = move_toward(velocity.x, 0, friction * delta)
`;
    }

    generateGodotEnemyScript(): string {
        return `extends CharacterBody2D

@export var speed: float = 100.0
@export var detection_range: float = 200.0
@export var attack_range: float = 50.0
@export var health: int = 3

var player: Node2D = null
var direction: int = 1

enum State { IDLE, PATROL, CHASE, ATTACK }
var current_state: State = State.PATROL

func _ready() -> void:
    player = get_tree().get_first_node_in_group("player")

func _physics_process(delta: float) -> void:
    match current_state:
        State.IDLE:
            state_idle()
        State.PATROL:
            state_patrol(delta)
        State.CHASE:
            state_chase(delta)
        State.ATTACK:
            state_attack()

func state_idle() -> void:
    velocity.x = 0
    if can_see_player():
        current_state = State.CHASE

func state_patrol(delta: float) -> void:
    velocity.x = direction * speed * 0.5
    
    if is_on_wall():
        direction *= -1
    
    if can_see_player():
        current_state = State.CHASE

func state_chase(delta: float) -> void:
    if player:
        var dir_to_player := sign(player.global_position.x - global_position.x)
        velocity.x = dir_to_player * speed
        
        if global_position.distance_to(player.global_position) < attack_range:
            current_state = State.ATTACK
        elif not can_see_player():
            current_state = State.PATROL

func state_attack() -> void:
    velocity.x = 0
    # Attack animation/logic here
    
    if global_position.distance_to(player.global_position) > attack_range:
        current_state = State.CHASE

func can_see_player() -> bool:
    if not player:
        return false
    return global_position.distance_to(player.global_position) < detection_range

func take_damage(amount: int) -> void:
    health -= amount
    if health <= 0:
        queue_free()
`;
    }
}

export const godotExporter = GodotExporter.getInstance();
