/**
 * ðŸ“Š GraphQL Generator
 * 
 * Generate GraphQL code:
 * - Schema definitions
 * - Resolvers
 * - Subscriptions
 */

import { EventEmitter } from 'events';

export interface GraphQLType {
    name: string;
    fields: { name: string; type: string; args?: { name: string; type: string }[] }[];
}

export class GraphQLGenerator extends EventEmitter {
    private static instance: GraphQLGenerator;

    private constructor() { super(); }

    static getInstance(): GraphQLGenerator {
        if (!GraphQLGenerator.instance) {
            GraphQLGenerator.instance = new GraphQLGenerator();
        }
        return GraphQLGenerator.instance;
    }

    generateFullStack(): string {
        return `// GraphQL Full Stack Setup
// Generated by Shadow AI

// === schema.graphql ===
\`
scalar DateTime
scalar JSON

type Query {
    users(limit: Int, offset: Int): [User!]!
    user(id: ID!): User
    posts(authorId: ID): [Post!]!
    post(id: ID!): Post
    me: User
}

type Mutation {
    register(input: RegisterInput!): AuthPayload!
    login(email: String!, password: String!): AuthPayload!
    createPost(input: CreatePostInput!): Post!
    updatePost(id: ID!, input: UpdatePostInput!): Post!
    deletePost(id: ID!): Boolean!
    updateProfile(input: UpdateProfileInput!): User!
}

type Subscription {
    postCreated: Post!
    postUpdated(authorId: ID): Post!
    userJoined: User!
}

type User {
    id: ID!
    email: String!
    name: String!
    avatar: String
    posts: [Post!]!
    createdAt: DateTime!
}

type Post {
    id: ID!
    title: String!
    content: String!
    published: Boolean!
    author: User!
    createdAt: DateTime!
    updatedAt: DateTime!
}

type AuthPayload {
    token: String!
    user: User!
}

input RegisterInput {
    email: String!
    password: String!
    name: String!
}

input CreatePostInput {
    title: String!
    content: String!
    published: Boolean
}

input UpdatePostInput {
    title: String
    content: String
    published: Boolean
}

input UpdateProfileInput {
    name: String
    avatar: String
}
\`

// === resolvers.ts ===
import { PubSub, withFilter } from 'graphql-subscriptions';

const pubsub = new PubSub();

const POST_CREATED = 'POST_CREATED';
const POST_UPDATED = 'POST_UPDATED';
const USER_JOINED = 'USER_JOINED';

export const resolvers = {
    Query: {
        users: async (_, { limit, offset }, { prisma }) => {
            return prisma.user.findMany({
                take: limit || 10,
                skip: offset || 0
            });
        },
        
        user: async (_, { id }, { prisma }) => {
            return prisma.user.findUnique({ where: { id } });
        },
        
        posts: async (_, { authorId }, { prisma }) => {
            return prisma.post.findMany({
                where: authorId ? { authorId } : {},
                orderBy: { createdAt: 'desc' }
            });
        },
        
        post: async (_, { id }, { prisma }) => {
            return prisma.post.findUnique({ where: { id } });
        },
        
        me: async (_, __, { user, prisma }) => {
            if (!user) return null;
            return prisma.user.findUnique({ where: { id: user.id } });
        }
    },
    
    Mutation: {
        register: async (_, { input }, { prisma, auth }) => {
            const user = await auth.register(input.email, input.password, input.name);
            pubsub.publish(USER_JOINED, { userJoined: user });
            return user;
        },
        
        login: async (_, { email, password }, { auth }) => {
            return auth.login(email, password);
        },
        
        createPost: async (_, { input }, { user, prisma }) => {
            if (!user) throw new Error('Not authenticated');
            
            const post = await prisma.post.create({
                data: { ...input, authorId: user.id }
            });
            
            pubsub.publish(POST_CREATED, { postCreated: post });
            return post;
        },
        
        updatePost: async (_, { id, input }, { user, prisma }) => {
            const post = await prisma.post.findUnique({ where: { id } });
            if (!post || post.authorId !== user.id) {
                throw new Error('Not authorized');
            }
            
            const updated = await prisma.post.update({
                where: { id },
                data: input
            });
            
            pubsub.publish(POST_UPDATED, { postUpdated: updated });
            return updated;
        },
        
        deletePost: async (_, { id }, { user, prisma }) => {
            const post = await prisma.post.findUnique({ where: { id } });
            if (!post || post.authorId !== user.id) {
                throw new Error('Not authorized');
            }
            
            await prisma.post.delete({ where: { id } });
            return true;
        }
    },
    
    Subscription: {
        postCreated: {
            subscribe: () => pubsub.asyncIterator([POST_CREATED])
        },
        
        postUpdated: {
            subscribe: withFilter(
                () => pubsub.asyncIterator([POST_UPDATED]),
                (payload, variables) => {
                    if (!variables.authorId) return true;
                    return payload.postUpdated.authorId === variables.authorId;
                }
            )
        },
        
        userJoined: {
            subscribe: () => pubsub.asyncIterator([USER_JOINED])
        }
    },
    
    User: {
        posts: async (parent, _, { prisma }) => {
            return prisma.post.findMany({ where: { authorId: parent.id } });
        }
    },
    
    Post: {
        author: async (parent, _, { prisma }) => {
            return prisma.user.findUnique({ where: { id: parent.authorId } });
        }
    }
};

// === server.ts ===
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import { makeExecutableSchema } from '@graphql-tools/schema';

const schema = makeExecutableSchema({ typeDefs, resolvers });

// WebSocket server for subscriptions
const wsServer = new WebSocketServer({ port: 4000, path: '/graphql' });
useServer({ schema }, wsServer);

// Apollo Server
const server = new ApolloServer({ schema });
await server.start();

app.use('/graphql', 
    express.json(),
    expressMiddleware(server, {
        context: async ({ req }) => ({
            prisma,
            auth: new AuthService(),
            user: await getUserFromToken(req.headers.authorization)
        })
    })
);
`;
    }

    generateTypeFromModel(modelName: string, fields: { name: string; type: string }[]): string {
        let type = `type ${modelName} {\n    id: ID!\n`;
        for (const field of fields) {
            type += `    ${field.name}: ${this.graphqlType(field.type)}\n`;
        }
        type += '}\n';
        return type;
    }

    private graphqlType(type: string): string {
        const map: Record<string, string> = {
            'string': 'String',
            'number': 'Int',
            'float': 'Float',
            'boolean': 'Boolean',
            'date': 'DateTime',
            'json': 'JSON'
        };
        return map[type.toLowerCase()] || 'String';
    }

    generateCRUDResolvers(modelName: string): string {
        const lower = modelName.toLowerCase();
        const plural = lower + 's';

        return `// ${modelName} Resolvers
const ${lower}Resolvers = {
    Query: {
        ${plural}: (_, args, { prisma }) => prisma.${lower}.findMany(args),
        ${lower}: (_, { id }, { prisma }) => prisma.${lower}.findUnique({ where: { id } })
    },
    Mutation: {
        create${modelName}: (_, { input }, { prisma }) => prisma.${lower}.create({ data: input }),
        update${modelName}: (_, { id, input }, { prisma }) => prisma.${lower}.update({ where: { id }, data: input }),
        delete${modelName}: (_, { id }, { prisma }) => prisma.${lower}.delete({ where: { id } })
    }
};`;
    }
}

export const graphqlGenerator = GraphQLGenerator.getInstance();
