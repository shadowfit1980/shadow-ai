/**
 * ðŸ“Š GraphQL Tooling Generator
 * 
 * Generate GraphQL advanced patterns:
 * - Codegen, Federation, Subscriptions
 */

import { EventEmitter } from 'events';

export class GraphQLTooling extends EventEmitter {
    private static instance: GraphQLTooling;

    private constructor() { super(); }

    static getInstance(): GraphQLTooling {
        if (!GraphQLTooling.instance) {
            GraphQLTooling.instance = new GraphQLTooling();
        }
        return GraphQLTooling.instance;
    }

    generateCodegen(): string {
        return `// GraphQL Code Generation
// Generated by Shadow AI

// codegen.ts
import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
    overwrite: true,
    schema: './schema.graphql',
    documents: 'src/**/*.graphql',
    generates: {
        // TypeScript types
        'src/generated/graphql.ts': {
            plugins: [
                'typescript',
                'typescript-operations',
                'typescript-react-query'
            ],
            config: {
                fetcher: {
                    func: './fetcher#fetcher',
                    isReactHook: false
                },
                exposeFetcher: true,
                exposeQueryKeys: true,
                enumsAsTypes: true,
                skipTypename: false,
                withHooks: true,
                withHOC: false,
                withComponent: false
            }
        },
        // Introspection JSON
        'src/generated/introspection.json': {
            plugins: ['introspection']
        },
        // Schema AST
        'src/generated/schema.json': {
            plugins: ['introspection'],
            config: { minify: true }
        }
    },
    hooks: {
        afterAllFileWrite: ['prettier --write']
    }
};

export default config;

// fetcher.ts
export async function fetcher<TData, TVariables>(
    query: string,
    variables?: TVariables
): Promise<TData> {
    const response = await fetch('/graphql', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: \`Bearer \${getToken()}\`
        },
        body: JSON.stringify({ query, variables })
    });

    const json = await response.json();

    if (json.errors) {
        throw new Error(json.errors[0].message);
    }

    return json.data;
}

// Usage with generated hooks
import { useGetUsersQuery, useCreateUserMutation } from './generated/graphql';

function UserList() {
    const { data, isLoading } = useGetUsersQuery();
    const createUser = useCreateUserMutation();

    const handleCreate = () => {
        createUser.mutate({ input: { name: 'New User' } });
    };

    if (isLoading) return <Loading />;
    return <ul>{data?.users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
`;
    }

    generateFederation(): string {
        return `// Apollo Federation
// Generated by Shadow AI

// === Gateway (Supergraph) ===
import { ApolloGateway, IntrospectAndCompose } from '@apollo/gateway';
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';

const gateway = new ApolloGateway({
    supergraphSdl: new IntrospectAndCompose({
        subgraphs: [
            { name: 'users', url: 'http://users-service:4001/graphql' },
            { name: 'products', url: 'http://products-service:4002/graphql' },
            { name: 'orders', url: 'http://orders-service:4003/graphql' }
        ]
    })
});

const server = new ApolloServer({ gateway });
await server.start();
app.use('/graphql', expressMiddleware(server));

// === Subgraph: Users Service ===
import { buildSubgraphSchema } from '@apollo/subgraph';
import { gql } from 'graphql-tag';

const typeDefs = gql\`
    extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@shareable"])

    type Query {
        me: User
        users: [User!]!
    }

    type User @key(fields: "id") {
        id: ID!
        name: String!
        email: String!
    }
\`;

const resolvers = {
    Query: {
        me: (_, __, { user }) => user,
        users: () => db.user.findMany()
    },
    User: {
        __resolveReference: (ref) => db.user.findUnique({ where: { id: ref.id } })
    }
};

const server = new ApolloServer({
    schema: buildSubgraphSchema({ typeDefs, resolvers })
});

// === Subgraph: Orders Service (extends User) ===
const typeDefs = gql\`
    extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@external"])

    type Order @key(fields: "id") {
        id: ID!
        items: [OrderItem!]!
        user: User!
        total: Float!
    }

    type OrderItem {
        product: Product!
        quantity: Int!
        price: Float!
    }

    extend type User @key(fields: "id") {
        id: ID! @external
        orders: [Order!]!
    }

    extend type Product @key(fields: "id") {
        id: ID! @external
    }
\`;

const resolvers = {
    User: {
        orders: (user) => db.order.findMany({ where: { userId: user.id } })
    },
    Order: {
        user: (order) => ({ __typename: 'User', id: order.userId })
    }
};
`;
    }

    generateSubscriptions(): string {
        return `// GraphQL Subscriptions
// Generated by Shadow AI

import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { PubSub } from 'graphql-subscriptions';

const pubsub = new PubSub();

const typeDefs = \`
    type Query {
        messages: [Message!]!
    }

    type Mutation {
        sendMessage(content: String!, channelId: ID!): Message!
    }

    type Subscription {
        messageReceived(channelId: ID!): Message!
        userTyping(channelId: ID!): User!
        onlineUsers: [User!]!
    }

    type Message {
        id: ID!
        content: String!
        author: User!
        createdAt: String!
    }

    type User {
        id: ID!
        name: String!
        avatar: String
    }
\`;

const resolvers = {
    Query: {
        messages: () => db.message.findMany({ include: { author: true } })
    },
    Mutation: {
        sendMessage: async (_, { content, channelId }, { user }) => {
            const message = await db.message.create({
                data: { content, channelId, authorId: user.id },
                include: { author: true }
            });
            
            // Publish to subscribers
            pubsub.publish(\`MESSAGE_\${channelId}\`, { messageReceived: message });
            
            return message;
        }
    },
    Subscription: {
        messageReceived: {
            subscribe: (_, { channelId }) => pubsub.asyncIterator(\`MESSAGE_\${channelId}\`)
        },
        userTyping: {
            subscribe: (_, { channelId }) => pubsub.asyncIterator(\`TYPING_\${channelId}\`)
        },
        onlineUsers: {
            subscribe: () => pubsub.asyncIterator('ONLINE_USERS')
        }
    }
};

const schema = makeExecutableSchema({ typeDefs, resolvers });

// HTTP + WebSocket server
const httpServer = createServer(app);
const wsServer = new WebSocketServer({ server: httpServer, path: '/graphql' });

useServer(
    {
        schema,
        context: async (ctx) => {
            const token = ctx.connectionParams?.authorization;
            const user = await verifyToken(token);
            return { user };
        },
        onConnect: async (ctx) => {
            console.log('Client connected');
        },
        onDisconnect: (ctx) => {
            console.log('Client disconnected');
        }
    },
    wsServer
);

// Client usage
import { createClient } from 'graphql-ws';

const client = createClient({
    url: 'ws://localhost:4000/graphql',
    connectionParams: { authorization: \`Bearer \${token}\` }
});

client.subscribe(
    {
        query: \`subscription($channelId: ID!) { messageReceived(channelId: $channelId) { id content author { name } } }\`,
        variables: { channelId: '123' }
    },
    {
        next: (data) => console.log('Message:', data),
        error: (err) => console.error('Error:', err),
        complete: () => console.log('Complete')
    }
);
`;
    }
}

export const graphqlTooling = GraphQLTooling.getInstance();
