/**
 * üèÉ HealthCheckGenerator
 * 
 * Health checks:
 * - Liveness, readiness, dependencies
 */

import { EventEmitter } from 'events';

export class HealthCheckGenerator extends EventEmitter {
    private static instance: HealthCheckGenerator;
    private constructor() { super(); }
    static getInstance(): HealthCheckGenerator {
        if (!HealthCheckGenerator.instance) {
            HealthCheckGenerator.instance = new HealthCheckGenerator();
        }
        return HealthCheckGenerator.instance;
    }

    generate(): string {
        return `// Health Check Generator - Liveness, readiness, dependencies
// Generated by Shadow AI

// Health Check Service
class HealthCheckService {
    private checks: Map<string, () => Promise<{ status: 'healthy' | 'unhealthy'; latency?: number; error?: string }>> = new Map();
    
    register(name: string, check: () => Promise<any>) {
        this.checks.set(name, async () => {
            const start = Date.now();
            try {
                await check();
                return { status: 'healthy', latency: Date.now() - start };
            } catch (error) {
                return { status: 'unhealthy', latency: Date.now() - start, error: error.message };
            }
        });
    }
    
    async check(): Promise<HealthReport> {
        const results: Record<string, any> = {};
        let overallHealthy = true;
        
        for (const [name, check] of this.checks) {
            const result = await check();
            results[name] = result;
            if (result.status === 'unhealthy') overallHealthy = false;
        }
        
        return {
            status: overallHealthy ? 'healthy' : 'unhealthy',
            timestamp: new Date().toISOString(),
            checks: results
        };
    }
    
    async liveness(): Promise<{ status: 'ok' }> {
        return { status: 'ok' };
    }
    
    async readiness(): Promise<HealthReport> {
        return this.check();
    }
}

// Default Checks
function setupDefaultChecks(healthCheck: HealthCheckService) {
    // Database check
    healthCheck.register('database', async () => {
        await prisma.$queryRaw\`SELECT 1\`;
    });
    
    // Redis check
    healthCheck.register('redis', async () => {
        await redis.ping();
    });
    
    // Memory check
    healthCheck.register('memory', async () => {
        const used = process.memoryUsage();
        const threshold = 500 * 1024 * 1024; // 500MB
        if (used.heapUsed > threshold) {
            throw new Error(\`Memory usage too high: \${Math.round(used.heapUsed / 1024 / 1024)}MB\`);
        }
    });
    
    // Disk check (optional)
    healthCheck.register('disk', async () => {
        const { execSync } = require('child_process');
        const output = execSync("df -h / | tail -1 | awk '{print $5}'").toString().trim();
        const usage = parseInt(output.replace('%', ''));
        if (usage > 90) throw new Error(\`Disk usage too high: \${usage}%\`);
    });
}

// Express Routes
function setupHealthRoutes(app: Express, healthCheck: HealthCheckService) {
    // Kubernetes liveness probe
    app.get('/health/live', async (req, res) => {
        const result = await healthCheck.liveness();
        res.json(result);
    });
    
    // Kubernetes readiness probe
    app.get('/health/ready', async (req, res) => {
        const result = await healthCheck.readiness();
        res.status(result.status === 'healthy' ? 200 : 503).json(result);
    });
    
    // Full health report
    app.get('/health', async (req, res) => {
        const result = await healthCheck.check();
        res.status(result.status === 'healthy' ? 200 : 503).json(result);
    });
}

export { HealthCheckService, setupDefaultChecks, setupHealthRoutes };
`;
    }
}

export const healthCheckGenerator = HealthCheckGenerator.getInstance();
