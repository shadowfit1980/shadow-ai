/**
 * ðŸ”§ HotReloadAgentService
 * 
 * Hot reload capabilities:
 * - Update without restart
 */

import { EventEmitter } from 'events';

export class HotReloadAgentService extends EventEmitter {
    private static instance: HotReloadAgentService;
    private constructor() { super(); }
    static getInstance(): HotReloadAgentService {
        if (!HotReloadAgentService.instance) {
            HotReloadAgentService.instance = new HotReloadAgentService();
        }
        return HotReloadAgentService.instance;
    }

    generate(): string {
        return `// Hot Reload Agent Service - Update without restart
// Generated by Shadow AI

interface HotModule {
    path: string;
    exports: any;
    lastModified: number;
    dependencies: string[];
}

class HotReloadAgent {
    private modules: Map<string, HotModule> = new Map();
    private watchers: Map<string, any> = new Map();
    private reloadQueue: string[] = [];
    
    // Register module for hot reload
    register(path: string, module: any): void {
        this.modules.set(path, {
            path,
            exports: module,
            lastModified: Date.now(),
            dependencies: this.extractDependencies(module)
        });
        
        // Start watching
        this.watchFile(path);
    }
    
    // Hot reload a specific module
    async reload(path: string): Promise<ReloadResult> {
        const existing = this.modules.get(path);
        if (!existing) {
            return { success: false, error: 'Module not registered' };
        }
        
        try {
            // Clear require cache
            this.clearModuleCache(path);
            
            // Re-require the module
            const newModule = require(path);
            
            // Validate the new module
            const valid = await this.validateModule(newModule, existing.exports);
            if (!valid) {
                return { success: false, error: 'Module validation failed' };
            }
            
            // Update references
            this.updateReferences(path, existing.exports, newModule);
            
            // Update stored module
            this.modules.set(path, {
                path,
                exports: newModule,
                lastModified: Date.now(),
                dependencies: this.extractDependencies(newModule)
            });
            
            // Reload dependents
            await this.reloadDependents(path);
            
            this.emit('reloaded', { path, timestamp: Date.now() });
            
            return { success: true };
        } catch (error) {
            this.emit('reload-error', { path, error });
            return { success: false, error: (error as Error).message };
        }
    }
    
    // Watch file for changes
    private watchFile(path: string): void {
        if (this.watchers.has(path)) return;
        
        const watcher = fs.watch(path, async (eventType) => {
            if (eventType === 'change') {
                // Debounce
                if (!this.reloadQueue.includes(path)) {
                    this.reloadQueue.push(path);
                    
                    setTimeout(async () => {
                        const idx = this.reloadQueue.indexOf(path);
                        if (idx > -1) {
                            this.reloadQueue.splice(idx, 1);
                            await this.reload(path);
                        }
                    }, 100);
                }
            }
        });
        
        this.watchers.set(path, watcher);
    }
    
    // Clear Node.js module cache
    private clearModuleCache(path: string): void {
        const resolvedPath = require.resolve(path);
        const module = require.cache[resolvedPath];
        
        if (module) {
            // Remove from parent's children
            if (module.parent) {
                module.parent.children = module.parent.children.filter(
                    (child: any) => child.id !== resolvedPath
                );
            }
            
            // Clear cache
            delete require.cache[resolvedPath];
        }
    }
    
    // Update references from old to new module
    private updateReferences(path: string, oldModule: any, newModule: any): void {
        // Copy over any state that should persist
        if (oldModule._persistentState && newModule._persistentState !== undefined) {
            newModule._persistentState = oldModule._persistentState;
        }
        
        // Update singleton instances
        if (oldModule.getInstance && newModule.getInstance) {
            const instance = oldModule.getInstance();
            // Transfer state to new instance
            const newInstance = newModule.getInstance();
            Object.assign(newInstance, instance);
        }
    }
    
    // Validate new module has required exports
    private async validateModule(newModule: any, oldModule: any): Promise<boolean> {
        const oldKeys = Object.keys(oldModule);
        const newKeys = Object.keys(newModule);
        
        // Check all old exports exist
        for (const key of oldKeys) {
            if (!newKeys.includes(key)) {
                console.warn(\`Missing export: \${key}\`);
                return false;
            }
        }
        
        return true;
    }
    
    // Extract dependencies from module
    private extractDependencies(module: any): string[] {
        // Would analyze source or module.children
        return [];
    }
    
    // Reload all modules that depend on the changed one
    private async reloadDependents(path: string): Promise<void> {
        for (const [depPath, mod] of this.modules.entries()) {
            if (mod.dependencies.includes(path)) {
                await this.reload(depPath);
            }
        }
    }
    
    // Hot reload prompts
    async reloadPrompt(promptPath: string): Promise<void> {
        const newPrompt = await fs.readFile(promptPath, 'utf-8');
        
        // Update prompt cache
        this.emit('prompt-reloaded', { path: promptPath, length: newPrompt.length });
    }
    
    // Hot reload tool definitions
    async reloadTools(toolsPath: string): Promise<void> {
        await this.reload(toolsPath);
        this.emit('tools-reloaded', { path: toolsPath });
    }
    
    // Get reload statistics
    getStats(): ReloadStats {
        return {
            registeredModules: this.modules.size,
            activeWatchers: this.watchers.size,
            pendingReloads: this.reloadQueue.length
        };
    }
    
    // Stop watching
    stopWatching(path?: string): void {
        if (path) {
            const watcher = this.watchers.get(path);
            if (watcher) {
                watcher.close();
                this.watchers.delete(path);
            }
        } else {
            for (const watcher of this.watchers.values()) {
                watcher.close();
            }
            this.watchers.clear();
        }
    }
}

export { HotReloadAgent };
`;
    }
}

export const hotReloadAgentService = HotReloadAgentService.getInstance();
