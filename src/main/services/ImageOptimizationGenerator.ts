/**
 * üñºÔ∏è ImageOptimizationGenerator
 * 
 * Image optimization:
 * - Sharp, WebP, responsive images
 */

import { EventEmitter } from 'events';

export class ImageOptimizationGenerator extends EventEmitter {
    private static instance: ImageOptimizationGenerator;
    private constructor() { super(); }
    static getInstance(): ImageOptimizationGenerator {
        if (!ImageOptimizationGenerator.instance) {
            ImageOptimizationGenerator.instance = new ImageOptimizationGenerator();
        }
        return ImageOptimizationGenerator.instance;
    }

    generate(): string {
        return `// Image Optimization Generator - Sharp, WebP, responsive
// Generated by Shadow AI

import sharp from 'sharp';

class ImageOptimizer {
    async optimize(buffer: Buffer, options: OptimizeOptions = {}): Promise<Buffer> {
        let image = sharp(buffer);
        
        // Resize if dimensions provided
        if (options.width || options.height) {
            image = image.resize(options.width, options.height, {
                fit: options.fit || 'cover',
                withoutEnlargement: true
            });
        }
        
        // Convert to format
        switch (options.format || 'webp') {
            case 'webp':
                image = image.webp({ quality: options.quality || 80 });
                break;
            case 'avif':
                image = image.avif({ quality: options.quality || 80 });
                break;
            case 'jpeg':
                image = image.jpeg({ quality: options.quality || 80, progressive: true });
                break;
            case 'png':
                image = image.png({ compressionLevel: 9 });
                break;
        }
        
        return image.toBuffer();
    }
    
    async generateResponsiveSizes(buffer: Buffer): Promise<ResponsiveImages> {
        const sizes = [320, 640, 768, 1024, 1280, 1920];
        const results: ResponsiveImages = {};
        
        for (const width of sizes) {
            results[width] = {
                webp: await this.optimize(buffer, { width, format: 'webp' }),
                jpeg: await this.optimize(buffer, { width, format: 'jpeg' })
            };
        }
        
        return results;
    }
    
    async generateThumbnail(buffer: Buffer, size = 200): Promise<Buffer> {
        return this.optimize(buffer, { width: size, height: size, fit: 'cover' });
    }
    
    async getMetadata(buffer: Buffer) {
        return sharp(buffer).metadata();
    }
}

// Express Middleware for Image Processing
function imageProcessingMiddleware(optimzer: ImageOptimizer) {
    return async (req: any, res: any, next: Function) => {
        if (!req.file) return next();
        
        const optimized = await optimizer.optimize(req.file.buffer, {
            width: 1920,
            format: 'webp',
            quality: 85
        });
        
        req.file.buffer = optimized;
        req.file.mimetype = 'image/webp';
        req.file.size = optimized.length;
        
        next();
    };
}

// Next.js Image Component
export function OptimizedImage({ src, alt, sizes }: ImageProps) {
    return (
        <picture>
            <source srcSet={\`\${src}?w=320 320w, \${src}?w=640 640w, \${src}?w=1024 1024w\`} type="image/webp" />
            <source srcSet={\`\${src}?w=320&f=jpg 320w, \${src}?w=640&f=jpg 640w\`} type="image/jpeg" />
            <img src={src} alt={alt} loading="lazy" decoding="async" />
        </picture>
    );
}

export { ImageOptimizer, imageProcessingMiddleware, OptimizedImage };
`;
    }
}

export const imageOptimizationGenerator = ImageOptimizationGenerator.getInstance();
