/**
 * ðŸ¤– Intelligent NPC Generator
 * 
 * AI-driven NPCs:
 * - Behavior trees, pathfinding, dialogue
 */

import { EventEmitter } from 'events';

export class IntelligentNPCGenerator extends EventEmitter {
    private static instance: IntelligentNPCGenerator;

    private constructor() { super(); }

    static getInstance(): IntelligentNPCGenerator {
        if (!IntelligentNPCGenerator.instance) {
            IntelligentNPCGenerator.instance = new IntelligentNPCGenerator();
        }
        return IntelligentNPCGenerator.instance;
    }

    generate(): string {
        return `// Intelligent NPC Generator
// Generated by Shadow AI

/**
 * INTELLIGENT NPC GENERATOR
 * 
 * Generate AI-driven NPCs with personality, behavior, and dialogue.
 */

interface NPCProfile {
    id: string;
    name: string;
    role: string;
    personality: PersonalityTraits;
    backstory: string;
    goals: Goal[];
    skills: Skill[];
    relationships: Map<string, number>;
    schedule: DailySchedule;
    behaviorTree: BehaviorNode;
}

interface PersonalityTraits {
    openness: number;        // 0-100 (incurious to curious)
    conscientiousness: number; // 0-100 (careless to organized)
    extraversion: number;    // 0-100 (introverted to extroverted)
    agreeableness: number;   // 0-100 (hostile to friendly)
    neuroticism: number;     // 0-100 (calm to anxious)
}

// === NPC Generator ===
class NPCGenerator {
    async generateNPC(template: NPCTemplate): Promise<NPCProfile> {
        const prompt = \`
            Generate a detailed NPC for a \${template.gameGenre} game:
            
            Role: \${template.role}
            Setting: \${template.setting}
            Importance: \${template.importance}
            
            Create:
            1. Unique name fitting the setting
            2. Detailed personality (Big Five traits with reasoning)
            3. Compelling backstory (200 words)
            4. 3-5 short-term and long-term goals
            5. Skills and abilities
            6. Quirks and habits
            7. Speech patterns/catchphrases
            8. Secrets they're hiding
            
            Return as JSON.
        \`;
        
        const npcData = await this.llm.complete(prompt);
        const parsed = JSON.parse(npcData);
        
        // Generate behavior tree
        parsed.behaviorTree = await this.generateBehaviorTree(parsed);
        
        // Generate schedule
        parsed.schedule = await this.generateSchedule(parsed);
        
        return parsed;
    }
    
    private async generateBehaviorTree(npc: any): Promise<BehaviorNode> {
        const prompt = \`
            Create a behavior tree for this NPC:
            Name: \${npc.name}
            Role: \${npc.role}
            Personality: \${JSON.stringify(npc.personality)}
            Goals: \${JSON.stringify(npc.goals)}
            
            Behavior tree should include:
            - Selector nodes for decision making
            - Sequence nodes for actions
            - Conditions based on world state
            - Actions for daily activities
            - Combat/danger responses
            - Social interaction behaviors
            
            Return as nested JSON behavior tree.
        \`;
        
        const response = await this.llm.complete(prompt);
        return JSON.parse(response);
    }
}

// === Behavior Tree System ===
interface BehaviorNode {
    type: 'selector' | 'sequence' | 'action' | 'condition' | 'decorator';
    name: string;
    children?: BehaviorNode[];
    action?: string;
    condition?: string;
    decorator?: 'repeat' | 'invert' | 'succeed' | 'fail';
}

class BehaviorTreeExecutor {
    private blackboard: Map<string, any> = new Map();
    
    async execute(node: BehaviorNode, npc: NPCProfile): Promise<'success' | 'failure' | 'running'> {
        switch (node.type) {
            case 'selector':
                // Try children until one succeeds
                for (const child of node.children || []) {
                    const result = await this.execute(child, npc);
                    if (result === 'success' || result === 'running') {
                        return result;
                    }
                }
                return 'failure';
                
            case 'sequence':
                // Execute all children in order
                for (const child of node.children || []) {
                    const result = await this.execute(child, npc);
                    if (result === 'failure') {
                        return 'failure';
                    }
                    if (result === 'running') {
                        return 'running';
                    }
                }
                return 'success';
                
            case 'condition':
                return this.evaluateCondition(node.condition!, npc) ? 'success' : 'failure';
                
            case 'action':
                return this.executeAction(node.action!, npc);
                
            default:
                return 'failure';
        }
    }
    
    private evaluateCondition(condition: string, npc: NPCProfile): boolean {
        // Evaluate conditions like "isHungry", "playerNearby", "isNight"
        switch (condition) {
            case 'isPlayerNearby':
                return this.blackboard.get('playerDistance') < 10;
            case 'isInCombat':
                return this.blackboard.get('inCombat') === true;
            case 'isScheduledActivity':
                return this.checkSchedule(npc);
            default:
                return false;
        }
    }
}

// === AI Dialogue System ===
class NPCDialogueAI {
    async chat(npc: NPCProfile, playerMessage: string, context: DialogueContext): Promise<NPCResponse> {
        const prompt = \`
            You are roleplaying as \${npc.name}, a \${npc.role}.
            
            Personality:
            - Openness: \${npc.personality.openness}/100
            - Conscientiousness: \${npc.personality.conscientiousness}/100
            - Extraversion: \${npc.personality.extraversion}/100
            - Agreeableness: \${npc.personality.agreeableness}/100
            - Neuroticism: \${npc.personality.neuroticism}/100
            
            Backstory: \${npc.backstory}
            Current mood: \${context.mood}
            Relationship with player: \${context.relationship}/100
            Current situation: \${context.situation}
            
            The player says: "\${playerMessage}"
            
            Respond in character. Keep response under 50 words unless elaborating on lore.
            Include emotional cues in [brackets].
            
            Return JSON: { "response": "...", "emotion": "...", "relationshipChange": 0 }
        \`;
        
        const response = await this.llm.complete(prompt);
        return JSON.parse(response);
    }
}

// === Pathfinding Integration ===
class NPCPathfinding {
    generatePathfindingCode(): string {
        return \`
// A* Pathfinding for NPC navigation
class AStarPathfinder {
    private grid: number[][];
    private openSet: Set<string> = new Set();
    private closedSet: Set<string> = new Set();
    
    findPath(start: Vector2, goal: Vector2): Vector2[] {
        const frontier = new PriorityQueue<PathNode>();
        frontier.enqueue({ pos: start, g: 0, f: this.heuristic(start, goal) }, 0);
        
        const cameFrom = new Map<string, Vector2>();
        const gScore = new Map<string, number>();
        gScore.set(this.key(start), 0);
        
        while (!frontier.isEmpty()) {
            const current = frontier.dequeue()!.pos;
            
            if (this.equals(current, goal)) {
                return this.reconstructPath(cameFrom, current);
            }
            
            for (const neighbor of this.getNeighbors(current)) {
                const tentativeG = gScore.get(this.key(current))! + 1;
                
                if (tentativeG < (gScore.get(this.key(neighbor)) ?? Infinity)) {
                    cameFrom.set(this.key(neighbor), current);
                    gScore.set(this.key(neighbor), tentativeG);
                    
                    const f = tentativeG + this.heuristic(neighbor, goal);
                    frontier.enqueue({ pos: neighbor, g: tentativeG, f }, f);
                }
            }
        }
        
        return []; // No path found
    }
}
        \`;
    }
}

export { NPCGenerator, BehaviorTreeExecutor, NPCDialogueAI, NPCPathfinding };
`;
    }
}

export const intelligentNPCGenerator = IntelligentNPCGenerator.getInstance();
