/**
 * ðŸ§© LanguageDetectorService
 * 
 * Language detection:
 * - File type, framework, syntax
 */

import { EventEmitter } from 'events';

export class LanguageDetectorService extends EventEmitter {
    private static instance: LanguageDetectorService;
    private constructor() { super(); }
    static getInstance(): LanguageDetectorService {
        if (!LanguageDetectorService.instance) {
            LanguageDetectorService.instance = new LanguageDetectorService();
        }
        return LanguageDetectorService.instance;
    }

    generate(): string {
        return `// Language Detector Service - File type, framework
// Generated by Shadow AI

class LanguageDetector {
    private extensionMap: Record<string, string> = {
        '.ts': 'typescript', '.tsx': 'typescriptreact',
        '.js': 'javascript', '.jsx': 'javascriptreact',
        '.py': 'python', '.rb': 'ruby', '.go': 'go',
        '.rs': 'rust', '.java': 'java', '.kt': 'kotlin',
        '.swift': 'swift', '.cpp': 'cpp', '.c': 'c',
        '.cs': 'csharp', '.php': 'php', '.vue': 'vue',
        '.svelte': 'svelte', '.html': 'html', '.css': 'css',
        '.scss': 'scss', '.json': 'json', '.md': 'markdown',
        '.yaml': 'yaml', '.yml': 'yaml', '.sql': 'sql'
    };
    
    // Detect from file extension
    detectFromPath(filePath: string): string {
        const ext = path.extname(filePath).toLowerCase();
        return this.extensionMap[ext] || 'plaintext';
    }
    
    // Detect from content
    detectFromContent(content: string): string {
        // Check shebang
        if (content.startsWith('#!/usr/bin/env node')) return 'javascript';
        if (content.startsWith('#!/usr/bin/python')) return 'python';
        if (content.startsWith('#!/bin/bash')) return 'bash';
        
        // Check patterns
        if (/import React|from 'react'/.test(content)) return 'typescriptreact';
        if (/^package\\s+\\w+/.test(content)) return 'go';
        if (/^fn\\s+\\w+|impl\\s+\\w+/.test(content)) return 'rust';
        if (/^class.*extends.*Component/.test(content)) return 'typescript';
        
        return 'plaintext';
    }
    
    // Detect framework
    detectFramework(projectPath: string): Promise<Framework[]> {
        const detected: Framework[] = [];
        
        const pkgPath = path.join(projectPath, 'package.json');
        if (fs.existsSync(pkgPath)) {
            const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
            const deps = { ...pkg.dependencies, ...pkg.devDependencies };
            
            if (deps['next']) detected.push({ name: 'Next.js', type: 'frontend' });
            if (deps['react']) detected.push({ name: 'React', type: 'frontend' });
            if (deps['vue']) detected.push({ name: 'Vue', type: 'frontend' });
            if (deps['express']) detected.push({ name: 'Express', type: 'backend' });
            if (deps['prisma']) detected.push({ name: 'Prisma', type: 'orm' });
        }
        
        return detected;
    }
    
    // Get parser config for language
    getParserConfig(language: string): ParserConfig {
        const configs: Record<string, ParserConfig> = {
            typescript: { parser: 'typescript', plugins: ['typescript'] },
            javascript: { parser: 'babel', plugins: ['jsx'] },
            python: { parser: 'python', plugins: [] },
            json: { parser: 'json', plugins: [] }
        };
        
        return configs[language] || { parser: 'babel', plugins: [] };
    }
}

export { LanguageDetector };
`;
    }
}

export const languageDetectorService = LanguageDetectorService.getInstance();
