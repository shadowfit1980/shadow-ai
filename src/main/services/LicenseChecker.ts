/**
 * ðŸ“š License Checker
 * 
 * Open-source license compliance:
 * - Detect, validate, report license issues
 */

import { EventEmitter } from 'events';

export class LicenseChecker extends EventEmitter {
    private static instance: LicenseChecker;

    private constructor() { super(); }

    static getInstance(): LicenseChecker {
        if (!LicenseChecker.instance) {
            LicenseChecker.instance = new LicenseChecker();
        }
        return LicenseChecker.instance;
    }

    generate(): string {
        return `// License Checker
// Generated by Shadow AI

/**
 * LICENSE CHECKER
 * 
 * Automated open-source license compliance checking.
 */

interface LicenseInfo {
    package: string;
    version: string;
    license: string;
    licenseFile?: string;
    repository?: string;
    author?: string;
    compatible: boolean;
    issues: string[];
}

interface LicensePolicy {
    allowed: string[];
    forbidden: string[];
    requireAttribution: string[];
    copyleft: string[];
}

const defaultPolicy: LicensePolicy = {
    allowed: [
        'MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 
        'ISC', 'CC0-1.0', 'Unlicense', '0BSD', 'WTFPL'
    ],
    forbidden: [
        'GPL-3.0', 'AGPL-3.0', 'SSPL', 'Commons-Clause'
    ],
    requireAttribution: [
        'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause'
    ],
    copyleft: [
        'GPL-2.0', 'GPL-3.0', 'LGPL-2.1', 'LGPL-3.0', 'AGPL-3.0', 'MPL-2.0'
    ]
};

// === License Scanner ===
class LicenseScanner {
    async scanProject(projectPath: string, policy: LicensePolicy = defaultPolicy): Promise<LicenseReport> {
        const report: LicenseReport = {
            timestamp: new Date(),
            totalPackages: 0,
            compliant: 0,
            nonCompliant: 0,
            unknown: 0,
            packages: [],
            issues: [],
            attributionRequired: []
        };
        
        // Read package.json
        const packageJson = JSON.parse(
            await fs.readFile(\`\${projectPath}/package.json\`, 'utf-8')
        );
        
        const allDeps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
        
        for (const [name, version] of Object.entries(allDeps)) {
            const licenseInfo = await this.getLicenseInfo(projectPath, name);
            report.packages.push(licenseInfo);
            report.totalPackages++;
            
            if (policy.forbidden.includes(licenseInfo.license)) {
                report.nonCompliant++;
                report.issues.push({
                    package: name,
                    issue: \`Forbidden license: \${licenseInfo.license}\`,
                    severity: 'critical'
                });
            } else if (policy.allowed.includes(licenseInfo.license)) {
                report.compliant++;
                
                if (policy.requireAttribution.includes(licenseInfo.license)) {
                    report.attributionRequired.push(licenseInfo);
                }
            } else if (licenseInfo.license === 'UNKNOWN') {
                report.unknown++;
                report.issues.push({
                    package: name,
                    issue: 'Unknown license - manual review required',
                    severity: 'warning'
                });
            } else if (policy.copyleft.includes(licenseInfo.license)) {
                report.issues.push({
                    package: name,
                    issue: \`Copyleft license (\${licenseInfo.license}) - may require source disclosure\`,
                    severity: 'warning'
                });
            }
        }
        
        return report;
    }
    
    private async getLicenseInfo(projectPath: string, packageName: string): Promise<LicenseInfo> {
        try {
            const packagePath = \`\${projectPath}/node_modules/\${packageName}/package.json\`;
            const pkgJson = JSON.parse(await fs.readFile(packagePath, 'utf-8'));
            
            return {
                package: packageName,
                version: pkgJson.version,
                license: this.normalizeLicense(pkgJson.license),
                repository: pkgJson.repository?.url,
                author: typeof pkgJson.author === 'string' ? pkgJson.author : pkgJson.author?.name,
                compatible: true,
                issues: []
            };
        } catch {
            return {
                package: packageName,
                version: 'unknown',
                license: 'UNKNOWN',
                compatible: false,
                issues: ['Could not read package info']
            };
        }
    }
    
    private normalizeLicense(license: any): string {
        if (!license) return 'UNKNOWN';
        if (typeof license === 'string') return license;
        if (license.type) return license.type;
        if (Array.isArray(license)) return license.map(l => l.type || l).join(' OR ');
        return 'UNKNOWN';
    }
}

// === Attribution Generator ===
class AttributionGenerator {
    async generateNotice(packages: LicenseInfo[]): Promise<string> {
        let notice = '# Third-Party Licenses\\n\\n';
        notice += 'This project uses the following third-party packages:\\n\\n';
        
        const byLicense = this.groupByLicense(packages);
        
        for (const [license, pkgs] of Object.entries(byLicense)) {
            notice += \`## \${license}\\n\\n\`;
            
            for (const pkg of pkgs) {
                notice += \`### \${pkg.package} v\${pkg.version}\\n\\n\`;
                if (pkg.author) notice += \`Author: \${pkg.author}\\n\\n\`;
                if (pkg.repository) notice += \`Repository: \${pkg.repository}\\n\\n\`;
                notice += \`---\\n\\n\`;
            }
        }
        
        return notice;
    }
    
    async generateSBOM(packages: LicenseInfo[]): Promise<SBOM> {
        return {
            bomFormat: 'CycloneDX',
            specVersion: '1.4',
            version: 1,
            metadata: {
                timestamp: new Date().toISOString(),
                tools: [{ vendor: 'Shadow AI', name: 'LicenseChecker' }]
            },
            components: packages.map(pkg => ({
                type: 'library',
                name: pkg.package,
                version: pkg.version,
                licenses: [{ license: { id: pkg.license } }],
                purl: \`pkg:npm/\${pkg.package}@\${pkg.version}\`
            }))
        };
    }
}

// === CI Integration ===
class LicenseCICheck {
    async runCheck(projectPath: string): Promise<CIResult> {
        const scanner = new LicenseScanner();
        const report = await scanner.scanProject(projectPath);
        
        const passed = report.nonCompliant === 0 && 
                       report.issues.filter(i => i.severity === 'critical').length === 0;
        
        return {
            passed,
            exitCode: passed ? 0 : 1,
            summary: \`\${report.compliant}/\${report.totalPackages} packages compliant\`,
            details: report.issues
        };
    }
}

export { LicenseScanner, AttributionGenerator, LicenseCICheck };
`;
    }
}

export const licenseChecker = LicenseChecker.getInstance();
