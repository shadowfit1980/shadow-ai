/**
 * üåç Localization Generator
 * 
 * Full internationalization:
 * - i18n, translations, RTL, date/currency formats
 */

import { EventEmitter } from 'events';

export class LocalizationGenerator extends EventEmitter {
    private static instance: LocalizationGenerator;

    private constructor() { super(); }

    static getInstance(): LocalizationGenerator {
        if (!LocalizationGenerator.instance) {
            LocalizationGenerator.instance = new LocalizationGenerator();
        }
        return LocalizationGenerator.instance;
    }

    generate(): string {
        return `// Localization Generator
// Generated by Shadow AI

/**
 * LOCALIZATION GENERATOR
 * 
 * Complete internationalization solution with AI-powered translations.
 */

interface LocaleConfig {
    code: string;
    name: string;
    direction: 'ltr' | 'rtl';
    dateFormat: string;
    numberFormat: NumberFormatConfig;
    currencyFormat: CurrencyFormatConfig;
}

// === Translation Generator ===
class TranslationGenerator {
    async extractStrings(projectPath: string): Promise<string[]> {
        const files = await glob(\`\${projectPath}/**/*.{tsx,jsx,ts,js}\`);
        const strings = new Set<string>();
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            
            // Find t() and Trans components
            const tCalls = content.matchAll(/t\\(['"\`]([^'"\`]+)['"\`]\\)/g);
            const transComponents = content.matchAll(/<Trans[^>]*>([^<]+)<\\/Trans>/g);
            
            for (const match of tCalls) strings.add(match[1]);
            for (const match of transComponents) strings.add(match[1]);
        }
        
        return Array.from(strings);
    }
    
    async translateStrings(strings: string[], targetLocale: string): Promise<Record<string, string>> {
        const translations: Record<string, string> = {};
        
        const prompt = \`
            Translate these strings to \${targetLocale}:
            \${JSON.stringify(strings)}
            
            Requirements:
            - Preserve placeholders like {{name}} or {0}
            - Use natural, contextual translations
            - Match the formality level of the source
            
            Return as JSON: { "source": "translation", ... }
        \`;
        
        const response = await this.llm.complete(prompt);
        return JSON.parse(response);
    }
    
    generateLocaleFile(translations: Record<string, string>, locale: string): string {
        return \`
// \${locale} translations - Generated by Shadow AI
export default {
\${Object.entries(translations).map(([key, value]) => \`  "\${key}": "\${value}"\`).join(',\\n')}
};
        \`;
    }
}

// === i18n Setup Generator ===
class I18nSetupGenerator {
    generateReactI18next(): string {
        return \`
// i18n Configuration - Generated by Shadow AI
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

// Import translations
import en from './locales/en.json';
import es from './locales/es.json';
import fr from './locales/fr.json';
import ar from './locales/ar.json';
import zh from './locales/zh.json';
import ja from './locales/ja.json';

const resources = {
    en: { translation: en },
    es: { translation: es },
    fr: { translation: fr },
    ar: { translation: ar },
    zh: { translation: zh },
    ja: { translation: ja }
};

i18n
    .use(Backend)
    .use(LanguageDetector)
    .use(initReactI18next)
    .init({
        resources,
        fallbackLng: 'en',
        debug: process.env.NODE_ENV === 'development',
        interpolation: {
            escapeValue: false
        },
        detection: {
            order: ['localStorage', 'navigator', 'htmlTag'],
            caches: ['localStorage']
        }
    });

export default i18n;
        \`;
    }
    
    generateLanguageSwitcher(): string {
        return \`
// Language Switcher Component - Generated by Shadow AI
import { useTranslation } from 'react-i18next';

const languages = [
    { code: 'en', name: 'English', flag: 'üá∫üá∏' },
    { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' },
    { code: 'fr', name: 'Fran√ßais', flag: 'üá´üá∑' },
    { code: 'ar', name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶', rtl: true },
    { code: 'zh', name: '‰∏≠Êñá', flag: 'üá®üá≥' },
    { code: 'ja', name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ' }
];

export function LanguageSwitcher() {
    const { i18n } = useTranslation();
    
    const handleChange = (code: string) => {
        i18n.changeLanguage(code);
        
        // Update document direction for RTL languages
        const isRTL = languages.find(l => l.code === code)?.rtl;
        document.documentElement.dir = isRTL ? 'rtl' : 'ltr';
    };
    
    return (
        <select 
            value={i18n.language} 
            onChange={(e) => handleChange(e.target.value)}
            className="language-select"
        >
            {languages.map(lang => (
                <option key={lang.code} value={lang.code}>
                    {lang.flag} {lang.name}
                </option>
            ))}
        </select>
    );
}
        \`;
    }
}

// === Format Generators ===
class FormatGenerator {
    generateDateFormatter(): string {
        return \`
// Date Formatter - Generated by Shadow AI
import { format, formatDistance, formatRelative } from 'date-fns';
import { enUS, es, fr, ar, zhCN, ja } from 'date-fns/locale';

const locales = { en: enUS, es, fr, ar, zh: zhCN, ja };

export function formatDate(date: Date, pattern: string, locale = 'en'): string {
    return format(date, pattern, { locale: locales[locale] });
}

export function formatRelativeDate(date: Date, locale = 'en'): string {
    return formatDistance(date, new Date(), { 
        addSuffix: true, 
        locale: locales[locale] 
    });
}

export function formatLocalDate(date: Date, locale = 'en'): string {
    const patterns = {
        en: 'MMMM d, yyyy',
        es: 'd \\\'de\\\' MMMM \\\'de\\\' yyyy',
        fr: 'd MMMM yyyy',
        ar: 'd MMMM yyyy',
        zh: 'yyyyÂπ¥MÊúàdÊó•',
        ja: 'yyyyÂπ¥MÊúàdÊó•'
    };
    return formatDate(date, patterns[locale], locale);
}
        \`;
    }
    
    generateCurrencyFormatter(): string {
        return \`
// Currency Formatter - Generated by Shadow AI
export function formatCurrency(
    amount: number, 
    currency: string, 
    locale = 'en-US'
): string {
    return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency,
        minimumFractionDigits: 2
    }).format(amount);
}

export function formatCompactCurrency(
    amount: number, 
    currency: string, 
    locale = 'en-US'
): string {
    return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency,
        notation: 'compact',
        compactDisplay: 'short'
    }).format(amount);
}

// Example usage:
// formatCurrency(1234.56, 'USD') => '$1,234.56'
// formatCurrency(1234.56, 'EUR', 'de-DE') => '1.234,56 ‚Ç¨'
// formatCompactCurrency(1234567, 'USD') => '$1.2M'
        \`;
    }
}

export { TranslationGenerator, I18nSetupGenerator, FormatGenerator };
`;
    }
}

export const localizationGenerator = LocalizationGenerator.getInstance();
