/**
 * ðŸ“Š Logging Pipeline Generator
 * 
 * Generate logging systems:
 * - Structured logging, ELK
 */

import { EventEmitter } from 'events';

export class LoggingPipeline extends EventEmitter {
    private static instance: LoggingPipeline;

    private constructor() { super(); }

    static getInstance(): LoggingPipeline {
        if (!LoggingPipeline.instance) {
            LoggingPipeline.instance = new LoggingPipeline();
        }
        return LoggingPipeline.instance;
    }

    generate(): string {
        return `// Logging Pipeline
// Generated by Shadow AI

import pino from 'pino';
import { AsyncLocalStorage } from 'async_hooks';

// Request context storage
const requestContext = new AsyncLocalStorage<Map<string, any>>();

// Base logger
const baseLogger = pino({
    level: process.env.LOG_LEVEL || 'info',
    formatters: {
        level: (label) => ({ level: label }),
        bindings: (bindings) => ({
            pid: bindings.pid,
            host: bindings.hostname,
            service: process.env.SERVICE_NAME || 'app',
            version: process.env.APP_VERSION || '1.0.0',
            environment: process.env.NODE_ENV || 'development'
        })
    },
    timestamp: () => \`,"timestamp":"\${new Date().toISOString()}"\`,
    redact: ['password', 'token', 'authorization', 'cookie', 'creditCard']
});

// Context-aware logger
const logger = {
    _getContext() {
        const store = requestContext.getStore();
        return store ? Object.fromEntries(store) : {};
    },

    child(bindings: Record<string, any>) {
        return baseLogger.child({ ...this._getContext(), ...bindings });
    },

    trace(msg: string, data?: Record<string, any>) {
        baseLogger.trace({ ...this._getContext(), ...data }, msg);
    },
    
    debug(msg: string, data?: Record<string, any>) {
        baseLogger.debug({ ...this._getContext(), ...data }, msg);
    },
    
    info(msg: string, data?: Record<string, any>) {
        baseLogger.info({ ...this._getContext(), ...data }, msg);
    },
    
    warn(msg: string, data?: Record<string, any>) {
        baseLogger.warn({ ...this._getContext(), ...data }, msg);
    },
    
    error(msg: string, error?: Error | Record<string, any>) {
        if (error instanceof Error) {
            baseLogger.error({
                ...this._getContext(),
                error: {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                }
            }, msg);
        } else {
            baseLogger.error({ ...this._getContext(), ...error }, msg);
        }
    },
    
    fatal(msg: string, error?: Error | Record<string, any>) {
        if (error instanceof Error) {
            baseLogger.fatal({
                ...this._getContext(),
                error: {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                }
            }, msg);
        } else {
            baseLogger.fatal({ ...this._getContext(), ...error }, msg);
        }
    }
};

// Express middleware
function requestLoggerMiddleware(req, res, next) {
    const requestId = req.headers['x-request-id'] || crypto.randomUUID();
    const startTime = Date.now();

    // Set up context
    const store = new Map<string, any>();
    store.set('requestId', requestId);
    store.set('method', req.method);
    store.set('path', req.path);
    store.set('userAgent', req.headers['user-agent']);
    store.set('ip', req.ip);

    // Add request ID to response
    res.setHeader('x-request-id', requestId);

    // Log request
    logger.info('Request started', { query: req.query });

    // Log response
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        const level = res.statusCode >= 500 ? 'error' : res.statusCode >= 400 ? 'warn' : 'info';
        
        logger[level]('Request completed', {
            statusCode: res.statusCode,
            duration,
            contentLength: res.get('content-length')
        });
    });

    requestContext.run(store, () => next());
}

// Logstash transport (for ELK)
const logstashTransport = pino.transport({
    target: 'pino-socket',
    options: {
        address: process.env.LOGSTASH_HOST || 'localhost',
        port: parseInt(process.env.LOGSTASH_PORT || '5000'),
        mode: 'tcp'
    }
});

// File transport with rotation
const fileTransport = pino.transport({
    targets: [
        {
            target: 'pino/file',
            options: { destination: './logs/app.log' },
            level: 'info'
        },
        {
            target: 'pino/file',
            options: { destination: './logs/error.log' },
            level: 'error'
        }
    ]
});

// Query logging for databases
function createQueryLogger(dbName: string) {
    return {
        logQuery(query: string, params: any[], duration: number) {
            logger.debug('Database query', {
                database: dbName,
                query: query.slice(0, 500),
                params: params.length,
                duration
            });
        }
    };
}

// Performance logging
function logPerformance(operation: string, fn: () => Promise<any>) {
    return async (...args: any[]) => {
        const start = performance.now();
        try {
            const result = await fn(...args);
            logger.debug('Operation completed', {
                operation,
                duration: Math.round(performance.now() - start)
            });
            return result;
        } catch (error) {
            logger.error('Operation failed', {
                operation,
                duration: Math.round(performance.now() - start),
                error
            });
            throw error;
        }
    };
}

export { logger, requestLoggerMiddleware, requestContext, createQueryLogger, logPerformance };
`;
    }
}

export const loggingPipeline = LoggingPipeline.getInstance();
