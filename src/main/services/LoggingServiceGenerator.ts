/**
 * ðŸ“Š LoggingServiceGenerator
 * 
 * Structured logging:
 * - Winston, Pino, log aggregation
 */

import { EventEmitter } from 'events';

export class LoggingServiceGenerator extends EventEmitter {
    private static instance: LoggingServiceGenerator;
    private constructor() { super(); }
    static getInstance(): LoggingServiceGenerator {
        if (!LoggingServiceGenerator.instance) {
            LoggingServiceGenerator.instance = new LoggingServiceGenerator();
        }
        return LoggingServiceGenerator.instance;
    }

    generate(): string {
        return `// Logging Service Generator - Winston, Pino, log aggregation
// Generated by Shadow AI

import pino from 'pino';
import pinoHttp from 'pino-http';

// Pino Logger Setup
const logger = pino({
    level: process.env.LOG_LEVEL || 'info',
    formatters: {
        level: (label) => ({ level: label }),
        bindings: (bindings) => ({
            pid: bindings.pid,
            hostname: bindings.hostname,
            service: process.env.SERVICE_NAME || 'app'
        })
    },
    timestamp: pino.stdTimeFunctions.isoTime,
    redact: ['password', 'token', 'authorization', 'cookie']
});

// HTTP Logger Middleware
const httpLogger = pinoHttp({
    logger,
    customLogLevel: (req, res, err) => {
        if (res.statusCode >= 500 || err) return 'error';
        if (res.statusCode >= 400) return 'warn';
        return 'info';
    },
    customSuccessMessage: (req, res) => {
        return \`\${req.method} \${req.url} \${res.statusCode}\`;
    },
    customErrorMessage: (req, res, err) => {
        return \`\${req.method} \${req.url} \${res.statusCode} - \${err.message}\`;
    }
});

// Child Logger Factory
function createLogger(context: Record<string, any>) {
    return logger.child(context);
}

// Log Levels
const log = {
    debug: (msg: string, data?: any) => logger.debug(data, msg),
    info: (msg: string, data?: any) => logger.info(data, msg),
    warn: (msg: string, data?: any) => logger.warn(data, msg),
    error: (msg: string, error?: Error, data?: any) => {
        logger.error({ ...data, err: error }, msg);
    },
    fatal: (msg: string, error?: Error) => logger.fatal({ err: error }, msg)
};

// Request Context Logger
class RequestLogger {
    private requestId: string;
    private userId?: string;
    
    constructor(requestId: string, userId?: string) {
        this.requestId = requestId;
        this.userId = userId;
    }
    
    private context() {
        return { requestId: this.requestId, userId: this.userId };
    }
    
    info(msg: string, data?: any) {
        logger.info({ ...this.context(), ...data }, msg);
    }
    
    warn(msg: string, data?: any) {
        logger.warn({ ...this.context(), ...data }, msg);
    }
    
    error(msg: string, error?: Error, data?: any) {
        logger.error({ ...this.context(), ...data, err: error }, msg);
    }
}

// Performance Logging
function logPerformance(label: string, fn: () => Promise<any>) {
    return async () => {
        const start = performance.now();
        try {
            const result = await fn();
            const duration = performance.now() - start;
            logger.info({ label, durationMs: duration }, 'Performance');
            return result;
        } catch (error) {
            const duration = performance.now() - start;
            logger.error({ label, durationMs: duration, err: error }, 'Performance (failed)');
            throw error;
        }
    };
}

export { logger, httpLogger, createLogger, log, RequestLogger, logPerformance };
`;
    }
}

export const loggingServiceGenerator = LoggingServiceGenerator.getInstance();
