/**
 * ðŸ“Š MetricsCollector
 * 
 * Business metrics:
 * - KPIs, revenue, growth tracking
 */

import { EventEmitter } from 'events';

export class MetricsCollector extends EventEmitter {
    private static instance: MetricsCollector;
    private constructor() { super(); }
    static getInstance(): MetricsCollector {
        if (!MetricsCollector.instance) {
            MetricsCollector.instance = new MetricsCollector();
        }
        return MetricsCollector.instance;
    }

    generate(): string {
        return `// Metrics Collector - KPIs, revenue, growth tracking
// Generated by Shadow AI

// Business Metrics Service
class BusinessMetricsService {
    async getMRR(date: Date = new Date()) {
        const startOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
        const endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);
        
        const activeSubscriptions = await prisma.subscription.findMany({
            where: {
                status: 'ACTIVE',
                currentPeriodStart: { lte: endOfMonth },
                currentPeriodEnd: { gte: startOfMonth }
            },
            include: { plan: true }
        });
        
        return activeSubscriptions.reduce((sum, sub) => sum + sub.plan.price, 0);
    }
    
    async getARR() {
        const mrr = await this.getMRR();
        return mrr * 12;
    }
    
    async getChurnRate(period: { start: Date; end: Date }) {
        const startingCustomers = await prisma.subscription.count({
            where: { createdAt: { lt: period.start }, status: 'ACTIVE' }
        });
        
        const churned = await prisma.subscription.count({
            where: {
                canceledAt: { gte: period.start, lte: period.end }
            }
        });
        
        return startingCustomers > 0 ? (churned / startingCustomers) * 100 : 0;
    }
    
    async getCustomerLifetimeValue() {
        const avgRevenue = await prisma.payment.aggregate({
            _avg: { amount: true }
        });
        
        const avgLifespan = await this.calculateAverageCustomerLifespan();
        
        return (avgRevenue._avg.amount || 0) * avgLifespan;
    }
    
    async getCustomerAcquisitionCost() {
        const marketingSpend = await prisma.expense.aggregate({
            where: { category: 'marketing', date: { gte: subMonths(new Date(), 1) } },
            _sum: { amount: true }
        });
        
        const newCustomers = await prisma.user.count({
            where: { createdAt: { gte: subMonths(new Date(), 1) } }
        });
        
        return newCustomers > 0 ? (marketingSpend._sum.amount || 0) / newCustomers : 0;
    }
    
    async getDashboardMetrics() {
        const [mrr, arr, churnRate, ltv, cac] = await Promise.all([
            this.getMRR(),
            this.getARR(),
            this.getChurnRate({ start: subMonths(new Date(), 1), end: new Date() }),
            this.getCustomerLifetimeValue(),
            this.getCustomerAcquisitionCost()
        ]);
        
        return {
            mrr,
            arr,
            churnRate,
            ltv,
            cac,
            ltvCacRatio: cac > 0 ? ltv / cac : 0
        };
    }
    
    async getGrowthMetrics() {
        const currentMRR = await this.getMRR();
        const previousMRR = await this.getMRR(subMonths(new Date(), 1));
        
        return {
            mrrGrowth: previousMRR > 0 ? ((currentMRR - previousMRR) / previousMRR) * 100 : 0,
            currentMRR,
            previousMRR
        };
    }
}

// Revenue Chart Data
async function getRevenueChartData(months: number = 12) {
    const data = [];
    
    for (let i = months - 1; i >= 0; i--) {
        const date = subMonths(new Date(), i);
        const mrr = await new BusinessMetricsService().getMRR(date);
        
        data.push({
            month: format(date, 'MMM yyyy'),
            mrr
        });
    }
    
    return data;
}

export { BusinessMetricsService, getRevenueChartData };
`;
    }
}

export const metricsCollector = MetricsCollector.getInstance();
