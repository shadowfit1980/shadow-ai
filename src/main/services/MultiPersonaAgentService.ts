/**
 * ðŸŽ­ MultiPersonaAgentService
 * 
 * Agent with multiple personalities:
 * - Expert personas for different domains
 */

import { EventEmitter } from 'events';

export class MultiPersonaAgentService extends EventEmitter {
    private static instance: MultiPersonaAgentService;
    private constructor() { super(); }
    static getInstance(): MultiPersonaAgentService {
        if (!MultiPersonaAgentService.instance) {
            MultiPersonaAgentService.instance = new MultiPersonaAgentService();
        }
        return MultiPersonaAgentService.instance;
    }

    generate(): string {
        return `// Multi-Persona Agent Service - Expert personas
// Generated by Shadow AI

interface Persona {
    id: string;
    name: string;
    role: string;
    expertise: string[];
    systemPrompt: string;
    communicationStyle: 'formal' | 'casual' | 'technical' | 'mentoring';
    temperature: number;
}

class MultiPersonaAgent {
    private personas: Map<string, Persona> = new Map();
    private activePersona: string | null = null;
    
    constructor() {
        // Pre-built personas
        this.registerBuiltInPersonas();
    }
    
    private registerBuiltInPersonas(): void {
        const builtIn: Persona[] = [
            {
                id: 'architect',
                name: 'Alex the Architect',
                role: 'Senior Software Architect',
                expertise: ['system design', 'microservices', 'scalability', 'patterns'],
                systemPrompt: 'You are Alex, a senior software architect with 20 years of experience. Focus on high-level design, scalability, and maintainability. Question any design decisions that could lead to tech debt.',
                communicationStyle: 'technical',
                temperature: 0.3
            },
            {
                id: 'security',
                name: 'Sam Security',
                role: 'Security Engineer',
                expertise: ['security', 'penetration testing', 'compliance', 'encryption'],
                systemPrompt: 'You are Sam, a paranoid security engineer. Always look for vulnerabilities, suggest hardening, and question any code that handles sensitive data.',
                communicationStyle: 'formal',
                temperature: 0.2
            },
            {
                id: 'mentor',
                name: 'Maya Mentor',
                role: 'Engineering Mentor',
                expertise: ['teaching', 'code review', 'best practices', 'growth'],
                systemPrompt: 'You are Maya, a patient engineering mentor. Explain concepts clearly, encourage learning, and help developers grow. Never make anyone feel bad for not knowing something.',
                communicationStyle: 'mentoring',
                temperature: 0.5
            },
            {
                id: 'devops',
                name: 'Dylan DevOps',
                role: 'DevOps Engineer',
                expertise: ['CI/CD', 'kubernetes', 'terraform', 'monitoring'],
                systemPrompt: 'You are Dylan, a DevOps engineer obsessed with automation. Suggest infrastructure as code, CI/CD improvements, and monitoring for everything.',
                communicationStyle: 'casual',
                temperature: 0.4
            },
            {
                id: 'ux',
                name: 'Uma UX',
                role: 'UX Engineer',
                expertise: ['user experience', 'accessibility', 'design systems', 'testing'],
                systemPrompt: 'You are Uma, a UX engineer who advocates for users. Question any design that might confuse users or exclude people with disabilities.',
                communicationStyle: 'casual',
                temperature: 0.6
            },
            {
                id: 'performance',
                name: 'Perry Performance',
                role: 'Performance Engineer',
                expertise: ['optimization', 'profiling', 'caching', 'algorithms'],
                systemPrompt: 'You are Perry, a performance engineer who hates slow code. Always suggest optimizations, question complexity, and benchmark everything.',
                communicationStyle: 'technical',
                temperature: 0.3
            }
        ];
        
        for (const persona of builtIn) {
            this.personas.set(persona.id, persona);
        }
    }
    
    // Register custom persona
    registerPersona(persona: Omit<Persona, 'id'>): string {
        const id = crypto.randomUUID();
        this.personas.set(id, { ...persona, id });
        return id;
    }
    
    // Switch to persona
    switchPersona(personaId: string): void {
        if (!this.personas.has(personaId)) {
            throw new Error('Persona not found');
        }
        this.activePersona = personaId;
        this.emit('persona-switched', { personaId });
    }
    
    // Get response from persona
    async askPersona(personaId: string, message: string, context?: any): Promise<string> {
        const persona = this.personas.get(personaId);
        if (!persona) throw new Error('Persona not found');
        
        const response = await llm.chat([{
            role: 'system',
            content: persona.systemPrompt
        }, {
            role: 'user',
            content: context ? \`Context: \${JSON.stringify(context)}\n\nQuestion: \${message}\` : message
        }], { temperature: persona.temperature });
        
        return response.content;
    }
    
    // Get multi-persona review
    async multiPersonaReview(code: string, personas: string[] = ['architect', 'security', 'performance']): Promise<MultiReview> {
        const reviews: Record<string, string> = {};
        
        for (const personaId of personas) {
            reviews[personaId] = await this.askPersona(personaId, 'Review this code from your perspective.', { code });
        }
        
        // Synthesize into unified review
        const synthesis = await llm.chat([{
            role: 'system',
            content: 'Synthesize these expert reviews into one cohesive code review with prioritized action items.'
        }, {
            role: 'user',
            content: JSON.stringify(reviews)
        }]);
        
        return {
            individualReviews: reviews,
            synthesis: synthesis.content,
            actionItems: await this.extractActionItems(synthesis.content)
        };
    }
    
    // Auto-select persona based on context
    async autoSelectPersona(context: string): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Select the best persona for this task. Available: \${Array.from(this.personas.values()).map(p => \`\${p.id}: \${p.role}\`).join(', ')}\n\nReturn only the persona ID.\`
        }, {
            role: 'user',
            content: context
        }]);
        
        return response.content.trim();
    }
    
    // Get all personas
    getPersonas(): Persona[] {
        return Array.from(this.personas.values());
    }
    
    // Get active persona
    getActivePersona(): Persona | null {
        return this.activePersona ? this.personas.get(this.activePersona) || null : null;
    }
    
    private async extractActionItems(review: string): Promise<string[]> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Extract actionable items from this review. Return JSON array of strings.'
        }, {
            role: 'user',
            content: review
        }]);
        
        return JSON.parse(response.content);
    }
}

export { MultiPersonaAgent };
`;
    }
}

export const multiPersonaAgentService = MultiPersonaAgentService.getInstance();
