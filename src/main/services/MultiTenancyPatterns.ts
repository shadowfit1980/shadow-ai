/**
 * ðŸ¢ Multi-Tenancy Patterns
 * 
 * Generate SaaS patterns:
 * - Database, schema, row-level
 */

import { EventEmitter } from 'events';

export class MultiTenancyPatterns extends EventEmitter {
    private static instance: MultiTenancyPatterns;

    private constructor() { super(); }

    static getInstance(): MultiTenancyPatterns {
        if (!MultiTenancyPatterns.instance) {
            MultiTenancyPatterns.instance = new MultiTenancyPatterns();
        }
        return MultiTenancyPatterns.instance;
    }

    generate(): string {
        return `// Multi-Tenancy Patterns
// Generated by Shadow AI

// === Row-Level Security (Recommended for most SaaS) ===
import { PrismaClient } from '@prisma/client';

// Prisma middleware for automatic tenant filtering
function createTenantPrisma(tenantId: string) {
    const prisma = new PrismaClient();

    prisma.$use(async (params, next) => {
        // Models that require tenant isolation
        const tenantModels = ['Project', 'Document', 'Team', 'Invoice'];

        if (tenantModels.includes(params.model || '')) {
            // Inject tenantId on create
            if (params.action === 'create') {
                params.args.data.tenantId = tenantId;
            }
            if (params.action === 'createMany') {
                params.args.data = params.args.data.map((d: any) => ({ ...d, tenantId }));
            }

            // Add where clause for reads/updates/deletes
            if (['findUnique', 'findFirst', 'findMany', 'update', 'updateMany', 'delete', 'deleteMany'].includes(params.action)) {
                params.args.where = { ...params.args.where, tenantId };
            }
        }

        return next(params);
    });

    return prisma;
}

// Express middleware
function tenantMiddleware(req, res, next) {
    // Get tenant from subdomain, header, or JWT
    const tenantId = req.headers['x-tenant-id'] ||
                     req.subdomains[0] ||
                     req.user?.tenantId;

    if (!tenantId) {
        return res.status(400).json({ error: 'Tenant ID required' });
    }

    req.tenantId = tenantId;
    req.prisma = createTenantPrisma(tenantId);

    next();
}

// === Schema-per-Tenant (PostgreSQL) ===
async function createTenantSchema(tenantId: string) {
    const schemaName = \`tenant_\${tenantId.replace(/-/g, '_')}\`;
    
    await prisma.$executeRawUnsafe(\`CREATE SCHEMA IF NOT EXISTS "\${schemaName}"\`);
    
    // Run migrations for the new schema
    await prisma.$executeRawUnsafe(\`
        SET search_path TO "\${schemaName}";
        -- Your table creation SQL here
        CREATE TABLE IF NOT EXISTS projects (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            name VARCHAR(255) NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
    \`);
    
    return schemaName;
}

function createSchemaPrisma(tenantId: string) {
    const schemaName = \`tenant_\${tenantId.replace(/-/g, '_')}\`;
    
    return new PrismaClient({
        datasources: {
            db: {
                url: \`\${process.env.DATABASE_URL}?schema=\${schemaName}\`
            }
        }
    });
}

// === Tenant Management ===
interface Tenant {
    id: string;
    name: string;
    slug: string;
    plan: 'free' | 'pro' | 'enterprise';
    settings: Record<string, any>;
    createdAt: Date;
}

class TenantService {
    async create(data: { name: string; slug: string; ownerId: string }) {
        const tenant = await prisma.tenant.create({
            data: {
                name: data.name,
                slug: data.slug.toLowerCase(),
                plan: 'free',
                settings: { maxUsers: 5, features: [] },
                members: {
                    create: { userId: data.ownerId, role: 'OWNER' }
                }
            }
        });

        // Create tenant-specific resources
        await this.provisionTenant(tenant.id);
        
        return tenant;
    }

    async provisionTenant(tenantId: string) {
        // Create default resources, send welcome email, etc.
        await createDefaultProject(tenantId);
        await sendWelcomeEmail(tenantId);
    }

    async getBySlug(slug: string) {
        return prisma.tenant.findUnique({
            where: { slug },
            include: { members: { include: { user: true } } }
        });
    }

    async updatePlan(tenantId: string, plan: Tenant['plan']) {
        const limits = {
            free: { maxUsers: 5, maxStorage: 1024 * 1024 * 100 },
            pro: { maxUsers: 50, maxStorage: 1024 * 1024 * 1024 * 10 },
            enterprise: { maxUsers: -1, maxStorage: -1 }
        };

        return prisma.tenant.update({
            where: { id: tenantId },
            data: { plan, settings: { ...limits[plan] } }
        });
    }

    async addMember(tenantId: string, userId: string, role: 'ADMIN' | 'MEMBER') {
        const tenant = await prisma.tenant.findUnique({ where: { id: tenantId }, include: { members: true } });
        const limits = tenant?.settings as any;

        if (limits.maxUsers > 0 && tenant!.members.length >= limits.maxUsers) {
            throw new Error('Member limit reached. Upgrade your plan.');
        }

        return prisma.tenantMember.create({
            data: { tenantId, userId, role }
        });
    }
}

// === Tenant Context Hook ===
const TenantContext = createContext<{ tenant: Tenant; isLoading: boolean } | null>(null);

function TenantProvider({ children }) {
    const [tenant, setTenant] = useState<Tenant | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        const slug = window.location.hostname.split('.')[0];
        
        fetch(\`/api/tenants/\${slug}\`)
            .then(res => res.json())
            .then(setTenant)
            .finally(() => setIsLoading(false));
    }, []);

    if (isLoading) return <Loading />;
    if (!tenant) return <TenantNotFound />;

    return (
        <TenantContext.Provider value={{ tenant, isLoading }}>
            {children}
        </TenantContext.Provider>
    );
}

function useTenant() {
    const context = useContext(TenantContext);
    if (!context) throw new Error('useTenant must be used within TenantProvider');
    return context;
}

export { createTenantPrisma, tenantMiddleware, createTenantSchema, TenantService, TenantProvider, useTenant };
`;
    }
}

export const multiTenancyPatterns = MultiTenancyPatterns.getInstance();
