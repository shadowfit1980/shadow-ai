/**
 * üîé Natural Language Code Search
 * 
 * Ask questions about code:
 * - Semantic search, context-aware results
 */

import { EventEmitter } from 'events';

export class NaturalLanguageCodeSearch extends EventEmitter {
    private static instance: NaturalLanguageCodeSearch;

    private constructor() { super(); }

    static getInstance(): NaturalLanguageCodeSearch {
        if (!NaturalLanguageCodeSearch.instance) {
            NaturalLanguageCodeSearch.instance = new NaturalLanguageCodeSearch();
        }
        return NaturalLanguageCodeSearch.instance;
    }

    generate(): string {
        return `// Natural Language Code Search
// Generated by Shadow AI

/**
 * NATURAL LANGUAGE CODE SEARCH
 * 
 * Ask questions about your codebase in plain English:
 * - "Show me all React components that use Redux"
 * - "Find all API endpoints that return user data"
 * - "Where is the authentication logic?"
 */

// === Vector Store for Code Embeddings ===
interface CodeChunk {
    id: string;
    file: string;
    startLine: number;
    endLine: number;
    content: string;
    type: 'function' | 'class' | 'component' | 'hook' | 'api' | 'config';
    embedding?: number[];
}

class CodeVectorStore {
    private chunks: CodeChunk[] = [];
    private embeddings: Map<string, number[]> = new Map();
    
    async indexProject(projectPath: string): Promise<void> {
        console.log('üîç Indexing codebase...');
        
        const files = await glob(\`\${projectPath}/**/*.{ts,tsx,js,jsx}\`, {
            ignore: ['**/node_modules/**', '**/dist/**']
        });
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            const fileChunks = this.chunkFile(file, content);
            
            for (const chunk of fileChunks) {
                const embedding = await this.generateEmbedding(chunk.content);
                chunk.embedding = embedding;
                this.chunks.push(chunk);
                this.embeddings.set(chunk.id, embedding);
            }
        }
        
        console.log(\`Indexed \${this.chunks.length} code chunks\`);
    }
    
    private chunkFile(file: string, content: string): CodeChunk[] {
        const chunks: CodeChunk[] = [];
        const lines = content.split('\\n');
        
        // Parse AST to find logical chunks
        const ast = parse(content, { sourceType: 'module', plugins: ['typescript', 'jsx'] });
        
        traverse(ast, {
            FunctionDeclaration(path) {
                chunks.push({
                    id: \`\${file}:\${path.node.loc?.start.line}\`,
                    file,
                    startLine: path.node.loc?.start.line || 0,
                    endLine: path.node.loc?.end.line || 0,
                    content: content.slice(path.node.start!, path.node.end!),
                    type: 'function'
                });
            },
            ClassDeclaration(path) {
                chunks.push({
                    id: \`\${file}:\${path.node.loc?.start.line}\`,
                    file,
                    startLine: path.node.loc?.start.line || 0,
                    endLine: path.node.loc?.end.line || 0,
                    content: content.slice(path.node.start!, path.node.end!),
                    type: 'class'
                });
            },
            // ... more visitors
        });
        
        return chunks;
    }
    
    private async generateEmbedding(text: string): Promise<number[]> {
        const response = await openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: text
        });
        return response.data[0].embedding;
    }
    
    async search(query: string, limit = 10): Promise<SearchResult[]> {
        const queryEmbedding = await this.generateEmbedding(query);
        
        const results = this.chunks.map(chunk => ({
            chunk,
            similarity: this.cosineSimilarity(queryEmbedding, chunk.embedding!)
        }));
        
        return results
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, limit)
            .map(r => ({
                file: r.chunk.file,
                startLine: r.chunk.startLine,
                endLine: r.chunk.endLine,
                content: r.chunk.content,
                type: r.chunk.type,
                relevance: r.similarity
            }));
    }
    
    private cosineSimilarity(a: number[], b: number[]): number {
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        return dotProduct / (magnitudeA * magnitudeB);
    }
}

// === Natural Language Query Processor ===
class QueryProcessor {
    private vectorStore: CodeVectorStore;
    private llm: LLMProvider;
    
    async query(question: string): Promise<QueryResponse> {
        // Step 1: Classify the query type
        const queryType = await this.classifyQuery(question);
        
        // Step 2: Search for relevant code
        const searchResults = await this.vectorStore.search(question, 20);
        
        // Step 3: Generate answer with context
        const answer = await this.generateAnswer(question, searchResults);
        
        return {
            question,
            queryType,
            answer,
            codeReferences: searchResults.slice(0, 5),
            relatedQuestions: await this.suggestRelatedQuestions(question)
        };
    }
    
    private async classifyQuery(question: string): Promise<QueryType> {
        const prompt = \`
            Classify this code search query:
            "\${question}"
            
            Types:
            - find: Looking for specific code/files
            - explain: Wants understanding of code
            - howto: Wants to know how to do something
            - debug: Looking for bug source
            - refactor: Wants improvement suggestions
            
            Return just the type.
        \`;
        
        const response = await this.llm.complete(prompt);
        return response.trim() as QueryType;
    }
    
    private async generateAnswer(question: string, context: SearchResult[]): Promise<string> {
        const contextStr = context.map(r => 
            \`// File: \${r.file} (lines \${r.startLine}-\${r.endLine})\\n\${r.content}\`
        ).join('\\n\\n');
        
        const prompt = \`
            Answer this question about the codebase:
            "\${question}"
            
            Relevant code context:
            \${contextStr}
            
            Provide a clear, helpful answer with code references.
        \`;
        
        return await this.llm.complete(prompt);
    }
}

// === Example Queries ===
const exampleQueries = [
    "Show me all React components that use Redux",
    "Find all API endpoints that return user data",
    "Where is the authentication logic?",
    "What functions call the database?",
    "Show me how errors are handled",
    "Find all usages of the User model",
    "What middleware is applied to routes?",
    "Show me the payment processing code"
];

export { CodeVectorStore, QueryProcessor, exampleQueries };
`;
    }
}

export const naturalLanguageCodeSearch = NaturalLanguageCodeSearch.getInstance();
