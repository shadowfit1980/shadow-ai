/**
 * ðŸ§  Neural Code Search
 * 
 * AI-powered semantic code search:
 * - Understand intent, not just keywords
 */

import { EventEmitter } from 'events';

export class NeuralCodeSearch extends EventEmitter {
    private static instance: NeuralCodeSearch;

    private constructor() { super(); }

    static getInstance(): NeuralCodeSearch {
        if (!NeuralCodeSearch.instance) {
            NeuralCodeSearch.instance = new NeuralCodeSearch();
        }
        return NeuralCodeSearch.instance;
    }

    generate(): string {
        return `// Neural Code Search
// Generated by Shadow AI

/**
 * NEURAL CODE SEARCH
 * 
 * AI-powered semantic code search that understands intent.
 * Finds code by meaning, not just patterns.
 */

interface SearchResult {
    file: string;
    startLine: number;
    endLine: number;
    code: string;
    relevance: number;
    explanation: string;
    type: 'exact' | 'semantic' | 'similar';
}

// === Embedding Index ===
class CodeEmbeddingIndex {
    private embeddings: Map<string, Float32Array> = new Map();
    private chunks: Map<string, CodeChunk> = new Map();
    
    async indexCodebase(projectPath: string): Promise<void> {
        console.log('ðŸ§  Building neural code index...');
        
        const files = await glob(\`\${projectPath}/**/*.{ts,tsx,js,jsx,py}\`);
        let totalChunks = 0;
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            const chunks = this.chunkCode(file, content);
            
            for (const chunk of chunks) {
                const embedding = await this.generateEmbedding(chunk.code);
                this.embeddings.set(chunk.id, embedding);
                this.chunks.set(chunk.id, chunk);
                totalChunks++;
            }
        }
        
        console.log(\`Indexed \${totalChunks} code chunks\`);
    }
    
    private chunkCode(file: string, content: string): CodeChunk[] {
        const chunks: CodeChunk[] = [];
        
        // Parse AST to find logical chunks
        const ast = parse(content, { 
            sourceType: 'module', 
            plugins: ['typescript', 'jsx'] 
        });
        
        traverse(ast, {
            FunctionDeclaration: (path) => this.addChunk(chunks, file, path, 'function'),
            ClassDeclaration: (path) => this.addChunk(chunks, file, path, 'class'),
            ArrowFunctionExpression: (path) => {
                if (path.parent.type === 'VariableDeclarator') {
                    this.addChunk(chunks, file, path, 'arrow-function');
                }
            }
        });
        
        return chunks;
    }
    
    private async generateEmbedding(code: string): Promise<Float32Array> {
        const response = await openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: code.substring(0, 8000) // Token limit
        });
        
        return new Float32Array(response.data[0].embedding);
    }
    
    async search(query: string, limit = 10): Promise<SearchResult[]> {
        // Generate query embedding
        const queryEmbedding = await this.generateEmbedding(query);
        
        // Find similar code
        const results: { id: string; similarity: number }[] = [];
        
        for (const [id, embedding] of this.embeddings) {
            const similarity = this.cosineSimilarity(queryEmbedding, embedding);
            results.push({ id, similarity });
        }
        
        // Sort by similarity
        results.sort((a, b) => b.similarity - a.similarity);
        
        // Build response
        return results.slice(0, limit).map(r => {
            const chunk = this.chunks.get(r.id)!;
            return {
                file: chunk.file,
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                code: chunk.code,
                relevance: r.similarity,
                explanation: \`Matches query with \${(r.similarity * 100).toFixed(1)}% semantic similarity\`,
                type: r.similarity > 0.9 ? 'exact' : 'semantic'
            };
        });
    }
    
    private cosineSimilarity(a: Float32Array, b: Float32Array): number {
        let dot = 0, magA = 0, magB = 0;
        for (let i = 0; i < a.length; i++) {
            dot += a[i] * b[i];
            magA += a[i] * a[i];
            magB += b[i] * b[i];
        }
        return dot / (Math.sqrt(magA) * Math.sqrt(magB));
    }
}

// === Natural Language Query Processor ===
class NLQueryProcessor {
    async processQuery(query: string): Promise<ProcessedQuery> {
        const prompt = \`
            Classify and process this code search query:
            "\${query}"
            
            Determine:
            1. Query type: find_implementation | find_usage | explain_code | find_similar | find_bug
            2. Key entities (functions, classes, concepts)
            3. Expanded search terms
            4. Programming concepts involved
            
            Return as JSON.
        \`;
        
        const response = await this.llm.complete(prompt);
        return JSON.parse(response);
    }
    
    async answer(query: string, results: SearchResult[]): Promise<string> {
        const prompt = \`
            Answer this question about the codebase:
            "\${query}"
            
            Based on these code snippets:
            \${results.map(r => \`
            File: \${r.file} (lines \${r.startLine}-\${r.endLine})
            \${r.code}
            \`).join('\\n---\\n')}
            
            Provide a clear, helpful answer with code references.
        \`;
        
        return await this.llm.complete(prompt);
    }
}

// === Cross-Codebase Search ===
class CrossCodebaseSearch {
    private indices: Map<string, CodeEmbeddingIndex> = new Map();
    
    async searchAcrossProjects(query: string, projects: string[]): Promise<SearchResult[]> {
        const allResults: SearchResult[] = [];
        
        for (const project of projects) {
            if (!this.indices.has(project)) {
                const index = new CodeEmbeddingIndex();
                await index.indexCodebase(project);
                this.indices.set(project, index);
            }
            
            const results = await this.indices.get(project)!.search(query);
            allResults.push(...results.map(r => ({
                ...r,
                file: \`\${project}/\${r.file}\`
            })));
        }
        
        return allResults.sort((a, b) => b.relevance - a.relevance).slice(0, 20);
    }
}

// === Find Similar Code ===
class SimilarCodeFinder {
    async findSimilar(codeSnippet: string): Promise<SearchResult[]> {
        const embedding = await this.generateEmbedding(codeSnippet);
        
        // Search indexed code for similar patterns
        return this.index.searchByEmbedding(embedding);
    }
    
    async findDuplicates(projectPath: string): Promise<DuplicateGroup[]> {
        const duplicates: DuplicateGroup[] = [];
        const seenEmbeddings: { embedding: Float32Array; chunk: CodeChunk }[] = [];
        
        // Index and compare
        for (const [id, embedding] of this.index.embeddings) {
            for (const seen of seenEmbeddings) {
                const similarity = this.cosineSimilarity(embedding, seen.embedding);
                
                if (similarity > 0.95) {
                    duplicates.push({
                        similarity,
                        files: [this.index.chunks.get(id)!, seen.chunk]
                    });
                }
            }
            
            seenEmbeddings.push({ embedding, chunk: this.index.chunks.get(id)! });
        }
        
        return duplicates;
    }
}

export { CodeEmbeddingIndex, NLQueryProcessor, CrossCodebaseSearch, SimilarCodeFinder };
`;
    }
}

export const neuralCodeSearch = NeuralCodeSearch.getInstance();
