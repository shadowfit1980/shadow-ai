/**
 * âš¡ Next.js Generator
 * 
 * Generate Next.js patterns:
 * - App Router, API routes, ISR
 */

import { EventEmitter } from 'events';

export class NextJSGenerator extends EventEmitter {
    private static instance: NextJSGenerator;

    private constructor() { super(); }

    static getInstance(): NextJSGenerator {
        if (!NextJSGenerator.instance) {
            NextJSGenerator.instance = new NextJSGenerator();
        }
        return NextJSGenerator.instance;
    }

    generateAppStructure(): string {
        return `// Next.js 14 App Router Structure
// Generated by Shadow AI

// app/layout.tsx
import { Inter } from 'next/font/google';
import { Providers } from './providers';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
    title: { default: 'My App', template: '%s | My App' },
    description: 'My awesome Next.js app',
    openGraph: { type: 'website', locale: 'en_US', url: 'https://example.com' }
};

export default function RootLayout({ children }) {
    return (
        <html lang="en" suppressHydrationWarning>
            <body className={inter.className}>
                <Providers>
                    <Header />
                    <main>{children}</main>
                    <Footer />
                </Providers>
            </body>
        </html>
    );
}

// app/providers.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from 'next-themes';

const queryClient = new QueryClient();

export function Providers({ children }) {
    return (
        <SessionProvider>
            <QueryClientProvider client={queryClient}>
                <ThemeProvider attribute="data-theme" defaultTheme="system">
                    {children}
                </ThemeProvider>
            </QueryClientProvider>
        </SessionProvider>
    );
}

// app/page.tsx
export default async function Home() {
    const data = await getData();
    
    return (
        <div>
            <h1>Welcome</h1>
            <Suspense fallback={<Loading />}>
                <DynamicContent data={data} />
            </Suspense>
        </div>
    );
}

async function getData() {
    const res = await fetch('https://api.example.com/data', {
        next: { revalidate: 3600 } // ISR: revalidate every hour
    });
    return res.json();
}

// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';

export async function generateStaticParams() {
    const posts = await getPosts();
    return posts.map(post => ({ slug: post.slug }));
}

export async function generateMetadata({ params }) {
    const post = await getPost(params.slug);
    if (!post) return {};
    
    return {
        title: post.title,
        description: post.excerpt,
        openGraph: { images: [post.image] }
    };
}

export default async function BlogPost({ params }) {
    const post = await getPost(params.slug);
    if (!post) notFound();
    
    return (
        <article>
            <h1>{post.title}</h1>
            <div dangerouslySetInnerHTML={{ __html: post.content }} />
        </article>
    );
}
`;
    }

    generateAPIRoute(): string {
        return `// Next.js API Routes (App Router)
// Generated by Shadow AI

// app/api/users/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

const userSchema = z.object({
    name: z.string().min(1),
    email: z.string().email()
});

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    
    const users = await prisma.user.findMany({
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' }
    });
    
    const total = await prisma.user.count();
    
    return NextResponse.json({
        data: users,
        meta: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
}

export async function POST(request: Request) {
    const session = await getServerSession(authOptions);
    if (!session) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    try {
        const body = await request.json();
        const validated = userSchema.parse(body);
        
        const user = await prisma.user.create({ data: validated });
        return NextResponse.json(user, { status: 201 });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return NextResponse.json({ errors: error.errors }, { status: 400 });
        }
        throw error;
    }
}

// app/api/users/[id]/route.ts
export async function GET(request: Request, { params }) {
    const user = await prisma.user.findUnique({ where: { id: params.id } });
    if (!user) {
        return NextResponse.json({ error: 'Not found' }, { status: 404 });
    }
    return NextResponse.json(user);
}

export async function PUT(request: Request, { params }) {
    const body = await request.json();
    const user = await prisma.user.update({
        where: { id: params.id },
        data: body
    });
    return NextResponse.json(user);
}

export async function DELETE(request: Request, { params }) {
    await prisma.user.delete({ where: { id: params.id } });
    return new NextResponse(null, { status: 204 });
}
`;
    }

    generateServerActions(): string {
        return `// Next.js Server Actions
// Generated by Shadow AI

'use server';

import { revalidatePath, revalidateTag } from 'next/cache';
import { redirect } from 'next/navigation';
import { cookies } from 'next/headers';
import { z } from 'zod';

const createPostSchema = z.object({
    title: z.string().min(1).max(100),
    content: z.string().min(1),
    published: z.boolean().optional()
});

export async function createPost(formData: FormData) {
    const validated = createPostSchema.parse({
        title: formData.get('title'),
        content: formData.get('content'),
        published: formData.get('published') === 'on'
    });
    
    const post = await prisma.post.create({ data: validated });
    
    revalidatePath('/posts');
    revalidateTag('posts');
    redirect(\`/posts/\${post.id}\`);
}

export async function updatePost(id: string, formData: FormData) {
    const validated = createPostSchema.partial().parse({
        title: formData.get('title'),
        content: formData.get('content')
    });
    
    await prisma.post.update({ where: { id }, data: validated });
    revalidatePath(\`/posts/\${id}\`);
}

export async function deletePost(id: string) {
    await prisma.post.delete({ where: { id } });
    revalidatePath('/posts');
    redirect('/posts');
}

export async function setTheme(theme: 'light' | 'dark') {
    cookies().set('theme', theme, {
        httpOnly: true,
        secure: true,
        sameSite: 'lax',
        maxAge: 60 * 60 * 24 * 365
    });
}

// Form Component using Server Action
export function CreatePostForm() {
    return (
        <form action={createPost}>
            <input name="title" required />
            <textarea name="content" required />
            <label>
                <input type="checkbox" name="published" />
                Publish
            </label>
            <button type="submit">Create</button>
        </form>
    );
}
`;
    }
}

export const nextjsGenerator = NextJSGenerator.getInstance();
