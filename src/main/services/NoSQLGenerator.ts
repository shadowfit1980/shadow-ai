/**
 * ðŸƒ NoSQL Generator
 * 
 * Generate NoSQL code:
 * - MongoDB, DynamoDB, Firestore
 */

import { EventEmitter } from 'events';

export type NoSQLDB = 'mongodb' | 'dynamodb' | 'firestore';

export class NoSQLGenerator extends EventEmitter {
    private static instance: NoSQLGenerator;

    private constructor() { super(); }

    static getInstance(): NoSQLGenerator {
        if (!NoSQLGenerator.instance) {
            NoSQLGenerator.instance = new NoSQLGenerator();
        }
        return NoSQLGenerator.instance;
    }

    getDatabases(): NoSQLDB[] {
        return ['mongodb', 'dynamodb', 'firestore'];
    }

    generate(db: NoSQLDB): string {
        switch (db) {
            case 'mongodb': return this.generateMongoDB();
            case 'dynamodb': return this.generateDynamoDB();
            case 'firestore': return this.generateFirestore();
            default: return '';
        }
    }

    private generateMongoDB(): string {
        return `// MongoDB with Mongoose
// Generated by Shadow AI

import mongoose, { Schema, Document, Model } from 'mongoose';

// Connection
const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGODB_URI!);
        console.log('MongoDB connected');
    } catch (error) {
        console.error('MongoDB connection error:', error);
        process.exit(1);
    }
};

// User Schema
interface IUser extends Document {
    email: string;
    name: string;
    password: string;
    role: 'user' | 'admin';
    profile: {
        avatar?: string;
        bio?: string;
    };
    createdAt: Date;
    updatedAt: Date;
}

const userSchema = new Schema<IUser>({
    email: { type: String, required: true, unique: true, lowercase: true, trim: true },
    name: { type: String, required: true, trim: true },
    password: { type: String, required: true, select: false },
    role: { type: String, enum: ['user', 'admin'], default: 'user' },
    profile: {
        avatar: String,
        bio: String
    }
}, { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });

// Virtuals
userSchema.virtual('posts', {
    ref: 'Post',
    localField: '_id',
    foreignField: 'author'
});

// Pre-save hook
userSchema.pre('save', async function(next) {
    if (this.isModified('password')) {
        this.password = await bcrypt.hash(this.password, 12);
    }
    next();
});

// Methods
userSchema.methods.comparePassword = async function(candidate: string) {
    return bcrypt.compare(candidate, this.password);
};

// Statics
userSchema.statics.findByEmail = function(email: string) {
    return this.findOne({ email }).select('+password');
};

const User = mongoose.model<IUser>('User', userSchema);

// Repository Pattern
class UserRepository {
    async findAll(filter = {}, options = {}) {
        const { page = 1, limit = 10, sort = '-createdAt' } = options;
        const skip = (page - 1) * limit;
        
        const [users, total] = await Promise.all([
            User.find(filter).sort(sort).skip(skip).limit(limit).populate('posts'),
            User.countDocuments(filter)
        ]);
        
        return { users, total, page, pages: Math.ceil(total / limit) };
    }

    async findById(id: string) {
        return User.findById(id).populate('posts');
    }

    async create(data: Partial<IUser>) {
        return User.create(data);
    }

    async updateById(id: string, data: Partial<IUser>) {
        return User.findByIdAndUpdate(id, data, { new: true, runValidators: true });
    }

    async deleteById(id: string) {
        return User.findByIdAndDelete(id);
    }

    // Aggregation
    async getStats() {
        return User.aggregate([
            { $group: { _id: '$role', count: { $sum: 1 } } },
            { $project: { role: '$_id', count: 1, _id: 0 } }
        ]);
    }
}

export { connectDB, User, UserRepository };
`;
    }

    private generateDynamoDB(): string {
        return `// DynamoDB
// Generated by Shadow AI

import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { 
    DynamoDBDocumentClient, 
    GetCommand, 
    PutCommand, 
    UpdateCommand, 
    DeleteCommand, 
    QueryCommand, 
    ScanCommand 
} from '@aws-sdk/lib-dynamodb';
import { v4 as uuid } from 'uuid';

const client = new DynamoDBClient({ region: process.env.AWS_REGION });
const docClient = DynamoDBDocumentClient.from(client);

const TABLE_NAME = process.env.TABLE_NAME || 'MyTable';

class DynamoRepository<T extends { pk: string; sk: string }> {
    constructor(private tableName = TABLE_NAME) {}

    async get(pk: string, sk: string): Promise<T | null> {
        const { Item } = await docClient.send(new GetCommand({
            TableName: this.tableName,
            Key: { pk, sk }
        }));
        return Item as T || null;
    }

    async put(item: T): Promise<T> {
        await docClient.send(new PutCommand({
            TableName: this.tableName,
            Item: { 
                ...item, 
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            }
        }));
        return item;
    }

    async update(pk: string, sk: string, updates: Partial<T>): Promise<T> {
        const updateExpressionParts: string[] = [];
        const expressionAttributeNames: Record<string, string> = {};
        const expressionAttributeValues: Record<string, any> = {};

        Object.entries(updates).forEach(([key, value]) => {
            updateExpressionParts.push(\`#\${key} = :\${key}\`);
            expressionAttributeNames[\`#\${key}\`] = key;
            expressionAttributeValues[\`:\${key}\`] = value;
        });

        updateExpressionParts.push('#updatedAt = :updatedAt');
        expressionAttributeNames['#updatedAt'] = 'updatedAt';
        expressionAttributeValues[':updatedAt'] = new Date().toISOString();

        const { Attributes } = await docClient.send(new UpdateCommand({
            TableName: this.tableName,
            Key: { pk, sk },
            UpdateExpression: \`SET \${updateExpressionParts.join(', ')}\`,
            ExpressionAttributeNames: expressionAttributeNames,
            ExpressionAttributeValues: expressionAttributeValues,
            ReturnValues: 'ALL_NEW'
        }));

        return Attributes as T;
    }

    async delete(pk: string, sk: string): Promise<void> {
        await docClient.send(new DeleteCommand({
            TableName: this.tableName,
            Key: { pk, sk }
        }));
    }

    async query(pk: string, options: { limit?: number; lastKey?: any } = {}): Promise<{ items: T[]; lastKey?: any }> {
        const { Items, LastEvaluatedKey } = await docClient.send(new QueryCommand({
            TableName: this.tableName,
            KeyConditionExpression: 'pk = :pk',
            ExpressionAttributeValues: { ':pk': pk },
            Limit: options.limit,
            ExclusiveStartKey: options.lastKey
        }));

        return { items: Items as T[], lastKey: LastEvaluatedKey };
    }

    async queryByGSI(indexName: string, gsiPk: string, gsiPkValue: string): Promise<T[]> {
        const { Items } = await docClient.send(new QueryCommand({
            TableName: this.tableName,
            IndexName: indexName,
            KeyConditionExpression: \`\${gsiPk} = :value\`,
            ExpressionAttributeValues: { ':value': gsiPkValue }
        }));

        return Items as T[];
    }
}

// User Entity
interface User {
    pk: string;      // USER#<userId>
    sk: string;      // PROFILE
    email: string;
    name: string;
    gsi1pk?: string; // EMAIL#<email>
    gsi1sk?: string; // USER
}

const userRepo = new DynamoRepository<User>();

// CRUD Operations
async function createUser(data: { email: string; name: string }) {
    const userId = uuid();
    const user: User = {
        pk: \`USER#\${userId}\`,
        sk: 'PROFILE',
        email: data.email,
        name: data.name,
        gsi1pk: \`EMAIL#\${data.email}\`,
        gsi1sk: 'USER'
    };
    return userRepo.put(user);
}

async function getUserByEmail(email: string) {
    const users = await userRepo.queryByGSI('gsi1', 'gsi1pk', \`EMAIL#\${email}\`);
    return users[0] || null;
}

export { DynamoRepository, userRepo, createUser, getUserByEmail };
`;
    }

    private generateFirestore(): string {
        return `// Firestore
// Generated by Shadow AI

import { initializeApp, cert } from 'firebase-admin/app';
import { getFirestore, Timestamp, FieldValue } from 'firebase-admin/firestore';

// Initialize
initializeApp({
    credential: cert(JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT!))
});

const db = getFirestore();

// Generic Repository
class FirestoreRepository<T extends { id?: string }> {
    constructor(private collectionName: string) {}

    private get collection() {
        return db.collection(this.collectionName);
    }

    async findAll(options: { limit?: number; orderBy?: string; startAfter?: any } = {}) {
        let query = this.collection.orderBy(options.orderBy || 'createdAt', 'desc');
        
        if (options.limit) query = query.limit(options.limit);
        if (options.startAfter) query = query.startAfter(options.startAfter);
        
        const snapshot = await query.get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as T));
    }

    async findById(id: string): Promise<T | null> {
        const doc = await this.collection.doc(id).get();
        if (!doc.exists) return null;
        return { id: doc.id, ...doc.data() } as T;
    }

    async findWhere(field: string, op: FirebaseFirestore.WhereFilterOp, value: any): Promise<T[]> {
        const snapshot = await this.collection.where(field, op, value).get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as T));
    }

    async create(data: Omit<T, 'id'>): Promise<T> {
        const docRef = await this.collection.add({
            ...data,
            createdAt: FieldValue.serverTimestamp(),
            updatedAt: FieldValue.serverTimestamp()
        });
        return { id: docRef.id, ...data } as T;
    }

    async update(id: string, data: Partial<T>): Promise<void> {
        await this.collection.doc(id).update({
            ...data,
            updatedAt: FieldValue.serverTimestamp()
        });
    }

    async delete(id: string): Promise<void> {
        await this.collection.doc(id).delete();
    }

    async batchWrite(operations: Array<{ type: 'create' | 'update' | 'delete'; id?: string; data?: any }>) {
        const batch = db.batch();
        
        for (const op of operations) {
            const ref = op.id ? this.collection.doc(op.id) : this.collection.doc();
            
            switch (op.type) {
                case 'create':
                    batch.set(ref, { ...op.data, createdAt: FieldValue.serverTimestamp() });
                    break;
                case 'update':
                    batch.update(ref, { ...op.data, updatedAt: FieldValue.serverTimestamp() });
                    break;
                case 'delete':
                    batch.delete(ref);
                    break;
            }
        }
        
        await batch.commit();
    }

    // Real-time listener
    onSnapshot(callback: (items: T[]) => void) {
        return this.collection.orderBy('createdAt', 'desc').onSnapshot(snapshot => {
            const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as T));
            callback(items);
        });
    }
}

// Usage
interface User {
    id?: string;
    email: string;
    name: string;
}

const userRepo = new FirestoreRepository<User>('users');

export { db, FirestoreRepository, userRepo };
`;
    }
}

export const noSQLGenerator = NoSQLGenerator.getInstance();
