/**
 * ðŸ”” NotificationCenterGenerator
 * 
 * Notification center:
 * - In-app, push, preferences
 */

import { EventEmitter } from 'events';

export class NotificationCenterGenerator extends EventEmitter {
    private static instance: NotificationCenterGenerator;
    private constructor() { super(); }
    static getInstance(): NotificationCenterGenerator {
        if (!NotificationCenterGenerator.instance) {
            NotificationCenterGenerator.instance = new NotificationCenterGenerator();
        }
        return NotificationCenterGenerator.instance;
    }

    generate(): string {
        return `// Notification Center Generator - In-app, push, preferences
// Generated by Shadow AI

// Notification Schema
model Notification {
    id          String   @id @default(cuid())
    userId      String
    type        String
    title       String
    message     String
    data        Json?
    read        Boolean  @default(false)
    readAt      DateTime?
    createdAt   DateTime @default(now())
}

model NotificationPreference {
    id              String   @id @default(cuid())
    userId          String   @unique
    emailEnabled    Boolean  @default(true)
    pushEnabled     Boolean  @default(true)
    inAppEnabled    Boolean  @default(true)
    mutedTypes      String[]
}

// Notification Service
class NotificationService {
    async send(userId: string, notification: CreateNotification) {
        const prefs = await this.getPreferences(userId);
        
        // Check if type is muted
        if (prefs.mutedTypes.includes(notification.type)) return;
        
        // Create in-app notification
        if (prefs.inAppEnabled) {
            await prisma.notification.create({
                data: { userId, ...notification }
            });
            
            // Send via WebSocket
            websocket.emitToUser(userId, 'notification', notification);
        }
        
        // Send email
        if (prefs.emailEnabled && notification.sendEmail) {
            await emailService.send({
                to: userId,
                subject: notification.title,
                html: notification.emailTemplate
            });
        }
        
        // Send push
        if (prefs.pushEnabled && notification.sendPush) {
            await pushService.send(userId, {
                title: notification.title,
                body: notification.message
            });
        }
    }
    
    async getNotifications(userId: string, options?: { unreadOnly?: boolean; limit?: number }) {
        return prisma.notification.findMany({
            where: {
                userId,
                read: options?.unreadOnly ? false : undefined
            },
            orderBy: { createdAt: 'desc' },
            take: options?.limit || 50
        });
    }
    
    async markAsRead(userId: string, notificationId: string) {
        await prisma.notification.update({
            where: { id: notificationId, userId },
            data: { read: true, readAt: new Date() }
        });
    }
    
    async markAllAsRead(userId: string) {
        await prisma.notification.updateMany({
            where: { userId, read: false },
            data: { read: true, readAt: new Date() }
        });
    }
    
    async getUnreadCount(userId: string): Promise<number> {
        return prisma.notification.count({
            where: { userId, read: false }
        });
    }
    
    async getPreferences(userId: string) {
        return prisma.notificationPreference.upsert({
            where: { userId },
            create: { userId },
            update: {}
        });
    }
    
    async updatePreferences(userId: string, prefs: Partial<NotificationPreference>) {
        return prisma.notificationPreference.update({
            where: { userId },
            data: prefs
        });
    }
}

// React Notification Bell
export function NotificationBell() {
    const { data: count } = useQuery(['notifications', 'count'], getUnreadCount);
    const [open, setOpen] = useState(false);
    
    return (
        <div className="notification-bell">
            <button onClick={() => setOpen(!open)}>
                ðŸ”” {count > 0 && <span className="badge">{count}</span>}
            </button>
            {open && <NotificationDropdown onClose={() => setOpen(false)} />}
        </div>
    );
}

export { NotificationService, NotificationBell };
`;
    }
}

export const notificationCenterGenerator = NotificationCenterGenerator.getInstance();
