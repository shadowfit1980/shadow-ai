/**
 * ðŸ—„ï¸ ORM Generator
 * 
 * Generate ORM code for:
 * - Prisma, TypeORM, Sequelize, Drizzle
 * - Models, migrations, seeds
 */

import { EventEmitter } from 'events';

export type ORMType = 'prisma' | 'typeorm' | 'sequelize' | 'drizzle';

export interface ModelDefinition {
    name: string;
    fields: { name: string; type: string; constraints?: string[] }[];
    relations?: { type: string; model: string; field?: string }[];
}

export class ORMGenerator extends EventEmitter {
    private static instance: ORMGenerator;

    private constructor() { super(); }

    static getInstance(): ORMGenerator {
        if (!ORMGenerator.instance) {
            ORMGenerator.instance = new ORMGenerator();
        }
        return ORMGenerator.instance;
    }

    getSupportedORMs(): ORMType[] {
        return ['prisma', 'typeorm', 'sequelize', 'drizzle'];
    }

    generateSchema(orm: ORMType, models: ModelDefinition[]): string {
        switch (orm) {
            case 'prisma': return this.generatePrisma(models);
            case 'typeorm': return this.generateTypeORM(models);
            case 'sequelize': return this.generateSequelize(models);
            case 'drizzle': return this.generateDrizzle(models);
            default: return '';
        }
    }

    private generatePrisma(models: ModelDefinition[]): string {
        let schema = `// Prisma Schema
// Generated by Shadow AI

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

`;
        for (const model of models) {
            schema += `model ${model.name} {\n`;
            schema += `    id        String   @id @default(cuid())\n`;
            schema += `    createdAt DateTime @default(now())\n`;
            schema += `    updatedAt DateTime @updatedAt\n`;

            for (const field of model.fields) {
                const constraints = field.constraints?.map(c => `@${c}`).join(' ') || '';
                schema += `    ${field.name} ${this.prismaType(field.type)} ${constraints}\n`;
            }

            if (model.relations) {
                for (const rel of model.relations) {
                    if (rel.type === 'hasMany') {
                        schema += `    ${rel.field || rel.model.toLowerCase() + 's'} ${rel.model}[]\n`;
                    } else if (rel.type === 'belongsTo') {
                        schema += `    ${rel.field || rel.model.toLowerCase()} ${rel.model}? @relation(fields: [${rel.model.toLowerCase()}Id], references: [id])\n`;
                        schema += `    ${rel.model.toLowerCase()}Id String?\n`;
                    }
                }
            }

            schema += `}\n\n`;
        }

        return schema;
    }

    private prismaType(type: string): string {
        const map: Record<string, string> = {
            'string': 'String',
            'number': 'Int',
            'float': 'Float',
            'boolean': 'Boolean',
            'date': 'DateTime',
            'json': 'Json',
            'text': 'String'
        };
        return map[type.toLowerCase()] || 'String';
    }

    private generateTypeORM(models: ModelDefinition[]): string {
        let code = `// TypeORM Entities
// Generated by Shadow AI

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, OneToMany } from 'typeorm';

`;
        for (const model of models) {
            code += `@Entity()\nexport class ${model.name} {\n`;
            code += `    @PrimaryGeneratedColumn('uuid')\n    id: string;\n\n`;
            code += `    @CreateDateColumn()\n    createdAt: Date;\n\n`;
            code += `    @UpdateDateColumn()\n    updatedAt: Date;\n\n`;

            for (const field of model.fields) {
                const nullable = field.constraints?.includes('optional') ? '{ nullable: true }' : '';
                code += `    @Column(${nullable})\n    ${field.name}: ${this.tsType(field.type)};\n\n`;
            }

            code += `}\n\n`;
        }

        return code;
    }

    private generateSequelize(models: ModelDefinition[]): string {
        let code = `// Sequelize Models
// Generated by Shadow AI

import { Model, DataTypes, Sequelize } from 'sequelize';

export function defineModels(sequelize: Sequelize) {
`;
        for (const model of models) {
            code += `    const ${model.name} = sequelize.define('${model.name}', {\n`;
            code += `        id: { type: DataTypes.UUID, defaultValue: DataTypes.UUIDV4, primaryKey: true },\n`;

            for (const field of model.fields) {
                const allowNull = field.constraints?.includes('optional') ? 'true' : 'false';
                code += `        ${field.name}: { type: ${this.sequelizeType(field.type)}, allowNull: ${allowNull} },\n`;
            }

            code += `    }, { timestamps: true });\n\n`;
        }

        code += `    return { ${models.map(m => m.name).join(', ')} };\n}\n`;
        return code;
    }

    private sequelizeType(type: string): string {
        const map: Record<string, string> = {
            'string': 'DataTypes.STRING',
            'text': 'DataTypes.TEXT',
            'number': 'DataTypes.INTEGER',
            'float': 'DataTypes.FLOAT',
            'boolean': 'DataTypes.BOOLEAN',
            'date': 'DataTypes.DATE',
            'json': 'DataTypes.JSON'
        };
        return map[type.toLowerCase()] || 'DataTypes.STRING';
    }

    private generateDrizzle(models: ModelDefinition[]): string {
        let code = `// Drizzle ORM Schema
// Generated by Shadow AI

import { pgTable, uuid, text, timestamp, integer, boolean, jsonb } from 'drizzle-orm/pg-core';

`;
        for (const model of models) {
            const tableName = model.name.toLowerCase() + 's';
            code += `export const ${tableName} = pgTable('${tableName}', {\n`;
            code += `    id: uuid('id').primaryKey().defaultRandom(),\n`;
            code += `    createdAt: timestamp('created_at').defaultNow(),\n`;
            code += `    updatedAt: timestamp('updated_at').defaultNow(),\n`;

            for (const field of model.fields) {
                code += `    ${field.name}: ${this.drizzleType(field.type)}('${field.name}'),\n`;
            }

            code += `});\n\n`;
        }

        return code;
    }

    private drizzleType(type: string): string {
        const map: Record<string, string> = {
            'string': 'text',
            'text': 'text',
            'number': 'integer',
            'boolean': 'boolean',
            'date': 'timestamp',
            'json': 'jsonb'
        };
        return map[type.toLowerCase()] || 'text';
    }

    private tsType(type: string): string {
        const map: Record<string, string> = {
            'string': 'string',
            'text': 'string',
            'number': 'number',
            'float': 'number',
            'boolean': 'boolean',
            'date': 'Date',
            'json': 'any'
        };
        return map[type.toLowerCase()] || 'string';
    }

    generateMigration(orm: ORMType, model: ModelDefinition): string {
        if (orm === 'prisma') {
            return `-- CreateTable
CREATE TABLE "${model.name}" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    ${model.fields.map(f => `"${f.name}" ${this.sqlType(f.type)}`).join(',\n    ')}
);`;
        }
        return '';
    }

    private sqlType(type: string): string {
        const map: Record<string, string> = {
            'string': 'TEXT',
            'number': 'INTEGER',
            'float': 'REAL',
            'boolean': 'BOOLEAN',
            'date': 'DATETIME',
            'json': 'TEXT'
        };
        return map[type.toLowerCase()] || 'TEXT';
    }
}

export const ormGenerator = ORMGenerator.getInstance();
