/**
 * üöÄ One-Click Deployer
 * 
 * Full cloud deployment with rollback:
 * - Vercel, AWS, GCP, Azure
 */

import { EventEmitter } from 'events';

export class OneClickDeployer extends EventEmitter {
    private static instance: OneClickDeployer;

    private constructor() { super(); }

    static getInstance(): OneClickDeployer {
        if (!OneClickDeployer.instance) {
            OneClickDeployer.instance = new OneClickDeployer();
        }
        return OneClickDeployer.instance;
    }

    generate(): string {
        return `// One-Click Deployer
// Generated by Shadow AI

/**
 * ONE-CLICK DEPLOYER
 * 
 * Deploy to any cloud with a single command.
 * Includes automatic rollback on failure.
 */

interface DeploymentConfig {
    provider: 'vercel' | 'aws' | 'gcp' | 'azure' | 'fly' | 'railway';
    projectPath: string;
    environment: 'development' | 'staging' | 'production';
    envVars?: Record<string, string>;
    domain?: string;
    scaling?: { min: number; max: number };
}

interface DeploymentResult {
    success: boolean;
    url?: string;
    deploymentId: string;
    logs: string[];
    duration: number;
    rollbackAvailable: boolean;
}

// === Provider Adapters ===
abstract class DeploymentProvider {
    abstract deploy(config: DeploymentConfig): Promise<DeploymentResult>;
    abstract rollback(deploymentId: string): Promise<void>;
    abstract getStatus(deploymentId: string): Promise<DeploymentStatus>;
}

class VercelProvider extends DeploymentProvider {
    async deploy(config: DeploymentConfig): Promise<DeploymentResult> {
        const startTime = Date.now();
        const logs: string[] = [];
        
        try {
            logs.push('üì¶ Building project...');
            await this.exec(\`cd \${config.projectPath} && npm run build\`);
            
            logs.push('üöÄ Deploying to Vercel...');
            const envArgs = config.envVars 
                ? Object.entries(config.envVars).map(([k, v]) => \`-e \${k}="\${v}"\`).join(' ')
                : '';
            
            const prodFlag = config.environment === 'production' ? '--prod' : '';
            const result = await this.exec(
                \`cd \${config.projectPath} && vercel \${prodFlag} \${envArgs} --yes\`
            );
            
            const url = this.extractUrl(result.stdout);
            
            logs.push(\`‚úÖ Deployed to: \${url}\`);
            
            return {
                success: true,
                url,
                deploymentId: this.extractDeploymentId(result.stdout),
                logs,
                duration: Date.now() - startTime,
                rollbackAvailable: true
            };
        } catch (error: any) {
            logs.push(\`‚ùå Deployment failed: \${error.message}\`);
            return {
                success: false,
                deploymentId: '',
                logs,
                duration: Date.now() - startTime,
                rollbackAvailable: false
            };
        }
    }
    
    async rollback(deploymentId: string): Promise<void> {
        await this.exec(\`vercel rollback \${deploymentId}\`);
    }
}

class AWSProvider extends DeploymentProvider {
    async deploy(config: DeploymentConfig): Promise<DeploymentResult> {
        const startTime = Date.now();
        const logs: string[] = [];
        
        try {
            // Build
            logs.push('üì¶ Building project...');
            await this.exec(\`cd \${config.projectPath} && npm run build\`);
            
            // Package
            logs.push('üìã Packaging for AWS...');
            await this.exec(\`cd \${config.projectPath} && npx sst build\`);
            
            // Deploy
            logs.push('üöÄ Deploying to AWS...');
            const stage = config.environment === 'production' ? 'prod' : config.environment;
            const result = await this.exec(
                \`cd \${config.projectPath} && npx sst deploy --stage \${stage}\`
            );
            
            const outputs = this.parseSSOutput(result.stdout);
            
            logs.push(\`‚úÖ Deployed! API: \${outputs.apiUrl}\`);
            
            return {
                success: true,
                url: outputs.apiUrl,
                deploymentId: outputs.stackId,
                logs,
                duration: Date.now() - startTime,
                rollbackAvailable: true
            };
        } catch (error: any) {
            logs.push(\`‚ùå Deployment failed: \${error.message}\`);
            
            // Attempt auto-rollback
            logs.push('‚è™ Attempting rollback...');
            await this.rollback('previous');
            
            return {
                success: false,
                deploymentId: '',
                logs,
                duration: Date.now() - startTime,
                rollbackAvailable: false
            };
        }
    }
    
    async rollback(deploymentId: string): Promise<void> {
        await this.exec(\`aws cloudformation cancel-update-stack --stack-name \${deploymentId}\`);
    }
}

// === Deployment Orchestrator ===
class DeploymentOrchestrator {
    private providers: Map<string, DeploymentProvider> = new Map([
        ['vercel', new VercelProvider()],
        ['aws', new AWSProvider()],
    ]);
    
    async deploy(config: DeploymentConfig): Promise<DeploymentResult> {
        const provider = this.providers.get(config.provider);
        if (!provider) {
            throw new Error(\`Unsupported provider: \${config.provider}\`);
        }
        
        console.log(\`üöÄ Starting deployment to \${config.provider}...\`);
        
        // Pre-deployment checks
        await this.runPreflightChecks(config);
        
        // Deploy
        const result = await provider.deploy(config);
        
        // Post-deployment validation
        if (result.success) {
            const healthy = await this.healthCheck(result.url!);
            
            if (!healthy) {
                console.log('‚ö†Ô∏è Health check failed, rolling back...');
                await provider.rollback(result.deploymentId);
                result.success = false;
                result.logs.push('‚è™ Rolled back due to failed health check');
            }
        }
        
        // Notify
        await this.notifyTeam(result);
        
        return result;
    }
    
    private async runPreflightChecks(config: DeploymentConfig): Promise<void> {
        console.log('üîç Running preflight checks...');
        
        // Type check
        await this.exec(\`cd \${config.projectPath} && npx tsc --noEmit\`);
        
        // Lint
        await this.exec(\`cd \${config.projectPath} && npm run lint\`);
        
        // Tests
        await this.exec(\`cd \${config.projectPath} && npm test\`);
        
        console.log('‚úÖ Preflight checks passed');
    }
    
    private async healthCheck(url: string, retries = 5): Promise<boolean> {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(\`\${url}/health\`);
                if (response.ok) return true;
            } catch {
                await new Promise(r => setTimeout(r, 2000));
            }
        }
        return false;
    }
}

export { DeploymentConfig, DeploymentOrchestrator, VercelProvider, AWSProvider };
`;
    }
}

export const oneClickDeployer = OneClickDeployer.getInstance();
