/**
 * ðŸ“‹ OutputParserService
 * 
 * LLM output parsing:
 * - JSON, structured data, validation
 */

import { EventEmitter } from 'events';

export class OutputParserService extends EventEmitter {
    private static instance: OutputParserService;
    private constructor() { super(); }
    static getInstance(): OutputParserService {
        if (!OutputParserService.instance) {
            OutputParserService.instance = new OutputParserService();
        }
        return OutputParserService.instance;
    }

    generate(): string {
        return `// Output Parser Service - JSON, structured data
// Generated by Shadow AI

import { z } from 'zod';

class OutputParser {
    // Parse JSON from LLM output
    parseJSON<T>(output: string): T {
        // Handle markdown code blocks
        const jsonMatch = output.match(/\\\`\\\`\\\`(?:json)?\\n?([\\s\\S]*?)\\n?\\\`\\\`\\\`/);
        const jsonStr = jsonMatch ? jsonMatch[1] : output;
        
        try {
            return JSON.parse(jsonStr.trim());
        } catch (error) {
            // Try to extract JSON from text
            const objectMatch = jsonStr.match(/\\{[\\s\\S]*\\}/);
            const arrayMatch = jsonStr.match(/\\[[\\s\\S]*\\]/);
            
            const match = objectMatch || arrayMatch;
            if (!match) throw new Error('No valid JSON found in output');
            
            return JSON.parse(match[0]);
        }
    }
    
    // Parse with Zod schema validation
    parseWithSchema<T>(output: string, schema: z.ZodType<T>): T {
        const data = this.parseJSON(output);
        return schema.parse(data);
    }
    
    // Parse list output
    parseList(output: string): string[] {
        const lines = output.split('\\n');
        
        return lines
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .map(line => {
                // Remove bullet points, numbers, etc.
                return line.replace(/^[-*â€¢]\\s*/, '').replace(/^\\d+\\.\\s*/, '');
            });
    }
    
    // Parse code blocks
    parseCodeBlocks(output: string): { language: string; code: string }[] {
        const regex = /\\\`\\\`\\\`(\\w*)\\n([\\s\\S]*?)\\\`\\\`\\\`/g;
        const blocks: { language: string; code: string }[] = [];
        
        let match;
        while ((match = regex.exec(output)) !== null) {
            blocks.push({
                language: match[1] || 'text',
                code: match[2].trim()
            });
        }
        
        return blocks;
    }
    
    // Parse key-value pairs
    parseKeyValue(output: string): Record<string, string> {
        const result: Record<string, string> = {};
        const lines = output.split('\\n');
        
        for (const line of lines) {
            const colonIndex = line.indexOf(':');
            if (colonIndex > 0) {
                const key = line.slice(0, colonIndex).trim();
                const value = line.slice(colonIndex + 1).trim();
                result[key] = value;
            }
        }
        
        return result;
    }
    
    // Fix malformed JSON
    async fixJSON(malformed: string): Promise<any> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Fix this malformed JSON. Return only valid JSON, no explanation.'
        }, {
            role: 'user',
            content: malformed
        }]);
        
        return JSON.parse(response.content);
    }
    
    // Generate parser from example
    createParser<T>(example: T): (output: string) => T {
        const schema = this.inferSchema(example);
        
        return (output: string) => {
            const parsed = this.parseJSON(output);
            // Basic type coercion based on example
            return this.coerce(parsed, example);
        };
    }
    
    private inferSchema(example: any): any {
        if (Array.isArray(example)) {
            return { type: 'array', items: this.inferSchema(example[0]) };
        }
        if (typeof example === 'object' && example !== null) {
            const properties: any = {};
            for (const [key, value] of Object.entries(example)) {
                properties[key] = this.inferSchema(value);
            }
            return { type: 'object', properties };
        }
        return { type: typeof example };
    }
    
    private coerce(data: any, example: any): any {
        if (typeof example === 'number') return Number(data);
        if (typeof example === 'boolean') return Boolean(data);
        if (typeof example === 'string') return String(data);
        if (Array.isArray(example) && Array.isArray(data)) {
            return data.map(item => this.coerce(item, example[0]));
        }
        if (typeof example === 'object' && example !== null && typeof data === 'object') {
            const result: any = {};
            for (const key of Object.keys(example)) {
                result[key] = this.coerce(data[key], example[key]);
            }
            return result;
        }
        return data;
    }
}

export { OutputParser };
`;
    }
}

export const outputParserService = OutputParserService.getInstance();
