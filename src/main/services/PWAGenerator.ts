/**
 * ðŸ“± PWA Generator
 * 
 * Generate Progressive Web Apps:
 * - Service Workers, offline, manifest
 */

import { EventEmitter } from 'events';

export class PWAGenerator extends EventEmitter {
    private static instance: PWAGenerator;

    private constructor() { super(); }

    static getInstance(): PWAGenerator {
        if (!PWAGenerator.instance) {
            PWAGenerator.instance = new PWAGenerator();
        }
        return PWAGenerator.instance;
    }

    generateServiceWorker(): string {
        return `// Service Worker
// Generated by Shadow AI

const CACHE_NAME = 'app-v1';
const STATIC_ASSETS = [
    '/',
    '/index.html',
    '/manifest.json',
    '/offline.html',
    '/icons/icon-192.png',
    '/icons/icon-512.png'
];

// Install: Pre-cache static assets
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(STATIC_ASSETS))
            .then(() => self.skipWaiting())
    );
});

// Activate: Clean up old caches
self.addEventListener('activate', (event) => {
    event.waitUntil(
        caches.keys()
            .then(keys => Promise.all(
                keys.filter(key => key !== CACHE_NAME)
                    .map(key => caches.delete(key))
            ))
            .then(() => self.clients.claim())
    );
});

// Fetch: Network-first with cache fallback
self.addEventListener('fetch', (event) => {
    const { request } = event;
    
    // Skip non-GET requests
    if (request.method !== 'GET') return;
    
    // Skip cross-origin requests
    if (!request.url.startsWith(self.location.origin)) return;

    // API requests: Network only
    if (request.url.includes('/api/')) {
        event.respondWith(
            fetch(request)
                .catch(() => new Response(JSON.stringify({ error: 'Offline' }), {
                    headers: { 'Content-Type': 'application/json' }
                }))
        );
        return;
    }

    // Static assets: Cache first
    if (request.destination === 'image' || request.destination === 'script' || request.destination === 'style') {
        event.respondWith(
            caches.match(request)
                .then(cached => cached || fetch(request).then(response => {
                    const clone = response.clone();
                    caches.open(CACHE_NAME).then(cache => cache.put(request, clone));
                    return response;
                }))
        );
        return;
    }

    // HTML: Network first, cache fallback
    event.respondWith(
        fetch(request)
            .then(response => {
                const clone = response.clone();
                caches.open(CACHE_NAME).then(cache => cache.put(request, clone));
                return response;
            })
            .catch(() => caches.match(request).then(cached => cached || caches.match('/offline.html')))
    );
});

// Background sync
self.addEventListener('sync', (event) => {
    if (event.tag === 'sync-data') {
        event.waitUntil(syncData());
    }
});

async function syncData() {
    const queue = await getQueuedRequests();
    for (const request of queue) {
        try {
            await fetch(request.url, request.options);
            await removeFromQueue(request.id);
        } catch (error) {
            console.error('Sync failed:', error);
        }
    }
}

// Push notifications
self.addEventListener('push', (event) => {
    const data = event.data?.json() || { title: 'Notification', body: '' };
    
    event.waitUntil(
        self.registration.showNotification(data.title, {
            body: data.body,
            icon: '/icons/icon-192.png',
            badge: '/icons/badge.png',
            data: data.url
        })
    );
});

self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        clients.openWindow(event.notification.data || '/')
    );
});
`;
    }

    generateManifest(): string {
        return `// manifest.json
{
    "name": "My App",
    "short_name": "App",
    "description": "A Progressive Web App",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#667eea",
    "orientation": "portrait-primary",
    "icons": [
        { "src": "/icons/icon-72.png", "sizes": "72x72", "type": "image/png" },
        { "src": "/icons/icon-96.png", "sizes": "96x96", "type": "image/png" },
        { "src": "/icons/icon-128.png", "sizes": "128x128", "type": "image/png" },
        { "src": "/icons/icon-144.png", "sizes": "144x144", "type": "image/png" },
        { "src": "/icons/icon-152.png", "sizes": "152x152", "type": "image/png" },
        { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png", "purpose": "any maskable" },
        { "src": "/icons/icon-384.png", "sizes": "384x384", "type": "image/png" },
        { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png", "purpose": "any maskable" }
    ],
    "screenshots": [
        { "src": "/screenshots/desktop.png", "sizes": "1280x720", "type": "image/png", "form_factor": "wide" },
        { "src": "/screenshots/mobile.png", "sizes": "750x1334", "type": "image/png", "form_factor": "narrow" }
    ],
    "shortcuts": [
        { "name": "Dashboard", "url": "/dashboard", "description": "Go to dashboard" },
        { "name": "New Item", "url": "/new", "description": "Create new item" }
    ],
    "share_target": {
        "action": "/share",
        "method": "POST",
        "enctype": "multipart/form-data",
        "params": { "title": "title", "text": "text", "url": "url", "files": [{ "name": "files", "accept": ["image/*"] }] }
    },
    "categories": ["productivity", "utilities"]
}`;
    }

    generateHooks(): string {
        return `// PWA React Hooks
// Generated by Shadow AI

import { useState, useEffect, useCallback } from 'react';

// Register service worker
function useServiceWorker() {
    const [registration, setRegistration] = useState<ServiceWorkerRegistration | null>(null);
    const [updateAvailable, setUpdateAvailable] = useState(false);

    useEffect(() => {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => {
                    setRegistration(reg);
                    
                    reg.addEventListener('updatefound', () => {
                        const newWorker = reg.installing;
                        newWorker?.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                setUpdateAvailable(true);
                            }
                        });
                    });
                });
        }
    }, []);

    const update = useCallback(() => {
        registration?.waiting?.postMessage({ type: 'SKIP_WAITING' });
        window.location.reload();
    }, [registration]);

    return { registration, updateAvailable, update };
}

// Install prompt
function useInstallPrompt() {
    const [prompt, setPrompt] = useState<any>(null);
    const [isInstalled, setIsInstalled] = useState(false);

    useEffect(() => {
        const handler = (e: Event) => {
            e.preventDefault();
            setPrompt(e);
        };
        
        window.addEventListener('beforeinstallprompt', handler);
        window.addEventListener('appinstalled', () => setIsInstalled(true));
        
        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
            setIsInstalled(true);
        }
        
        return () => window.removeEventListener('beforeinstallprompt', handler);
    }, []);

    const install = useCallback(async () => {
        if (!prompt) return false;
        prompt.prompt();
        const { outcome } = await prompt.userChoice;
        setPrompt(null);
        return outcome === 'accepted';
    }, [prompt]);

    return { canInstall: !!prompt && !isInstalled, isInstalled, install };
}

// Online status
function useOnlineStatus() {
    const [isOnline, setIsOnline] = useState(navigator.onLine);

    useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
            window.removeEventListener('online', handleOnline);
            window.removeEventListener('offline', handleOffline);
        };
    }, []);

    return isOnline;
}

// Push notifications
function usePushNotifications() {
    const [permission, setPermission] = useState(Notification.permission);
    const [subscription, setSubscription] = useState<PushSubscription | null>(null);

    const subscribe = useCallback(async () => {
        const perm = await Notification.requestPermission();
        setPermission(perm);
        
        if (perm === 'granted') {
            const reg = await navigator.serviceWorker.ready;
            const sub = await reg.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY
            });
            setSubscription(sub);
            await sendSubscriptionToServer(sub);
        }
    }, []);

    return { permission, subscription, subscribe };
}

export { useServiceWorker, useInstallPrompt, useOnlineStatus, usePushNotifications };
`;
    }
}

export const pwaGenerator = PWAGenerator.getInstance();
