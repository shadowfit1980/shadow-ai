/**
 * ðŸ’³ Payment Integrator
 * 
 * Generate payment integration code:
 * - Stripe, PayPal, subscriptions
 */

import { EventEmitter } from 'events';

export type PaymentProvider = 'stripe' | 'paypal' | 'paddle';

export class PaymentIntegrator extends EventEmitter {
    private static instance: PaymentIntegrator;

    private constructor() { super(); }

    static getInstance(): PaymentIntegrator {
        if (!PaymentIntegrator.instance) {
            PaymentIntegrator.instance = new PaymentIntegrator();
        }
        return PaymentIntegrator.instance;
    }

    getProviders(): PaymentProvider[] {
        return ['stripe', 'paypal', 'paddle'];
    }

    generateStripe(): string {
        return `// Stripe Integration
// Generated by Shadow AI

import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export class StripeService {
    // Checkout Session
    async createCheckoutSession(items: any[], customerId?: string) {
        const session = await stripe.checkout.sessions.create({
            mode: 'payment',
            customer: customerId,
            line_items: items.map(item => ({
                price_data: {
                    currency: 'usd',
                    product_data: {
                        name: item.name,
                        images: item.images,
                    },
                    unit_amount: Math.round(item.price * 100),
                },
                quantity: item.quantity,
            })),
            success_url: \`\${process.env.FRONTEND_URL}/checkout/success?session_id={CHECKOUT_SESSION_ID}\`,
            cancel_url: \`\${process.env.FRONTEND_URL}/checkout/cancel\`,
            metadata: { orderId: item.orderId }
        });
        
        return { sessionId: session.id, url: session.url };
    }

    // Subscription
    async createSubscription(customerId: string, priceId: string) {
        const subscription = await stripe.subscriptions.create({
            customer: customerId,
            items: [{ price: priceId }],
            payment_behavior: 'default_incomplete',
            expand: ['latest_invoice.payment_intent'],
        });
        
        return {
            subscriptionId: subscription.id,
            clientSecret: (subscription.latest_invoice as any).payment_intent.client_secret,
        };
    }

    async cancelSubscription(subscriptionId: string) {
        return stripe.subscriptions.cancel(subscriptionId);
    }

    async updateSubscription(subscriptionId: string, priceId: string) {
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        return stripe.subscriptions.update(subscriptionId, {
            items: [{
                id: subscription.items.data[0].id,
                price: priceId,
            }],
            proration_behavior: 'always_invoice',
        });
    }

    // Customer
    async createCustomer(email: string, name?: string) {
        return stripe.customers.create({ email, name });
    }

    async getCustomerPortalUrl(customerId: string) {
        const session = await stripe.billingPortal.sessions.create({
            customer: customerId,
            return_url: \`\${process.env.FRONTEND_URL}/account\`,
        });
        return session.url;
    }

    // Payment Intent (custom flow)
    async createPaymentIntent(amount: number, currency = 'usd') {
        return stripe.paymentIntents.create({
            amount: Math.round(amount * 100),
            currency,
            automatic_payment_methods: { enabled: true },
        });
    }

    // Webhook handler
    async handleWebhook(payload: Buffer, signature: string) {
        const event = stripe.webhooks.constructEvent(
            payload,
            signature,
            process.env.STRIPE_WEBHOOK_SECRET!
        );

        switch (event.type) {
            case 'checkout.session.completed':
                const session = event.data.object as Stripe.Checkout.Session;
                await this.handleSuccessfulPayment(session);
                break;
                
            case 'invoice.paid':
                const invoice = event.data.object as Stripe.Invoice;
                await this.handleInvoicePaid(invoice);
                break;
                
            case 'customer.subscription.updated':
            case 'customer.subscription.deleted':
                const subscription = event.data.object as Stripe.Subscription;
                await this.handleSubscriptionChange(subscription);
                break;
        }
    }

    private async handleSuccessfulPayment(session: Stripe.Checkout.Session) {
        // Update order status, send email, etc.
        console.log('Payment successful:', session.id);
    }

    private async handleInvoicePaid(invoice: Stripe.Invoice) {
        console.log('Invoice paid:', invoice.id);
    }

    private async handleSubscriptionChange(subscription: Stripe.Subscription) {
        console.log('Subscription changed:', subscription.id, subscription.status);
    }
}

// React Component
export const CheckoutButton = ({ items }) => {
    const handleCheckout = async () => {
        const res = await fetch('/api/checkout', {
            method: 'POST',
            body: JSON.stringify({ items }),
        });
        const { url } = await res.json();
        window.location.href = url;
    };
    
    return <button onClick={handleCheckout}>Checkout</button>;
};
`;
    }

    generatePayPal(): string {
        return `// PayPal Integration
// Generated by Shadow AI

const paypal = require('@paypal/checkout-server-sdk');

const environment = process.env.NODE_ENV === 'production'
    ? new paypal.core.LiveEnvironment(process.env.PAYPAL_CLIENT_ID, process.env.PAYPAL_SECRET)
    : new paypal.core.SandboxEnvironment(process.env.PAYPAL_CLIENT_ID, process.env.PAYPAL_SECRET);

const client = new paypal.core.PayPalHttpClient(environment);

export class PayPalService {
    async createOrder(items: any[], total: number) {
        const request = new paypal.orders.OrdersCreateRequest();
        request.prefer('return=representation');
        request.requestBody({
            intent: 'CAPTURE',
            purchase_units: [{
                amount: {
                    currency_code: 'USD',
                    value: total.toFixed(2),
                    breakdown: {
                        item_total: { currency_code: 'USD', value: total.toFixed(2) }
                    }
                },
                items: items.map(item => ({
                    name: item.name,
                    unit_amount: { currency_code: 'USD', value: item.price.toFixed(2) },
                    quantity: item.quantity.toString()
                }))
            }]
        });

        const response = await client.execute(request);
        return { orderId: response.result.id };
    }

    async captureOrder(orderId: string) {
        const request = new paypal.orders.OrdersCaptureRequest(orderId);
        request.requestBody({});
        
        const response = await client.execute(request);
        return response.result;
    }

    async refundPayment(captureId: string, amount?: number) {
        const request = new paypal.payments.CapturesRefundRequest(captureId);
        request.requestBody({
            ...(amount && { amount: { value: amount.toFixed(2), currency_code: 'USD' } })
        });
        
        return client.execute(request);
    }
}
`;
    }
}

export const paymentIntegrator = PaymentIntegrator.getInstance();
