/**
 * âš¡ PerformanceMonitor
 * 
 * Performance monitoring:
 * - Core Web Vitals, profiling, optimization
 */

import { EventEmitter } from 'events';

export class PerformanceMonitor extends EventEmitter {
    private static instance: PerformanceMonitor;
    private constructor() { super(); }
    static getInstance(): PerformanceMonitor {
        if (!PerformanceMonitor.instance) {
            PerformanceMonitor.instance = new PerformanceMonitor();
        }
        return PerformanceMonitor.instance;
    }

    generate(): string {
        return `// Performance Monitor - Core Web Vitals, profiling
// Generated by Shadow AI

import { getCLS, getFID, getLCP, getFCP, getTTFB } from 'web-vitals';

// Core Web Vitals Tracking
class WebVitalsTracker {
    private metrics: Record<string, number> = {};
    
    init(onMetric: (metric: { name: string; value: number }) => void) {
        getCLS((metric) => { this.metrics.CLS = metric.value; onMetric({ name: 'CLS', value: metric.value }); });
        getFID((metric) => { this.metrics.FID = metric.value; onMetric({ name: 'FID', value: metric.value }); });
        getLCP((metric) => { this.metrics.LCP = metric.value; onMetric({ name: 'LCP', value: metric.value }); });
        getFCP((metric) => { this.metrics.FCP = metric.value; onMetric({ name: 'FCP', value: metric.value }); });
        getTTFB((metric) => { this.metrics.TTFB = metric.value; onMetric({ name: 'TTFB', value: metric.value }); });
    }
    
    getMetrics() {
        return this.metrics;
    }
    
    getScore(): { score: number; grade: 'good' | 'needs-improvement' | 'poor' } {
        const { LCP, FID, CLS } = this.metrics;
        
        let score = 100;
        
        // LCP: Good < 2.5s, Poor > 4s
        if (LCP > 4000) score -= 40;
        else if (LCP > 2500) score -= 20;
        
        // FID: Good < 100ms, Poor > 300ms
        if (FID > 300) score -= 30;
        else if (FID > 100) score -= 15;
        
        // CLS: Good < 0.1, Poor > 0.25
        if (CLS > 0.25) score -= 30;
        else if (CLS > 0.1) score -= 15;
        
        return {
            score,
            grade: score >= 80 ? 'good' : score >= 50 ? 'needs-improvement' : 'poor'
        };
    }
}

// Performance Hook
export function usePerformance() {
    const [metrics, setMetrics] = useState<Record<string, number>>({});
    
    useEffect(() => {
        const tracker = new WebVitalsTracker();
        tracker.init((metric) => {
            setMetrics(prev => ({ ...prev, [metric.name]: metric.value }));
        });
    }, []);
    
    return metrics;
}

// Memory Usage Tracking
class MemoryTracker {
    getMemoryUsage() {
        if ('memory' in performance) {
            const memory = (performance as any).memory;
            return {
                usedJSHeapSize: memory.usedJSHeapSize,
                totalJSHeapSize: memory.totalJSHeapSize,
                jsHeapSizeLimit: memory.jsHeapSizeLimit,
                usedPercentage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100
            };
        }
        return null;
    }
}

// Resource Timing
class ResourceTimingAnalyzer {
    analyze() {
        const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];
        
        return resources.map(r => ({
            name: r.name,
            type: r.initiatorType,
            duration: r.duration,
            size: r.transferSize,
            cached: r.transferSize === 0
        }));
    }
    
    getSlowResources(threshold = 1000) {
        return this.analyze().filter(r => r.duration > threshold);
    }
    
    getTotalSize() {
        return this.analyze().reduce((sum, r) => sum + (r.size || 0), 0);
    }
}

// Performance Budget
class PerformanceBudget {
    private budgets: Record<string, number> = {
        LCP: 2500,
        FID: 100,
        CLS: 0.1,
        totalSize: 1000000, // 1MB
        scriptSize: 300000  // 300KB
    };
    
    check(metrics: Record<string, number>): { passed: boolean; violations: string[] } {
        const violations: string[] = [];
        
        for (const [key, budget] of Object.entries(this.budgets)) {
            if (metrics[key] && metrics[key] > budget) {
                violations.push(\`\${key}: \${metrics[key]} exceeds budget \${budget}\`);
            }
        }
        
        return { passed: violations.length === 0, violations };
    }
}

export { WebVitalsTracker, MemoryTracker, ResourceTimingAnalyzer, PerformanceBudget };
`;
    }
}

export const performanceMonitor = PerformanceMonitor.getInstance();
