/**
 * âš¡ Performance Optimizer
 * 
 * Optimize web performance:
 * - Web Vitals, Lighthouse
 */

import { EventEmitter } from 'events';

export class PerformanceOptimizer extends EventEmitter {
    private static instance: PerformanceOptimizer;

    private constructor() { super(); }

    static getInstance(): PerformanceOptimizer {
        if (!PerformanceOptimizer.instance) {
            PerformanceOptimizer.instance = new PerformanceOptimizer();
        }
        return PerformanceOptimizer.instance;
    }

    generateWebVitals(): string {
        return `// Web Vitals Monitoring
// Generated by Shadow AI

import { onCLS, onFID, onLCP, onFCP, onTTFB, onINP } from 'web-vitals';

interface Metric {
    name: string;
    value: number;
    rating: 'good' | 'needs-improvement' | 'poor';
    id: string;
    delta: number;
}

// Report to analytics
function sendToAnalytics(metric: Metric) {
    const body = JSON.stringify({
        name: metric.name,
        value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
        rating: metric.rating,
        id: metric.id,
        page: window.location.pathname
    });

    // Use sendBeacon for reliable delivery
    if (navigator.sendBeacon) {
        navigator.sendBeacon('/api/analytics/vitals', body);
    } else {
        fetch('/api/analytics/vitals', { method: 'POST', body, keepalive: true });
    }
}

// Track all Core Web Vitals
export function trackWebVitals() {
    onCLS(sendToAnalytics);  // Cumulative Layout Shift
    onFID(sendToAnalytics);  // First Input Delay
    onLCP(sendToAnalytics);  // Largest Contentful Paint
    onFCP(sendToAnalytics);  // First Contentful Paint
    onTTFB(sendToAnalytics); // Time to First Byte
    onINP(sendToAnalytics);  // Interaction to Next Paint
}

// Thresholds
const thresholds = {
    LCP: { good: 2500, poor: 4000 },
    FID: { good: 100, poor: 300 },
    CLS: { good: 0.1, poor: 0.25 },
    FCP: { good: 1800, poor: 3000 },
    TTFB: { good: 800, poor: 1800 },
    INP: { good: 200, poor: 500 }
};

// Performance monitoring hook
function useWebVitals() {
    const [metrics, setMetrics] = useState<Record<string, Metric>>({});

    useEffect(() => {
        const handlers = {
            CLS: onCLS,
            FID: onFID,
            LCP: onLCP,
            FCP: onFCP,
            TTFB: onTTFB,
            INP: onINP
        };

        Object.entries(handlers).forEach(([name, handler]) => {
            handler((metric) => {
                setMetrics(prev => ({ ...prev, [name]: metric }));
            });
        });
    }, []);

    return metrics;
}

// Performance budget check
function checkPerformanceBudget(metrics: Record<string, Metric>) {
    const issues = [];
    
    for (const [name, metric] of Object.entries(metrics)) {
        const threshold = thresholds[name as keyof typeof thresholds];
        if (threshold && metric.value > threshold.poor) {
            issues.push(\`\${name} is poor (\${metric.value}ms, should be <\${threshold.good}ms)\`);
        }
    }
    
    return issues;
}

export { thresholds, useWebVitals, checkPerformanceBudget };
`;
    }

    generateOptimizations(): string {
        return `// Performance Optimizations
// Generated by Shadow AI

// === Image Optimization ===
import Image from 'next/image';

function OptimizedImage({ src, alt, ...props }) {
    return (
        <Image
            src={src}
            alt={alt}
            loading="lazy"
            placeholder="blur"
            blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMC..."
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            {...props}
        />
    );
}

// === Code Splitting ===
import dynamic from 'next/dynamic';
import { lazy, Suspense } from 'react';

// Next.js dynamic import
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
    loading: () => <Skeleton />,
    ssr: false
});

// React lazy
const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
    return (
        <Suspense fallback={<Loading />}>
            <LazyComponent />
        </Suspense>
    );
}

// === Prefetching ===
import { useRouter } from 'next/router';
import { useEffect } from 'react';

function usePrefetch(paths: string[]) {
    const router = useRouter();
    
    useEffect(() => {
        paths.forEach(path => router.prefetch(path));
    }, [paths, router]);
}

// === Resource Hints ===
function ResourceHints() {
    return (
        <>
            <link rel="preconnect" href="https://fonts.googleapis.com" />
            <link rel="preconnect" href="https://cdn.example.com" crossOrigin="anonymous" />
            <link rel="dns-prefetch" href="https://api.example.com" />
            <link rel="preload" href="/fonts/inter.woff2" as="font" type="font/woff2" crossOrigin="" />
            <link rel="modulepreload" href="/scripts/main.js" />
        </>
    );
}

// === Virtual List for Large Data ===
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualList({ items }) {
    const parentRef = useRef(null);
    
    const virtualizer = useVirtualizer({
        count: items.length,
        getScrollElement: () => parentRef.current,
        estimateSize: () => 50,
        overscan: 5
    });

    return (
        <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
            <div style={{ height: virtualizer.getTotalSize() + 'px', position: 'relative' }}>
                {virtualizer.getVirtualItems().map(virtualRow => (
                    <div
                        key={virtualRow.index}
                        style={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            width: '100%',
                            height: virtualRow.size + 'px',
                            transform: \`translateY(\${virtualRow.start}px)\`
                        }}
                    >
                        {items[virtualRow.index]}
                    </div>
                ))}
            </div>
        </div>
    );
}

// === Debounce and Throttle ===
function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState(value);
    
    useEffect(() => {
        const timer = setTimeout(() => setDebouncedValue(value), delay);
        return () => clearTimeout(timer);
    }, [value, delay]);
    
    return debouncedValue;
}

function useThrottle<T extends (...args: any[]) => any>(fn: T, delay: number) {
    const lastRun = useRef(0);
    
    return useCallback((...args: Parameters<T>) => {
        const now = Date.now();
        if (now - lastRun.current >= delay) {
            lastRun.current = now;
            return fn(...args);
        }
    }, [fn, delay]);
}

// === Memoization ===
import { useMemo, useCallback, memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
    const processedData = useMemo(() => {
        return data.map(item => expensiveOperation(item));
    }, [data]);
    
    const handleClick = useCallback((id) => {
        // Handle click
    }, []);
    
    return <div>{/* ... */}</div>;
});

export { OptimizedImage, usePrefetch, ResourceHints, VirtualList, useDebounce, useThrottle };
`;
    }
}

export const performanceOptimizer = PerformanceOptimizer.getInstance();
