/**
 * üîê PermissionGenerator
 * 
 * Permission system:
 * - Fine-grained, resource-based
 */

import { EventEmitter } from 'events';

export class PermissionGenerator extends EventEmitter {
    private static instance: PermissionGenerator;
    private constructor() { super(); }
    static getInstance(): PermissionGenerator {
        if (!PermissionGenerator.instance) {
            PermissionGenerator.instance = new PermissionGenerator();
        }
        return PermissionGenerator.instance;
    }

    generate(): string {
        return `// Permission Generator - Fine-grained, resource-based
// Generated by Shadow AI

// Permission Schema
model Permission {
    id          String   @id @default(cuid())
    action      String   // 'read', 'write', 'delete', 'admin'
    resource    String   // 'posts', 'users', 'settings'
    resourceId  String?  // specific resource ID or null for all
    userId      String?
    roleId      String?
    conditions  Json?    // additional conditions
    createdAt   DateTime @default(now())
    
    @@index([userId, resource, action])
    @@index([roleId, resource, action])
}

// Permission Service
class PermissionService {
    async can(userId: string, action: string, resource: string, resourceId?: string): Promise<boolean> {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            include: { roles: true }
        });
        
        if (!user) return false;
        
        // Check user-specific permissions
        const userPermission = await prisma.permission.findFirst({
            where: {
                userId,
                action,
                resource,
                OR: [
                    { resourceId: resourceId },
                    { resourceId: null }
                ]
            }
        });
        
        if (userPermission) {
            return this.evaluateConditions(userPermission.conditions, { userId, resourceId });
        }
        
        // Check role-based permissions
        for (const role of user.roles) {
            const rolePermission = await prisma.permission.findFirst({
                where: {
                    roleId: role.id,
                    action,
                    resource,
                    OR: [
                        { resourceId: resourceId },
                        { resourceId: null }
                    ]
                }
            });
            
            if (rolePermission) {
                return this.evaluateConditions(rolePermission.conditions, { userId, resourceId });
            }
        }
        
        return false;
    }
    
    async grantPermission(data: {
        userId?: string;
        roleId?: string;
        action: string;
        resource: string;
        resourceId?: string;
        conditions?: any;
    }) {
        return prisma.permission.create({ data });
    }
    
    async revokePermission(permissionId: string) {
        return prisma.permission.delete({ where: { id: permissionId } });
    }
    
    private evaluateConditions(conditions: any, context: any): boolean {
        if (!conditions) return true;
        
        // Example: { ownerId: '{{userId}}' }
        for (const [key, value] of Object.entries(conditions)) {
            if (typeof value === 'string' && value.startsWith('{{')) {
                const contextKey = value.slice(2, -2);
                if (context[contextKey] !== context[key]) return false;
            }
        }
        
        return true;
    }
}

// Express Middleware
function requirePermission(action: string, resource: string) {
    return async (req: any, res: any, next: Function) => {
        const userId = req.user?.id;
        const resourceId = req.params.id;
        
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        
        const allowed = await permissionService.can(userId, action, resource, resourceId);
        
        if (!allowed) {
            return res.status(403).json({ error: 'Forbidden' });
        }
        
        next();
    };
}

// React Hook
export function usePermission(action: string, resource: string, resourceId?: string) {
    const { data: user } = useUser();
    const [allowed, setAllowed] = useState<boolean | null>(null);
    
    useEffect(() => {
        if (user) {
            checkPermission(user.id, action, resource, resourceId).then(setAllowed);
        }
    }, [user, action, resource, resourceId]);
    
    return allowed;
}

export { PermissionService, requirePermission, usePermission };
`;
    }
}

export const permissionGenerator = PermissionGenerator.getInstance();
