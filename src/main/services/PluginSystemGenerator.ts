/**
 * ðŸ”§ Plugin System Generator
 * 
 * Extensible plugin architectures:
 * - Plugin loading, hooks, APIs
 */

import { EventEmitter } from 'events';

export class PluginSystemGenerator extends EventEmitter {
    private static instance: PluginSystemGenerator;

    private constructor() { super(); }

    static getInstance(): PluginSystemGenerator {
        if (!PluginSystemGenerator.instance) {
            PluginSystemGenerator.instance = new PluginSystemGenerator();
        }
        return PluginSystemGenerator.instance;
    }

    generate(): string {
        return `// Plugin System Generator
// Generated by Shadow AI

/**
 * PLUGIN SYSTEM GENERATOR
 * 
 * Generate extensible plugin architectures.
 */

interface PluginManifest {
    name: string;
    version: string;
    description: string;
    main: string;
    hooks: string[];
    permissions: string[];
    dependencies?: Record<string, string>;
}

interface Plugin {
    manifest: PluginManifest;
    instance: any;
    enabled: boolean;
}

// === Plugin Manager ===
class PluginManager extends EventEmitter {
    private plugins: Map<string, Plugin> = new Map();
    private hooks: Map<string, Set<Function>> = new Map();
    
    async loadPlugin(pluginPath: string): Promise<void> {
        const manifest = await this.loadManifest(pluginPath);
        
        // Validate permissions
        if (!this.validatePermissions(manifest.permissions)) {
            throw new Error(\`Plugin \${manifest.name} requires unauthorized permissions\`);
        }
        
        // Load plugin module
        const PluginClass = require(\`\${pluginPath}/\${manifest.main}\`);
        const instance = new PluginClass(this.createPluginAPI(manifest));
        
        // Register hooks
        for (const hook of manifest.hooks) {
            if (instance[hook]) {
                this.registerHook(hook, instance[hook].bind(instance));
            }
        }
        
        this.plugins.set(manifest.name, {
            manifest,
            instance,
            enabled: true
        });
        
        // Initialize plugin
        await instance.onLoad?.();
        
        this.emit('plugin:loaded', manifest.name);
    }
    
    async unloadPlugin(name: string): Promise<void> {
        const plugin = this.plugins.get(name);
        if (!plugin) return;
        
        // Call cleanup
        await plugin.instance.onUnload?.();
        
        // Unregister hooks
        for (const hook of plugin.manifest.hooks) {
            this.unregisterHook(hook, plugin.instance[hook]);
        }
        
        this.plugins.delete(name);
        this.emit('plugin:unloaded', name);
    }
    
    registerHook(name: string, callback: Function): void {
        if (!this.hooks.has(name)) {
            this.hooks.set(name, new Set());
        }
        this.hooks.get(name)!.add(callback);
    }
    
    async executeHook<T>(name: string, ...args: any[]): Promise<T[]> {
        const callbacks = this.hooks.get(name);
        if (!callbacks) return [];
        
        const results: T[] = [];
        for (const callback of callbacks) {
            try {
                const result = await callback(...args);
                results.push(result);
            } catch (error) {
                console.error(\`Hook \${name} error:\`, error);
            }
        }
        
        return results;
    }
    
    private createPluginAPI(manifest: PluginManifest): PluginAPI {
        return {
            // Storage
            storage: {
                get: async (key: string) => this.getStorage(manifest.name, key),
                set: async (key: string, value: any) => this.setStorage(manifest.name, key, value),
                delete: async (key: string) => this.deleteStorage(manifest.name, key)
            },
            
            // Events
            events: {
                on: (event: string, callback: Function) => this.on(\`plugin:\${manifest.name}:\${event}\`, callback),
                emit: (event: string, data: any) => this.emit(\`plugin:\${manifest.name}:\${event}\`, data)
            },
            
            // UI
            ui: {
                registerCommand: (cmd: Command) => this.registerCommand(manifest.name, cmd),
                registerPanel: (panel: Panel) => this.registerPanel(manifest.name, panel),
                showNotification: (msg: string) => this.showNotification(msg)
            },
            
            // Context
            context: {
                getActiveFile: () => this.getActiveFile(),
                getSelection: () => this.getSelection(),
                getWorkspace: () => this.getWorkspace()
            }
        };
    }
}

// === Plugin Template Generator ===
class PluginTemplateGenerator {
    generatePlugin(config: { name: string; description: string; hooks: string[] }): Map<string, string> {
        const files = new Map<string, string>();
        
        // manifest.json
        files.set('manifest.json', JSON.stringify({
            name: config.name,
            version: '1.0.0',
            description: config.description,
            main: 'index.js',
            hooks: config.hooks,
            permissions: ['storage', 'ui.notifications']
        }, null, 2));
        
        // index.ts
        files.set('index.ts', \`
// \${config.name} Plugin
// Generated by Shadow AI

import { PluginAPI } from '@shadow-ai/plugin-api';

export default class \${this.pascalCase(config.name)}Plugin {
    private api: PluginAPI;
    
    constructor(api: PluginAPI) {
        this.api = api;
    }
    
    async onLoad(): Promise<void> {
        console.log('\${config.name} plugin loaded');
        
        // Register commands
        this.api.ui.registerCommand({
            id: '\${config.name}.hello',
            title: 'Hello from \${config.name}',
            handler: () => this.sayHello()
        });
    }
    
    async onUnload(): Promise<void> {
        console.log('\${config.name} plugin unloaded');
    }
    
    // Hook implementations
    \${config.hooks.map(hook => \`
    async \${hook}(data: any): Promise<any> {
        // Implement \${hook} hook
        return data;
    }
    \`).join('\\n')}
    
    private sayHello(): void {
        this.api.ui.showNotification('Hello from \${config.name}!');
    }
}
        \`);
        
        // package.json
        files.set('package.json', JSON.stringify({
            name: \`@shadow-ai/plugin-\${config.name}\`,
            version: '1.0.0',
            main: 'dist/index.js',
            types: 'dist/index.d.ts',
            scripts: {
                build: 'tsc',
                watch: 'tsc -w'
            },
            devDependencies: {
                '@shadow-ai/plugin-api': '^1.0.0',
                typescript: '^5.0.0'
            }
        }, null, 2));
        
        return files;
    }
    
    private pascalCase(str: string): string {
        return str.split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
    }
}

export { PluginManager, PluginTemplateGenerator };
`;
    }
}

export const pluginSystemGenerator = PluginSystemGenerator.getInstance();
