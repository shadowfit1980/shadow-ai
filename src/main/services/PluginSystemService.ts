/**
 * ðŸ”Œ PluginSystemService
 * 
 * Plugin architecture:
 * - Loading, hot reload, API
 */

import { EventEmitter } from 'events';

export class PluginSystemService extends EventEmitter {
    private static instance: PluginSystemService;
    private constructor() { super(); }
    static getInstance(): PluginSystemService {
        if (!PluginSystemService.instance) {
            PluginSystemService.instance = new PluginSystemService();
        }
        return PluginSystemService.instance;
    }

    generate(): string {
        return `// Plugin System Service - Loading, hot reload
// Generated by Shadow AI

interface Plugin {
    name: string;
    version: string;
    description: string;
    activate: (api: PluginAPI) => Promise<void>;
    deactivate: () => Promise<void>;
}

interface PluginAPI {
    registerCommand: (name: string, handler: Function) => void;
    registerTool: (tool: Tool) => void;
    registerLanguage: (language: LanguageSupport) => void;
    getConfig: (key: string) => any;
    setConfig: (key: string, value: any) => void;
    showNotification: (message: string, type: 'info' | 'warning' | 'error') => void;
    openFile: (path: string) => Promise<void>;
    executeCommand: (name: string, ...args: any[]) => Promise<any>;
}

class PluginManager {
    private plugins: Map<string, Plugin> = new Map();
    private api: PluginAPI;
    
    constructor(api: PluginAPI) {
        this.api = api;
    }
    
    // Load plugin from path
    async loadPlugin(pluginPath: string): Promise<Plugin> {
        const manifest = await fs.readJson(path.join(pluginPath, 'package.json'));
        const entry = path.join(pluginPath, manifest.main || 'index.js');
        
        // Clear require cache for hot reload
        delete require.cache[require.resolve(entry)];
        
        const plugin = require(entry) as Plugin;
        
        await plugin.activate(this.api);
        this.plugins.set(plugin.name, plugin);
        
        console.log(\`Loaded plugin: \${plugin.name} v\${plugin.version}\`);
        
        return plugin;
    }
    
    // Unload plugin
    async unloadPlugin(name: string): Promise<void> {
        const plugin = this.plugins.get(name);
        if (!plugin) throw new Error(\`Plugin not found: \${name}\`);
        
        await plugin.deactivate();
        this.plugins.delete(name);
        
        console.log(\`Unloaded plugin: \${name}\`);
    }
    
    // Reload plugin
    async reloadPlugin(name: string): Promise<void> {
        const plugin = this.plugins.get(name);
        if (!plugin) throw new Error(\`Plugin not found: \${name}\`);
        
        await this.unloadPlugin(name);
        // Re-load from original path
    }
    
    // Get all plugins
    getPlugins(): Plugin[] {
        return Array.from(this.plugins.values());
    }
    
    // Get plugin by name
    getPlugin(name: string): Plugin | undefined {
        return this.plugins.get(name);
    }
    
    // Install from npm
    async installFromNpm(packageName: string): Promise<void> {
        const { execAsync } = require('./utils');
        
        await execAsync(\`npm install \${packageName}\`, {
            cwd: this.getPluginsDir()
        });
        
        await this.loadPlugin(path.join(this.getPluginsDir(), 'node_modules', packageName));
    }
    
    // Discover plugins
    async discoverPlugins(): Promise<string[]> {
        const pluginsDir = this.getPluginsDir();
        const entries = await fs.readdir(pluginsDir, { withFileTypes: true });
        
        const plugins: string[] = [];
        
        for (const entry of entries) {
            if (entry.isDirectory()) {
                const manifestPath = path.join(pluginsDir, entry.name, 'package.json');
                if (await fs.exists(manifestPath)) {
                    plugins.push(path.join(pluginsDir, entry.name));
                }
            }
        }
        
        return plugins;
    }
    
    private getPluginsDir(): string {
        return path.join(app.getPath('userData'), 'plugins');
    }
}

export { PluginManager, Plugin, PluginAPI };
`;
    }
}

export const pluginSystemService = PluginSystemService.getInstance();
