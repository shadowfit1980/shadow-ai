/**
 * ðŸ“¬ Queue System Generator
 * 
 * Generate job queues:
 * - BullMQ, RabbitMQ patterns
 */

import { EventEmitter } from 'events';

export class QueueSystemGenerator extends EventEmitter {
    private static instance: QueueSystemGenerator;

    private constructor() { super(); }

    static getInstance(): QueueSystemGenerator {
        if (!QueueSystemGenerator.instance) {
            QueueSystemGenerator.instance = new QueueSystemGenerator();
        }
        return QueueSystemGenerator.instance;
    }

    generateBullMQ(): string {
        return `// BullMQ Job Queue
// Generated by Shadow AI

import { Queue, Worker, Job, QueueEvents } from 'bullmq';
import Redis from 'ioredis';

const connection = new Redis(process.env.REDIS_URL!, { maxRetriesPerRequest: null });

// Queue Definition
interface EmailJobData {
    to: string;
    subject: string;
    template: string;
    data: Record<string, any>;
}

const emailQueue = new Queue<EmailJobData>('emails', { connection });

// Add job
async function sendEmail(data: EmailJobData, delay?: number) {
    return emailQueue.add('send', data, {
        delay,
        attempts: 3,
        backoff: { type: 'exponential', delay: 1000 },
        removeOnComplete: { age: 3600 },
        removeOnFail: { age: 24 * 3600 }
    });
}

// Scheduled/recurring jobs
async function scheduleWeeklyReport() {
    await emailQueue.add('weekly-report', { template: 'weekly-report' }, {
        repeat: { pattern: '0 9 * * MON' } // Every Monday at 9 AM
    });
}

// Worker
const emailWorker = new Worker<EmailJobData>('emails', async (job: Job<EmailJobData>) => {
    console.log(\`Processing job \${job.id}: \${job.name}\`);
    
    const { to, subject, template, data } = job.data;
    
    // Update progress
    await job.updateProgress(10);
    
    // Render template
    const html = await renderTemplate(template, data);
    await job.updateProgress(50);
    
    // Send email
    await transporter.sendMail({ to, subject, html });
    await job.updateProgress(100);
    
    return { sent: true, timestamp: new Date() };
}, {
    connection,
    concurrency: 5,
    limiter: { max: 100, duration: 60000 } // 100 per minute
});

// Event handling
emailWorker.on('completed', (job, result) => {
    console.log(\`Job \${job.id} completed\`, result);
});

emailWorker.on('failed', (job, error) => {
    console.error(\`Job \${job?.id} failed\`, error);
    // Send to error tracking
});

emailWorker.on('progress', (job, progress) => {
    console.log(\`Job \${job.id} progress: \${progress}%\`);
});

// Queue Events (for monitoring)
const queueEvents = new QueueEvents('emails', { connection });

queueEvents.on('waiting', ({ jobId }) => console.log(\`Job \${jobId} is waiting\`));
queueEvents.on('active', ({ jobId }) => console.log(\`Job \${jobId} is active\`));
queueEvents.on('completed', ({ jobId }) => console.log(\`Job \${jobId} completed\`));
queueEvents.on('failed', ({ jobId, failedReason }) => console.log(\`Job \${jobId} failed: \${failedReason}\`));

// Flow (parent-child jobs)
import { FlowProducer } from 'bullmq';

const flowProducer = new FlowProducer({ connection });

async function createOrderFlow(orderId: string) {
    return flowProducer.add({
        name: 'complete-order',
        queueName: 'orders',
        data: { orderId },
        children: [
            { name: 'send-confirmation', queueName: 'emails', data: { orderId } },
            { name: 'update-inventory', queueName: 'inventory', data: { orderId } },
            { name: 'notify-warehouse', queueName: 'notifications', data: { orderId } }
        ]
    });
}

// Graceful shutdown
async function shutdown() {
    await emailWorker.close();
    await emailQueue.close();
    await queueEvents.close();
    process.exit(0);
}

process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);

export { emailQueue, sendEmail, emailWorker };
`;
    }
}

export const queueSystemGenerator = QueueSystemGenerator.getInstance();
