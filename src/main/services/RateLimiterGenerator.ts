/**
 * ðŸ“Š RateLimiterGenerator
 * 
 * Rate limiting:
 * - Token bucket, sliding window, distributed
 */

import { EventEmitter } from 'events';

export class RateLimiterGenerator extends EventEmitter {
    private static instance: RateLimiterGenerator;
    private constructor() { super(); }
    static getInstance(): RateLimiterGenerator {
        if (!RateLimiterGenerator.instance) {
            RateLimiterGenerator.instance = new RateLimiterGenerator();
        }
        return RateLimiterGenerator.instance;
    }

    generate(): string {
        return `// Rate Limiter Generator - Token bucket, sliding window
// Generated by Shadow AI

import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Token Bucket Algorithm
class TokenBucketLimiter {
    constructor(
        private capacity: number,
        private refillRate: number, // tokens per second
        private keyPrefix: string = 'ratelimit:'
    ) {}
    
    async consume(identifier: string, tokens = 1): Promise<{ allowed: boolean; remaining: number; retryAfter?: number }> {
        const key = this.keyPrefix + identifier;
        const now = Date.now();
        
        const data = await redis.get(key);
        let bucket = data ? JSON.parse(data) : { tokens: this.capacity, lastRefill: now };
        
        // Refill tokens
        const timePassed = (now - bucket.lastRefill) / 1000;
        bucket.tokens = Math.min(this.capacity, bucket.tokens + timePassed * this.refillRate);
        bucket.lastRefill = now;
        
        if (bucket.tokens >= tokens) {
            bucket.tokens -= tokens;
            await redis.set(key, JSON.stringify(bucket), 'EX', 3600);
            return { allowed: true, remaining: Math.floor(bucket.tokens) };
        }
        
        const retryAfter = (tokens - bucket.tokens) / this.refillRate;
        return { allowed: false, remaining: 0, retryAfter: Math.ceil(retryAfter) };
    }
}

// Sliding Window Algorithm
class SlidingWindowLimiter {
    constructor(
        private limit: number,
        private windowMs: number,
        private keyPrefix: string = 'ratelimit:sw:'
    ) {}
    
    async consume(identifier: string): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {
        const key = this.keyPrefix + identifier;
        const now = Date.now();
        const windowStart = now - this.windowMs;
        
        // Remove old entries
        await redis.zremrangebyscore(key, 0, windowStart);
        
        // Count current window
        const count = await redis.zcard(key);
        
        if (count < this.limit) {
            await redis.zadd(key, now, \`\${now}:\${Math.random()}\`);
            await redis.expire(key, Math.ceil(this.windowMs / 1000));
            return { allowed: true, remaining: this.limit - count - 1, resetAt: now + this.windowMs };
        }
        
        return { allowed: false, remaining: 0, resetAt: now + this.windowMs };
    }
}

// Rate Limit Middleware
function rateLimitMiddleware(limiter: TokenBucketLimiter | SlidingWindowLimiter) {
    return async (req: any, res: any, next: Function) => {
        const identifier = req.user?.id || req.ip;
        const result = await limiter.consume(identifier);
        
        res.set('X-RateLimit-Remaining', result.remaining.toString());
        
        if (!result.allowed) {
            res.set('Retry-After', result.retryAfter?.toString() || '60');
            return res.status(429).json({ error: 'Too many requests' });
        }
        
        next();
    };
}

// Tiered Rate Limiting
class TieredRateLimiter {
    private tiers: Map<string, { limit: number; windowMs: number }> = new Map([
        ['free', { limit: 100, windowMs: 60000 }],
        ['pro', { limit: 1000, windowMs: 60000 }],
        ['enterprise', { limit: 10000, windowMs: 60000 }]
    ]);
    
    async consume(identifier: string, tier: string) {
        const config = this.tiers.get(tier) || this.tiers.get('free')!;
        const limiter = new SlidingWindowLimiter(config.limit, config.windowMs, \`ratelimit:\${tier}:\`);
        return limiter.consume(identifier);
    }
}

export { TokenBucketLimiter, SlidingWindowLimiter, rateLimitMiddleware, TieredRateLimiter };
`;
    }
}

export const rateLimiterGenerator = RateLimiterGenerator.getInstance();
