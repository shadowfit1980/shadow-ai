/**
 * ðŸ”„ Realtime Sync Engine
 * 
 * Real-time data synchronization:
 * - Conflict resolution, offline-first
 */

import { EventEmitter } from 'events';

export class RealtimeSyncEngine extends EventEmitter {
    private static instance: RealtimeSyncEngine;

    private constructor() { super(); }

    static getInstance(): RealtimeSyncEngine {
        if (!RealtimeSyncEngine.instance) {
            RealtimeSyncEngine.instance = new RealtimeSyncEngine();
        }
        return RealtimeSyncEngine.instance;
    }

    generate(): string {
        return `// Realtime Sync Engine
// Generated by Shadow AI

/**
 * REALTIME SYNC ENGINE
 * 
 * Real-time data sync with conflict resolution and offline support.
 */

interface SyncConfig {
    strategy: 'last-write-wins' | 'merge' | 'manual';
    conflictResolution: 'client' | 'server' | 'timestamp' | 'custom';
    offlineSupport: boolean;
    syncInterval: number;
}

// === CRDT Implementation ===
class CRDTDocument<T> {
    private clock: VectorClock = new VectorClock();
    private operations: Operation[] = [];
    private state: T;
    
    constructor(initialState: T, private nodeId: string) {
        this.state = initialState;
    }
    
    update(path: string[], value: any): Operation {
        const op: Operation = {
            id: crypto.randomUUID(),
            type: 'set',
            path,
            value,
            timestamp: this.clock.increment(this.nodeId),
            nodeId: this.nodeId
        };
        
        this.operations.push(op);
        this.applyOperation(op);
        
        return op;
    }
    
    merge(remoteOps: Operation[]): void {
        for (const op of remoteOps) {
            if (!this.hasOperation(op.id)) {
                this.operations.push(op);
                this.clock.merge(op.timestamp);
                this.applyOperation(op);
            }
        }
        
        // Re-sort and replay
        this.operations.sort((a, b) => this.compareTimestamps(a.timestamp, b.timestamp));
        this.rebuildState();
    }
    
    private applyOperation(op: Operation): void {
        let current: any = this.state;
        for (let i = 0; i < op.path.length - 1; i++) {
            current = current[op.path[i]];
        }
        current[op.path[op.path.length - 1]] = op.value;
    }
}

// === Vector Clock ===
class VectorClock {
    private clock: Map<string, number> = new Map();
    
    increment(nodeId: string): Map<string, number> {
        this.clock.set(nodeId, (this.clock.get(nodeId) || 0) + 1);
        return new Map(this.clock);
    }
    
    merge(other: Map<string, number>): void {
        for (const [node, time] of other) {
            this.clock.set(node, Math.max(this.clock.get(node) || 0, time));
        }
    }
    
    compare(a: Map<string, number>, b: Map<string, number>): -1 | 0 | 1 {
        let aGreater = false, bGreater = false;
        
        const allKeys = new Set([...a.keys(), ...b.keys()]);
        for (const key of allKeys) {
            const aVal = a.get(key) || 0;
            const bVal = b.get(key) || 0;
            if (aVal > bVal) aGreater = true;
            if (bVal > aVal) bGreater = true;
        }
        
        if (aGreater && !bGreater) return 1;
        if (bGreater && !aGreater) return -1;
        return 0; // Concurrent
    }
}

// === Sync Client ===
class SyncClient {
    private ws: WebSocket | null = null;
    private documents: Map<string, CRDTDocument<any>> = new Map();
    private pendingOps: Operation[] = [];
    private online = true;
    
    async connect(serverUrl: string): Promise<void> {
        this.ws = new WebSocket(serverUrl);
        
        this.ws.onopen = () => {
            this.online = true;
            this.flushPendingOps();
        };
        
        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        };
        
        this.ws.onclose = () => {
            this.online = false;
            setTimeout(() => this.connect(serverUrl), 5000);
        };
    }
    
    subscribe(docId: string, initialState: any): CRDTDocument<any> {
        const doc = new CRDTDocument(initialState, this.getNodeId());
        this.documents.set(docId, doc);
        
        this.send({ type: 'subscribe', docId });
        
        return doc;
    }
    
    update(docId: string, path: string[], value: any): void {
        const doc = this.documents.get(docId);
        if (!doc) throw new Error('Document not found');
        
        const op = doc.update(path, value);
        
        if (this.online) {
            this.send({ type: 'operation', docId, operation: op });
        } else {
            this.pendingOps.push({ ...op, docId });
            this.saveToLocalStorage();
        }
    }
    
    private handleMessage(message: any): void {
        switch (message.type) {
            case 'sync':
                const doc = this.documents.get(message.docId);
                doc?.merge(message.operations);
                break;
            case 'operation':
                const targetDoc = this.documents.get(message.docId);
                targetDoc?.merge([message.operation]);
                break;
        }
    }
    
    private flushPendingOps(): void {
        for (const op of this.pendingOps) {
            this.send({ type: 'operation', docId: op.docId, operation: op });
        }
        this.pendingOps = [];
        localStorage.removeItem('pending_ops');
    }
    
    private saveToLocalStorage(): void {
        localStorage.setItem('pending_ops', JSON.stringify(this.pendingOps));
    }
}

// === React Hook ===
function generateReactHook(): string {
    return \`
// useSyncDocument.ts - Generated by Shadow AI
import { useState, useEffect, useCallback } from 'react';
import { SyncClient } from './SyncClient';

const client = new SyncClient();

export function useSyncDocument<T>(docId: string, initialState: T) {
    const [state, setState] = useState<T>(initialState);
    const [syncing, setSyncing] = useState(false);
    
    useEffect(() => {
        const doc = client.subscribe(docId, initialState);
        
        doc.on('change', (newState: T) => {
            setState(newState);
        });
        
        doc.on('sync', () => setSyncing(false));
        doc.on('syncing', () => setSyncing(true));
        
        return () => {
            client.unsubscribe(docId);
        };
    }, [docId]);
    
    const update = useCallback((path: string[], value: any) => {
        client.update(docId, path, value);
    }, [docId]);
    
    return { state, update, syncing };
}
    \`;
}

export { CRDTDocument, VectorClock, SyncClient, generateReactHook };
`;
    }
}

export const realtimeSyncEngine = RealtimeSyncEngine.getInstance();
