/**
 * ðŸ”´ Redis Patterns Generator
 * 
 * Generate Redis patterns:
 * - Caching, Pub/Sub, Queues
 */

import { EventEmitter } from 'events';

export class RedisPatterns extends EventEmitter {
    private static instance: RedisPatterns;

    private constructor() { super(); }

    static getInstance(): RedisPatterns {
        if (!RedisPatterns.instance) {
            RedisPatterns.instance = new RedisPatterns();
        }
        return RedisPatterns.instance;
    }

    generatePatterns(): string {
        return `// Redis Patterns
// Generated by Shadow AI

import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);
const subscriber = new Redis(process.env.REDIS_URL);

// === CACHING ===
class CacheService {
    private defaultTTL = 3600; // 1 hour

    async get<T>(key: string): Promise<T | null> {
        const data = await redis.get(key);
        return data ? JSON.parse(data) : null;
    }

    async set<T>(key: string, value: T, ttl = this.defaultTTL): Promise<void> {
        await redis.setex(key, ttl, JSON.stringify(value));
    }

    async getOrSet<T>(key: string, fn: () => Promise<T>, ttl = this.defaultTTL): Promise<T> {
        const cached = await this.get<T>(key);
        if (cached) return cached;

        const value = await fn();
        await this.set(key, value, ttl);
        return value;
    }

    async invalidate(pattern: string): Promise<void> {
        const keys = await redis.keys(pattern);
        if (keys.length) await redis.del(...keys);
    }

    async invalidateByTags(tags: string[]): Promise<void> {
        for (const tag of tags) {
            const keys = await redis.smembers(\`tag:\${tag}\`);
            if (keys.length) {
                await redis.del(...keys);
                await redis.del(\`tag:\${tag}\`);
            }
        }
    }

    async setWithTags<T>(key: string, value: T, tags: string[], ttl = this.defaultTTL): Promise<void> {
        const pipeline = redis.pipeline();
        pipeline.setex(key, ttl, JSON.stringify(value));
        for (const tag of tags) {
            pipeline.sadd(\`tag:\${tag}\`, key);
            pipeline.expire(\`tag:\${tag}\`, ttl);
        }
        await pipeline.exec();
    }
}

// === PUB/SUB ===
class PubSubService {
    private handlers = new Map<string, Function[]>();

    constructor() {
        subscriber.on('message', (channel, message) => {
            const handlers = this.handlers.get(channel) || [];
            const data = JSON.parse(message);
            handlers.forEach(handler => handler(data));
        });
    }

    subscribe(channel: string, handler: (data: any) => void) {
        if (!this.handlers.has(channel)) {
            this.handlers.set(channel, []);
            subscriber.subscribe(channel);
        }
        this.handlers.get(channel)!.push(handler);
    }

    unsubscribe(channel: string, handler: (data: any) => void) {
        const handlers = this.handlers.get(channel);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index !== -1) handlers.splice(index, 1);
            if (handlers.length === 0) {
                subscriber.unsubscribe(channel);
                this.handlers.delete(channel);
            }
        }
    }

    publish(channel: string, data: any) {
        return redis.publish(channel, JSON.stringify(data));
    }
}

// === RATE LIMITING ===
class RateLimiter {
    async check(key: string, limit: number, windowSeconds: number): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {
        const now = Date.now();
        const windowStart = now - (windowSeconds * 1000);
        const fullKey = \`ratelimit:\${key}\`;

        const pipeline = redis.pipeline();
        pipeline.zremrangebyscore(fullKey, 0, windowStart);
        pipeline.zadd(fullKey, now.toString(), now.toString());
        pipeline.zcard(fullKey);
        pipeline.expire(fullKey, windowSeconds);

        const results = await pipeline.exec();
        const count = results![2][1] as number;

        return {
            allowed: count <= limit,
            remaining: Math.max(0, limit - count),
            resetAt: now + (windowSeconds * 1000)
        };
    }
}

// === DISTRIBUTED LOCK ===
class DistributedLock {
    async acquire(key: string, ttl = 30000): Promise<string | null> {
        const lockId = Math.random().toString(36);
        const result = await redis.set(\`lock:\${key}\`, lockId, 'PX', ttl, 'NX');
        return result === 'OK' ? lockId : null;
    }

    async release(key: string, lockId: string): Promise<boolean> {
        const script = \`
            if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
            else
                return 0
            end
        \`;
        const result = await redis.eval(script, 1, \`lock:\${key}\`, lockId);
        return result === 1;
    }

    async withLock<T>(key: string, fn: () => Promise<T>, ttl = 30000): Promise<T> {
        const lockId = await this.acquire(key, ttl);
        if (!lockId) throw new Error('Failed to acquire lock');

        try {
            return await fn();
        } finally {
            await this.release(key, lockId);
        }
    }
}

// === SESSION STORE ===
class SessionStore {
    private prefix = 'session:';
    private ttl = 86400; // 24 hours

    async get(sessionId: string) {
        const data = await redis.get(this.prefix + sessionId);
        return data ? JSON.parse(data) : null;
    }

    async set(sessionId: string, data: any) {
        await redis.setex(this.prefix + sessionId, this.ttl, JSON.stringify(data));
    }

    async destroy(sessionId: string) {
        await redis.del(this.prefix + sessionId);
    }

    async touch(sessionId: string) {
        await redis.expire(this.prefix + sessionId, this.ttl);
    }
}

// === LEADERBOARD ===
class Leaderboard {
    constructor(private key: string) {}

    async addScore(userId: string, score: number) {
        await redis.zadd(this.key, score.toString(), userId);
    }

    async getTop(count = 10) {
        return redis.zrevrange(this.key, 0, count - 1, 'WITHSCORES');
    }

    async getRank(userId: string) {
        const rank = await redis.zrevrank(this.key, userId);
        return rank !== null ? rank + 1 : null;
    }

    async getScore(userId: string) {
        return redis.zscore(this.key, userId);
    }
}

export { CacheService, PubSubService, RateLimiter, DistributedLock, SessionStore, Leaderboard };
`;
    }
}

export const redisPatterns = RedisPatterns.getInstance();
