/**
 * üíø Remix Generator
 * 
 * Generate Remix applications:
 * - Loaders, actions, forms
 */

import { EventEmitter } from 'events';

export class RemixGenerator extends EventEmitter {
    private static instance: RemixGenerator;

    private constructor() { super(); }

    static getInstance(): RemixGenerator {
        if (!RemixGenerator.instance) {
            RemixGenerator.instance = new RemixGenerator();
        }
        return RemixGenerator.instance;
    }

    generate(): string {
        return `// Remix Application
// Generated by Shadow AI

// === Root Route (app/root.tsx) ===
import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData, useRouteError, isRouteErrorResponse } from '@remix-run/react';
import { json, type LinksFunction, type LoaderFunctionArgs, type MetaFunction } from '@remix-run/node';
import stylesheet from '~/styles/global.css';

export const links: LinksFunction = () => [
    { rel: 'stylesheet', href: stylesheet },
    { rel: 'preconnect', href: 'https://fonts.googleapis.com' }
];

export const meta: MetaFunction = () => [
    { title: 'My Remix App' },
    { name: 'description', content: 'Built with Remix' }
];

export async function loader({ request }: LoaderFunctionArgs) {
    const user = await getUser(request);
    return json({ user });
}

export default function App() {
    const { user } = useLoaderData<typeof loader>();
    
    return (
        <html lang="en">
            <head>
                <meta charSet="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <Meta />
                <Links />
            </head>
            <body>
                <header>
                    <nav>
                        <a href="/">Home</a>
                        {user ? <a href="/dashboard">Dashboard</a> : <a href="/login">Login</a>}
                    </nav>
                </header>
                <main>
                    <Outlet />
                </main>
                <ScrollRestoration />
                <Scripts />
                <LiveReload />
            </body>
        </html>
    );
}

export function ErrorBoundary() {
    const error = useRouteError();
    
    if (isRouteErrorResponse(error)) {
        return (
            <div>
                <h1>{error.status} {error.statusText}</h1>
                <p>{error.data}</p>
            </div>
        );
    }
    
    return (
        <div>
            <h1>Error</h1>
            <p>{error instanceof Error ? error.message : 'Unknown error'}</p>
        </div>
    );
}

// === Route with Loader (app/routes/_index.tsx) ===
import { json, type LoaderFunctionArgs } from '@remix-run/node';
import { useLoaderData, Link } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
    const posts = await db.post.findMany({
        take: 10,
        orderBy: { createdAt: 'desc' },
        include: { author: true }
    });
    
    return json({ posts });
}

export default function Index() {
    const { posts } = useLoaderData<typeof loader>();
    
    return (
        <div>
            <h1>Latest Posts</h1>
            <ul>
                {posts.map(post => (
                    <li key={post.id}>
                        <Link to={\`/posts/\${post.id}\`}>{post.title}</Link>
                        <span>by {post.author.name}</span>
                    </li>
                ))}
            </ul>
        </div>
    );
}

// === Route with Action (app/routes/posts.new.tsx) ===
import { json, redirect, type ActionFunctionArgs, type LoaderFunctionArgs } from '@remix-run/node';
import { Form, useActionData, useNavigation } from '@remix-run/react';
import { z } from 'zod';

const PostSchema = z.object({
    title: z.string().min(3, 'Title must be at least 3 characters'),
    content: z.string().min(10, 'Content must be at least 10 characters')
});

export async function loader({ request }: LoaderFunctionArgs) {
    const user = await requireUser(request);
    return json({ user });
}

export async function action({ request }: ActionFunctionArgs) {
    const user = await requireUser(request);
    const formData = await request.formData();
    
    const data = Object.fromEntries(formData);
    const result = PostSchema.safeParse(data);
    
    if (!result.success) {
        return json({ errors: result.error.flatten().fieldErrors }, { status: 400 });
    }
    
    const post = await db.post.create({
        data: {
            title: result.data.title,
            content: result.data.content,
            authorId: user.id
        }
    });
    
    return redirect(\`/posts/\${post.id}\`);
}

export default function NewPost() {
    const actionData = useActionData<typeof action>();
    const navigation = useNavigation();
    const isSubmitting = navigation.state === 'submitting';
    
    return (
        <Form method="post">
            <div>
                <label htmlFor="title">Title</label>
                <input type="text" name="title" id="title" required />
                {actionData?.errors?.title && <span>{actionData.errors.title}</span>}
            </div>
            
            <div>
                <label htmlFor="content">Content</label>
                <textarea name="content" id="content" rows={10} required />
                {actionData?.errors?.content && <span>{actionData.errors.content}</span>}
            </div>
            
            <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Creating...' : 'Create Post'}
            </button>
        </Form>
    );
}

// === Dynamic Route (app/routes/posts.$postId.tsx) ===
import { json, type LoaderFunctionArgs, type ActionFunctionArgs } from '@remix-run/node';
import { useLoaderData, useFetcher } from '@remix-run/react';
import invariant from 'tiny-invariant';

export async function loader({ params }: LoaderFunctionArgs) {
    invariant(params.postId, 'Post ID is required');
    
    const post = await db.post.findUnique({
        where: { id: params.postId },
        include: { author: true, comments: { include: { author: true } } }
    });
    
    if (!post) {
        throw new Response('Not Found', { status: 404 });
    }
    
    return json({ post });
}

export async function action({ request, params }: ActionFunctionArgs) {
    invariant(params.postId, 'Post ID is required');
    const formData = await request.formData();
    const intent = formData.get('intent');
    
    switch (intent) {
        case 'like':
            await db.post.update({ where: { id: params.postId }, data: { likes: { increment: 1 } } });
            return json({ success: true });
        case 'comment':
            const content = formData.get('content') as string;
            await db.comment.create({ data: { content, postId: params.postId, authorId: userId } });
            return json({ success: true });
        default:
            return json({ error: 'Invalid intent' }, { status: 400 });
    }
}

export default function Post() {
    const { post } = useLoaderData<typeof loader>();
    const fetcher = useFetcher();
    
    return (
        <article>
            <h1>{post.title}</h1>
            <p>{post.content}</p>
            
            <fetcher.Form method="post">
                <input type="hidden" name="intent" value="like" />
                <button type="submit">‚ù§Ô∏è {post.likes}</button>
            </fetcher.Form>
        </article>
    );
}

export { RemixGenerator };
`;
    }
}

export const remixGenerator = RemixGenerator.getInstance();
