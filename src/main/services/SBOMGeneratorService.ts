/**
 * ðŸ”’ SBOMGeneratorService
 * 
 * Software Bill of Materials:
 * - Dependencies, vulnerabilities, licenses
 */

import { EventEmitter } from 'events';

export class SBOMGeneratorService extends EventEmitter {
    private static instance: SBOMGeneratorService;
    private constructor() { super(); }
    static getInstance(): SBOMGeneratorService {
        if (!SBOMGeneratorService.instance) {
            SBOMGeneratorService.instance = new SBOMGeneratorService();
        }
        return SBOMGeneratorService.instance;
    }

    generate(): string {
        return `// SBOM Generator Service - Software Bill of Materials
// Generated by Shadow AI

interface SBOMComponent {
    name: string;
    version: string;
    type: 'library' | 'framework' | 'application' | 'operating-system';
    supplier?: string;
    licenses: string[];
    purl?: string; // Package URL
    cpe?: string;  // Common Platform Enumeration
    hashes?: Record<string, string>;
    vulnerabilities: Vulnerability[];
}

interface SBOM {
    format: 'CycloneDX' | 'SPDX';
    version: string;
    serialNumber: string;
    timestamp: string;
    components: SBOMComponent[];
    dependencies: Dependency[];
    metadata: SBOMMetadata;
}

class SBOMGenerator {
    // Generate SBOM for project
    async generate(projectPath: string, format: 'CycloneDX' | 'SPDX' = 'CycloneDX'): Promise<SBOM> {
        // Read package files
        const pkgJson = await this.readPackageJson(projectPath);
        const lockFile = await this.readLockFile(projectPath);
        
        const components: SBOMComponent[] = [];
        const dependencies: Dependency[] = [];
        
        // Process all dependencies
        for (const [name, details] of Object.entries(lockFile.packages || lockFile.dependencies || {})) {
            const component = await this.analyzeComponent(name, details);
            components.push(component);
            
            // Track dependencies
            if ((details as any).dependencies) {
                for (const dep of Object.keys((details as any).dependencies)) {
                    dependencies.push({ from: name, to: dep });
                }
            }
        }
        
        // Check all vulnerabilities
        const vulnReport = await this.checkVulnerabilities(components);
        
        // Merge vulnerability data
        for (const vuln of vulnReport) {
            const component = components.find(c => c.name === vuln.package);
            if (component) {
                component.vulnerabilities.push(vuln);
            }
        }
        
        return {
            format,
            version: format === 'CycloneDX' ? '1.5' : '2.3',
            serialNumber: \`urn:uuid:\${crypto.randomUUID()}\`,
            timestamp: new Date().toISOString(),
            components,
            dependencies,
            metadata: {
                tool: 'Shadow AI SBOM Generator',
                version: '1.0.0',
                projectName: pkgJson.name,
                projectVersion: pkgJson.version
            }
        };
    }
    
    private async analyzeComponent(name: string, details: any): Promise<SBOMComponent> {
        const version = details.version || details;
        
        return {
            name: name.replace('node_modules/', ''),
            version,
            type: 'library',
            licenses: await this.detectLicenses(name, version),
            purl: \`pkg:npm/\${name}@\${version}\`,
            vulnerabilities: []
        };
    }
    
    private async detectLicenses(name: string, version: string): Promise<string[]> {
        try {
            const response = await fetch(\`https://registry.npmjs.org/\${name}/\${version}\`);
            const data = await response.json();
            
            if (data.license) {
                return [data.license];
            }
            if (data.licenses) {
                return data.licenses.map((l: any) => l.type || l);
            }
        } catch (error) {
            // Ignore errors
        }
        
        return ['UNKNOWN'];
    }
    
    private async checkVulnerabilities(components: SBOMComponent[]): Promise<Vulnerability[]> {
        const vulnerabilities: Vulnerability[] = [];
        
        // Would call OSV or npm audit API
        // Simplified for now
        
        return vulnerabilities;
    }
    
    // Export formats
    exportCycloneDX(sbom: SBOM): string {
        return JSON.stringify({
            bomFormat: 'CycloneDX',
            specVersion: sbom.version,
            serialNumber: sbom.serialNumber,
            version: 1,
            metadata: {
                timestamp: sbom.timestamp,
                tools: [{ name: sbom.metadata.tool, version: sbom.metadata.version }],
                component: { name: sbom.metadata.projectName, version: sbom.metadata.projectVersion }
            },
            components: sbom.components.map(c => ({
                type: c.type,
                name: c.name,
                version: c.version,
                purl: c.purl,
                licenses: c.licenses.map(l => ({ license: { id: l } }))
            })),
            dependencies: sbom.dependencies.map(d => ({
                ref: d.from,
                dependsOn: [d.to]
            }))
        }, null, 2);
    }
    
    exportSPDX(sbom: SBOM): string {
        return JSON.stringify({
            spdxVersion: 'SPDX-2.3',
            dataLicense: 'CC0-1.0',
            SPDXID: 'SPDXRef-DOCUMENT',
            name: sbom.metadata.projectName,
            documentNamespace: \`https://spdx.org/spdxdocs/\${sbom.metadata.projectName}-\${sbom.serialNumber}\`,
            packages: sbom.components.map((c, i) => ({
                SPDXID: \`SPDXRef-Package-\${i}\`,
                name: c.name,
                versionInfo: c.version,
                downloadLocation: 'NOASSERTION',
                licenseConcluded: c.licenses[0] || 'NOASSERTION'
            })),
            relationships: sbom.dependencies.map((d, i) => ({
                spdxElementId: \`SPDXRef-Package-\${i}\`,
                relatedSpdxElement: \`SPDXRef-Package-\${i + 1}\`,
                relationshipType: 'DEPENDS_ON'
            }))
        }, null, 2);
    }
    
    // Generate vulnerability report
    async generateVulnerabilityReport(sbom: SBOM): Promise<string> {
        const vulnComponents = sbom.components.filter(c => c.vulnerabilities.length > 0);
        
        let report = '# Vulnerability Report\\n\\n';
        report += \`Generated: \${new Date().toISOString()}\\n\\n\`;
        report += \`Total Components: \${sbom.components.length}\\n\`;
        report += \`Vulnerable Components: \${vulnComponents.length}\\n\\n\`;
        
        for (const component of vulnComponents) {
            report += \`## \${component.name}@\${component.version}\\n\\n\`;
            
            for (const vuln of component.vulnerabilities) {
                report += \`- **\${vuln.id}**: \${vuln.title} (Severity: \${vuln.severity})\\n\`;
            }
            
            report += '\\n';
        }
        
        return report;
    }
    
    // License compliance check
    async checkLicenseCompliance(sbom: SBOM, allowedLicenses: string[]): Promise<ComplianceReport> {
        const violations: LicenseViolation[] = [];
        
        for (const component of sbom.components) {
            for (const license of component.licenses) {
                if (!allowedLicenses.includes(license) && license !== 'UNKNOWN') {
                    violations.push({
                        component: component.name,
                        version: component.version,
                        license,
                        reason: \`License "\${license}" is not in allowed list\`
                    });
                }
            }
        }
        
        return {
            compliant: violations.length === 0,
            violations,
            allowedLicenses,
            checkedAt: new Date().toISOString()
        };
    }
    
    private async readPackageJson(projectPath: string): Promise<any> {
        // Would read actual file
        return {};
    }
    
    private async readLockFile(projectPath: string): Promise<any> {
        // Would read actual file
        return {};
    }
}

export { SBOMGenerator };
`;
    }
}

export const sbomGeneratorService = SBOMGeneratorService.getInstance();
