/**
 * ðŸ—ƒï¸ SQL Generator
 * 
 * Generate SQL code:
 * - Migrations, queries, indexes
 */

import { EventEmitter } from 'events';

export type SQLDialect = 'postgresql' | 'mysql' | 'sqlite';

export class SQLGenerator extends EventEmitter {
    private static instance: SQLGenerator;

    private constructor() { super(); }

    static getInstance(): SQLGenerator {
        if (!SQLGenerator.instance) {
            SQLGenerator.instance = new SQLGenerator();
        }
        return SQLGenerator.instance;
    }

    getDialects(): SQLDialect[] {
        return ['postgresql', 'mysql', 'sqlite'];
    }

    generateCreateTable(tableName: string, columns: { name: string; type: string; constraints?: string[] }[], dialect: SQLDialect = 'postgresql'): string {
        const columnDefs = columns.map(col => {
            const type = this.mapType(col.type, dialect);
            const constraints = col.constraints?.join(' ') || '';
            return `    ${col.name} ${type} ${constraints}`.trim();
        }).join(',\n');

        return `-- Create ${tableName} table
CREATE TABLE IF NOT EXISTS ${tableName} (
    id ${dialect === 'mysql' ? 'INT AUTO_INCREMENT' : dialect === 'postgresql' ? 'SERIAL' : 'INTEGER'} PRIMARY KEY,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
${columnDefs}
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_${tableName}_created_at ON ${tableName}(created_at);
`;
    }

    private mapType(type: string, dialect: SQLDialect): string {
        const typeMap: Record<string, Record<SQLDialect, string>> = {
            'string': { postgresql: 'VARCHAR(255)', mysql: 'VARCHAR(255)', sqlite: 'TEXT' },
            'text': { postgresql: 'TEXT', mysql: 'TEXT', sqlite: 'TEXT' },
            'number': { postgresql: 'INTEGER', mysql: 'INT', sqlite: 'INTEGER' },
            'float': { postgresql: 'DECIMAL(10,2)', mysql: 'DECIMAL(10,2)', sqlite: 'REAL' },
            'boolean': { postgresql: 'BOOLEAN', mysql: 'TINYINT(1)', sqlite: 'INTEGER' },
            'date': { postgresql: 'DATE', mysql: 'DATE', sqlite: 'TEXT' },
            'datetime': { postgresql: 'TIMESTAMP', mysql: 'DATETIME', sqlite: 'TEXT' },
            'json': { postgresql: 'JSONB', mysql: 'JSON', sqlite: 'TEXT' },
            'uuid': { postgresql: 'UUID', mysql: 'CHAR(36)', sqlite: 'TEXT' }
        };
        return typeMap[type.toLowerCase()]?.[dialect] || 'TEXT';
    }

    generateMigration(name: string, upSQL: string, downSQL: string): string {
        const timestamp = Date.now();
        return `-- Migration: ${name}
-- Created: ${new Date().toISOString()}

-- Up Migration
${upSQL}

-- Down Migration
-- ${downSQL}
`;
    }

    generateComplexQueries(): string {
        return `-- Common SQL Query Patterns
-- Generated by Shadow AI

-- 1. Pagination with total count
WITH data AS (
    SELECT *
    FROM items
    WHERE category_id = $1
    ORDER BY created_at DESC
    LIMIT $2 OFFSET $3
),
total AS (
    SELECT COUNT(*) as count
    FROM items
    WHERE category_id = $1
)
SELECT 
    (SELECT json_agg(data.*) FROM data) as items,
    (SELECT count FROM total) as total;

-- 2. Full-text search (PostgreSQL)
SELECT *
FROM articles
WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(to_tsvector('english', title || ' ' || content), plainto_tsquery('english', $1)) DESC
LIMIT 20;

-- 3. Recursive CTE (tree structure)
WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 1 as depth
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT c.id, c.name, c.parent_id, ct.depth + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree ORDER BY depth, name;

-- 4. Window functions for rankings
SELECT 
    id,
    user_id,
    score,
    RANK() OVER (ORDER BY score DESC) as rank,
    DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as user_rank
FROM scores;

-- 5. Upsert (INSERT or UPDATE)
-- PostgreSQL
INSERT INTO users (email, name, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (email) 
DO UPDATE SET name = EXCLUDED.name, updated_at = NOW()
RETURNING *;

-- MySQL
INSERT INTO users (email, name, updated_at)
VALUES (?, ?, NOW())
ON DUPLICATE KEY UPDATE name = VALUES(name), updated_at = NOW();

-- 6. Lateral join (correlated subquery)
SELECT 
    u.*,
    latest_posts.title as latest_post_title
FROM users u
LEFT JOIN LATERAL (
    SELECT title
    FROM posts
    WHERE posts.user_id = u.id
    ORDER BY created_at DESC
    LIMIT 1
) latest_posts ON true;

-- 7. Aggregation with filtering
SELECT 
    category_id,
    COUNT(*) as total_items,
    COUNT(*) FILTER (WHERE status = 'active') as active_items,
    AVG(price) as avg_price,
    percentile_cont(0.5) WITHIN GROUP (ORDER BY price) as median_price
FROM items
GROUP BY category_id
HAVING COUNT(*) > 5;

-- 8. Date range analysis
SELECT 
    date_trunc('day', created_at) as date,
    COUNT(*) as orders,
    SUM(total) as revenue,
    AVG(total) as avg_order_value
FROM orders
WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY date_trunc('day', created_at)
ORDER BY date;

-- 9. JSON operations (PostgreSQL)
SELECT 
    id,
    data->>'name' as name,
    data->'address'->>'city' as city,
    jsonb_array_length(data->'tags') as tag_count
FROM products
WHERE data @> '{"active": true}'
AND data->'tags' ? 'featured';

-- 10. Audit trigger
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data, changed_by)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP != 'DELETE' THEN row_to_json(NEW) ELSE NULL END,
        current_user
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_audit
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW EXECUTE FUNCTION audit_trigger();
`;
    }
}

export const sqlGenerator = SQLGenerator.getInstance();
