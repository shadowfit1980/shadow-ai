/**
 * ðŸ”’ SafeExecutionService
 * 
 * Safe execution:
 * - Permissions, validation, auditing
 */

import { EventEmitter } from 'events';

export class SafeExecutionService extends EventEmitter {
    private static instance: SafeExecutionService;
    private constructor() { super(); }
    static getInstance(): SafeExecutionService {
        if (!SafeExecutionService.instance) {
            SafeExecutionService.instance = new SafeExecutionService();
        }
        return SafeExecutionService.instance;
    }

    generate(): string {
        return `// Safe Execution Service - Permissions, validation
// Generated by Shadow AI

class SafeExecution {
    private allowedPaths: Set<string> = new Set();
    private blockedCommands: string[] = ['rm -rf', 'format', 'del /f'];
    private auditLog: AuditEntry[] = [];
    
    // Check if path is safe
    isPathSafe(path: string): boolean {
        const normalized = this.normalizePath(path);
        
        // Block system paths
        const systemPaths = ['/etc', '/System', '/Windows', '/usr/bin'];
        if (systemPaths.some(sp => normalized.startsWith(sp))) {
            return false;
        }
        
        // Check if in allowed paths
        if (this.allowedPaths.size > 0) {
            return Array.from(this.allowedPaths).some(ap => normalized.startsWith(ap));
        }
        
        return true;
    }
    
    // Check if command is safe
    isCommandSafe(command: string): { safe: boolean; reason?: string } {
        const lowerCmd = command.toLowerCase();
        
        // Check blocked patterns
        for (const blocked of this.blockedCommands) {
            if (lowerCmd.includes(blocked)) {
                return { safe: false, reason: \`Blocked pattern: \${blocked}\` };
            }
        }
        
        // Check for dangerous flags
        if (lowerCmd.includes('--force') || lowerCmd.includes('-rf')) {
            return { safe: false, reason: 'Dangerous flags detected' };
        }
        
        return { safe: true };
    }
    
    // Request user confirmation
    async requestConfirmation(action: string, details: any): Promise<boolean> {
        return new Promise((resolve) => {
            this.emit('confirmation-required', {
                action,
                details,
                approve: () => resolve(true),
                deny: () => resolve(false)
            });
        });
    }
    
    // Execute with safety checks
    async safeExecute<T>(
        action: string,
        fn: () => Promise<T>,
        options: SafeExecutionOptions = {}
    ): Promise<T> {
        // Log attempt
        this.audit('attempt', action, options);
        
        // Check if confirmation required
        if (options.requireConfirmation) {
            const confirmed = await this.requestConfirmation(action, options);
            if (!confirmed) {
                this.audit('denied', action, options);
                throw new Error('User denied action');
            }
        }
        
        // Execute with timeout
        const timeout = options.timeout || 30000;
        const result = await Promise.race([
            fn(),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Execution timeout')), timeout)
            )
        ]) as T;
        
        this.audit('completed', action, options);
        return result;
    }
    
    // Add allowed path
    allowPath(path: string): void {
        this.allowedPaths.add(this.normalizePath(path));
    }
    
    // Add blocked command
    blockCommand(pattern: string): void {
        this.blockedCommands.push(pattern);
    }
    
    // Audit log
    audit(type: string, action: string, details: any): void {
        this.auditLog.push({
            type,
            action,
            details,
            timestamp: Date.now()
        });
    }
    
    // Get audit log
    getAuditLog(filter?: { type?: string; action?: string }): AuditEntry[] {
        let log = this.auditLog;
        
        if (filter?.type) {
            log = log.filter(e => e.type === filter.type);
        }
        if (filter?.action) {
            log = log.filter(e => e.action.includes(filter.action));
        }
        
        return log;
    }
    
    private normalizePath(path: string): string {
        return path.replace(/\\\\/g, '/').toLowerCase();
    }
}

export { SafeExecution };
`;
    }
}

export const safeExecutionService = SafeExecutionService.getInstance();
