/**
 * ðŸ” SearchEngineGenerator
 * 
 * Search functionality:
 * - Full-text, fuzzy, faceted search
 */

import { EventEmitter } from 'events';

export class SearchEngineGenerator extends EventEmitter {
    private static instance: SearchEngineGenerator;

    private constructor() { super(); }

    static getInstance(): SearchEngineGenerator {
        if (!SearchEngineGenerator.instance) {
            SearchEngineGenerator.instance = new SearchEngineGenerator();
        }
        return SearchEngineGenerator.instance;
    }

    generate(): string {
        return `// Search Engine Generator
// Generated by Shadow AI

/**
 * SEARCH ENGINE GENERATOR
 * 
 * Full-text search with Algolia, MeiliSearch, Elasticsearch.
 */

// === Algolia Integration ===
class AlgoliaIntegration {
    generateClient(): string {
        return \`
import algoliasearch from 'algoliasearch';

const client = algoliasearch(process.env.ALGOLIA_APP_ID!, process.env.ALGOLIA_API_KEY!);
const index = client.initIndex('products');

// Index data
export async function indexProducts(products: Product[]) {
    const objects = products.map(p => ({
        objectID: p.id,
        name: p.name,
        description: p.description,
        price: p.price,
        category: p.category,
        _tags: p.tags
    }));
    
    await index.saveObjects(objects);
}

// Search
export async function search(query: string, options: SearchOptions = {}) {
    const { hits, nbHits, page, nbPages, facets } = await index.search(query, {
        hitsPerPage: options.limit || 20,
        page: options.page || 0,
        facets: ['category', 'price_range'],
        filters: options.filters
    });
    
    return { hits, total: nbHits, page, totalPages: nbPages, facets };
}
        \`;
    }
}

// === MeiliSearch Integration ===
class MeiliSearchIntegration {
    generateClient(): string {
        return \`
import { MeiliSearch } from 'meilisearch';

const client = new MeiliSearch({
    host: process.env.MEILISEARCH_HOST!,
    apiKey: process.env.MEILISEARCH_API_KEY
});

const index = client.index('products');

// Configure index
export async function configureIndex() {
    await index.updateSettings({
        searchableAttributes: ['name', 'description', 'category'],
        filterableAttributes: ['category', 'price', 'inStock'],
        sortableAttributes: ['price', 'createdAt'],
        rankingRules: ['words', 'typo', 'proximity', 'attribute', 'sort', 'exactness']
    });
}

// Index documents
export async function indexDocuments(documents: any[]) {
    await index.addDocuments(documents, { primaryKey: 'id' });
}

// Search
export async function search(query: string, options: SearchOptions = {}) {
    return index.search(query, {
        limit: options.limit || 20,
        offset: options.offset || 0,
        filter: options.filter,
        sort: options.sort,
        facets: ['category']
    });
}
        \`;
    }
}

// === Search UI Component ===
class SearchUIGenerator {
    generateSearchBox(): string {
        return \`
export function SearchBox({ onSearch, placeholder = 'Search...' }: SearchBoxProps) {
    const [query, setQuery] = useState('');
    const [suggestions, setSuggestions] = useState([]);
    const [isOpen, setIsOpen] = useState(false);
    const debouncedQuery = useDebounce(query, 300);
    
    useEffect(() => {
        if (debouncedQuery.length >= 2) {
            fetchSuggestions(debouncedQuery).then(setSuggestions);
            setIsOpen(true);
        } else {
            setSuggestions([]);
            setIsOpen(false);
        }
    }, [debouncedQuery]);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSearch(query);
        setIsOpen(false);
    };
    
    return (
        <div className="search-box">
            <form onSubmit={handleSubmit}>
                <SearchIcon className="search-icon" />
                <input
                    type="text"
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                    placeholder={placeholder}
                    onFocus={() => suggestions.length > 0 && setIsOpen(true)}
                />
                {query && <button type="button" onClick={() => setQuery('')}>Ã—</button>}
            </form>
            
            {isOpen && suggestions.length > 0 && (
                <ul className="suggestions">
                    {suggestions.map((s, i) => (
                        <li key={i} onClick={() => { setQuery(s); onSearch(s); setIsOpen(false); }}>
                            {s}
                        </li>
                    ))}
                </ul>
            )}
        </div>
    );
}
        \`;
    }
    
    generateFacetedSearch(): string {
        return \`
export function FacetedSearch({ facets, onFilterChange }: FacetedSearchProps) {
    const [activeFilters, setActiveFilters] = useState<Record<string, string[]>>({});
    
    const toggleFilter = (facet: string, value: string) => {
        const current = activeFilters[facet] || [];
        const updated = current.includes(value)
            ? current.filter(v => v !== value)
            : [...current, value];
        
        const newFilters = { ...activeFilters, [facet]: updated };
        setActiveFilters(newFilters);
        onFilterChange(newFilters);
    };
    
    return (
        <div className="faceted-search">
            {Object.entries(facets).map(([facetName, values]) => (
                <div key={facetName} className="facet-group">
                    <h4>{facetName}</h4>
                    {Object.entries(values).map(([value, count]) => (
                        <label key={value}>
                            <input
                                type="checkbox"
                                checked={activeFilters[facetName]?.includes(value) || false}
                                onChange={() => toggleFilter(facetName, value)}
                            />
                            {value} ({count})
                        </label>
                    ))}
                </div>
            ))}
        </div>
    );
}
        \`;
    }
}

export { AlgoliaIntegration, MeiliSearchIntegration, SearchUIGenerator };
`;
    }
}

export const searchEngineGenerator = SearchEngineGenerator.getInstance();
