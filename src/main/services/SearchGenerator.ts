/**
 * üîç Search Generator
 * 
 * Generate search systems:
 * - Elasticsearch, Algolia, Meilisearch
 */

import { EventEmitter } from 'events';

export type SearchEngine = 'elasticsearch' | 'algolia' | 'meilisearch';

export class SearchGenerator extends EventEmitter {
    private static instance: SearchGenerator;

    private constructor() { super(); }

    static getInstance(): SearchGenerator {
        if (!SearchGenerator.instance) {
            SearchGenerator.instance = new SearchGenerator();
        }
        return SearchGenerator.instance;
    }

    getEngines(): SearchEngine[] {
        return ['elasticsearch', 'algolia', 'meilisearch'];
    }

    generate(engine: SearchEngine): string {
        switch (engine) {
            case 'elasticsearch': return this.generateElasticsearch();
            case 'algolia': return this.generateAlgolia();
            case 'meilisearch': return this.generateMeilisearch();
            default: return '';
        }
    }

    private generateElasticsearch(): string {
        return `// Elasticsearch
// Generated by Shadow AI

import { Client } from '@elastic/elasticsearch';

const client = new Client({ node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200' });

const INDEX = 'products';

// Create index with mappings
async function createIndex() {
    await client.indices.create({
        index: INDEX,
        body: {
            settings: {
                analysis: {
                    analyzer: {
                        autocomplete: {
                            type: 'custom',
                            tokenizer: 'standard',
                            filter: ['lowercase', 'autocomplete_filter']
                        }
                    },
                    filter: {
                        autocomplete_filter: {
                            type: 'edge_ngram',
                            min_gram: 1,
                            max_gram: 20
                        }
                    }
                }
            },
            mappings: {
                properties: {
                    name: { type: 'text', analyzer: 'autocomplete', search_analyzer: 'standard' },
                    description: { type: 'text' },
                    category: { type: 'keyword' },
                    price: { type: 'float' },
                    tags: { type: 'keyword' },
                    createdAt: { type: 'date' }
                }
            }
        }
    });
}

// Index document
async function indexDocument(id: string, document: any) {
    await client.index({ index: INDEX, id, body: document, refresh: true });
}

// Bulk index
async function bulkIndex(documents: Array<{ id: string; [key: string]: any }>) {
    const body = documents.flatMap(doc => [
        { index: { _index: INDEX, _id: doc.id } },
        doc
    ]);
    await client.bulk({ body, refresh: true });
}

// Search
async function search(query: string, options: { page?: number; size?: number; filters?: any } = {}) {
    const { page = 1, size = 20, filters = {} } = options;

    const must: any[] = [
        { multi_match: { query, fields: ['name^3', 'description', 'tags'], fuzziness: 'AUTO' } }
    ];

    if (filters.category) {
        must.push({ term: { category: filters.category } });
    }
    if (filters.minPrice || filters.maxPrice) {
        must.push({ range: { price: { gte: filters.minPrice, lte: filters.maxPrice } } });
    }

    const result = await client.search({
        index: INDEX,
        body: {
            from: (page - 1) * size,
            size,
            query: { bool: { must } },
            highlight: { fields: { name: {}, description: {} } },
            aggs: {
                categories: { terms: { field: 'category' } },
                price_ranges: { range: { field: 'price', ranges: [
                    { to: 50 }, { from: 50, to: 100 }, { from: 100 }
                ]}}
            }
        }
    });

    return {
        hits: result.hits.hits.map(h => ({ id: h._id, ...h._source, highlight: h.highlight })),
        total: result.hits.total,
        aggregations: result.aggregations
    };
}

// Autocomplete
async function autocomplete(prefix: string) {
    const result = await client.search({
        index: INDEX,
        body: {
            size: 10,
            query: { match: { name: { query: prefix, analyzer: 'autocomplete' } } },
            _source: ['name']
        }
    });
    return result.hits.hits.map(h => h._source.name);
}

export { createIndex, indexDocument, bulkIndex, search, autocomplete };
`;
    }

    private generateAlgolia(): string {
        return `// Algolia Search
// Generated by Shadow AI

import algoliasearch from 'algoliasearch';
import { InstantSearch, SearchBox, Hits, RefinementList, Pagination, Highlight } from 'react-instantsearch';

const client = algoliasearch(process.env.ALGOLIA_APP_ID!, process.env.ALGOLIA_API_KEY!);
const index = client.initIndex('products');

// Index documents
async function indexDocuments(documents: any[]) {
    await index.saveObjects(documents, { autoGenerateObjectIDIfNotExist: true });
}

// Configure index
async function configureIndex() {
    await index.setSettings({
        searchableAttributes: ['name', 'description', 'tags'],
        attributesForFaceting: ['category', 'price', 'rating'],
        customRanking: ['desc(popularity)', 'desc(rating)'],
        highlightPreTag: '<mark>',
        highlightPostTag: '</mark>'
    });
}

// Search
async function search(query: string, options = {}) {
    return index.search(query, {
        hitsPerPage: 20,
        attributesToHighlight: ['name', 'description'],
        facets: ['category', 'price'],
        ...options
    });
}

// React InstantSearch Component
function ProductSearch() {
    return (
        <InstantSearch searchClient={client} indexName="products">
            <div className="search-container">
                <SearchBox placeholder="Search products..." />
                
                <div className="search-layout">
                    <aside className="filters">
                        <h3>Category</h3>
                        <RefinementList attribute="category" />
                        
                        <h3>Price Range</h3>
                        <RefinementList attribute="price" />
                    </aside>
                    
                    <main className="results">
                        <Hits hitComponent={ProductHit} />
                        <Pagination />
                    </main>
                </div>
            </div>
        </InstantSearch>
    );
}

function ProductHit({ hit }) {
    return (
        <article>
            <h2><Highlight attribute="name" hit={hit} /></h2>
            <p><Highlight attribute="description" hit={hit} /></p>
            <span className="price">\${hit.price}</span>
        </article>
    );
}

export { indexDocuments, configureIndex, search, ProductSearch };
`;
    }

    private generateMeilisearch(): string {
        return `// Meilisearch
// Generated by Shadow AI

import { MeiliSearch } from 'meilisearch';

const client = new MeiliSearch({
    host: process.env.MEILISEARCH_URL || 'http://localhost:7700',
    apiKey: process.env.MEILISEARCH_API_KEY
});

const INDEX = 'products';

// Setup index
async function setupIndex() {
    const index = client.index(INDEX);
    
    await index.updateSettings({
        searchableAttributes: ['name', 'description', 'tags'],
        filterableAttributes: ['category', 'price', 'inStock'],
        sortableAttributes: ['price', 'createdAt', 'popularity'],
        rankingRules: ['words', 'typo', 'proximity', 'attribute', 'sort', 'exactness']
    });
}

// Add documents
async function addDocuments(documents: any[]) {
    const index = client.index(INDEX);
    await index.addDocuments(documents);
}

// Search
async function search(query: string, options: { page?: number; filters?: string; sort?: string[] } = {}) {
    const index = client.index(INDEX);
    
    return index.search(query, {
        limit: 20,
        offset: ((options.page || 1) - 1) * 20,
        filter: options.filters,
        sort: options.sort,
        attributesToHighlight: ['name', 'description']
    });
}

// React hook
function useMeilisearch(query: string) {
    const [results, setResults] = useState([]);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (!query) { setResults([]); return; }
        
        setLoading(true);
        search(query)
            .then(res => setResults(res.hits))
            .finally(() => setLoading(false));
    }, [query]);

    return { results, loading };
}

export { setupIndex, addDocuments, search, useMeilisearch };
`;
    }
}

export const searchGenerator = SearchGenerator.getInstance();
