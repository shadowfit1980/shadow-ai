/**
 * ðŸ”’ Security Patterns Generator
 * 
 * Generate security patterns:
 * - CORS, CSRF, Rate Limiting, XSS
 */

import { EventEmitter } from 'events';

export class SecurityPatterns extends EventEmitter {
    private static instance: SecurityPatterns;

    private constructor() { super(); }

    static getInstance(): SecurityPatterns {
        if (!SecurityPatterns.instance) {
            SecurityPatterns.instance = new SecurityPatterns();
        }
        return SecurityPatterns.instance;
    }

    generate(): string {
        return `// Security Patterns
// Generated by Shadow AI

import helmet from 'helmet';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import mongoSanitize from 'express-mongo-sanitize';
import hpp from 'hpp';
import crypto from 'crypto';

// === HELMET (Security Headers) ===
const helmetConfig = helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'", 'trusted-cdn.com'],
            styleSrc: ["'self'", "'unsafe-inline'", 'fonts.googleapis.com'],
            imgSrc: ["'self'", 'data:', 'https:'],
            connectSrc: ["'self'", 'api.example.com'],
            fontSrc: ["'self'", 'fonts.gstatic.com'],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'"],
            frameSrc: ["'none'"]
        }
    },
    crossOriginEmbedderPolicy: true,
    crossOriginOpenerPolicy: { policy: 'same-origin' },
    crossOriginResourcePolicy: { policy: 'same-origin' },
    hsts: { maxAge: 31536000, includeSubDomains: true, preload: true },
    referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
});

// === CORS ===
const corsConfig = cors({
    origin: (origin, callback) => {
        const allowedOrigins = ['https://app.example.com', 'https://admin.example.com'];
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-CSRF-Token'],
    credentials: true,
    maxAge: 86400
});

// === RATE LIMITING ===
const rateLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: { error: 'Too many requests, please try again later' },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => req.ip || req.headers['x-forwarded-for'] || 'unknown',
    skip: (req) => req.path === '/health'
});

// Stricter limit for auth endpoints
const authLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 5, // 5 attempts per hour
    message: { error: 'Too many login attempts, try again in an hour' }
});

// === CSRF Protection ===
function generateCSRFToken(): string {
    return crypto.randomBytes(32).toString('hex');
}

function csrfMiddleware(req, res, next) {
    // Skip for safe methods
    if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
        return next();
    }

    const sessionToken = req.session?.csrfToken;
    const headerToken = req.headers['x-csrf-token'];
    const bodyToken = req.body?._csrf;

    const token = headerToken || bodyToken;

    if (!sessionToken || !token || sessionToken !== token) {
        return res.status(403).json({ error: 'Invalid CSRF token' });
    }

    next();
}

// Set CSRF token in session
function setCSRFToken(req, res, next) {
    if (!req.session.csrfToken) {
        req.session.csrfToken = generateCSRFToken();
    }
    res.locals.csrfToken = req.session.csrfToken;
    next();
}

// === XSS Prevention ===
function sanitizeInput(input: string): string {
    return input
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\\//g, '&#x2F;');
}

// DOMPurify for HTML content
import DOMPurify from 'isomorphic-dompurify';

function sanitizeHTML(html: string): string {
    return DOMPurify.sanitize(html, {
        ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
        ALLOWED_ATTR: ['href', 'target', 'rel']
    });
}

// === SQL Injection Prevention ===
// Always use parameterized queries (handled by ORMs)

// === Password Security ===
import bcrypt from 'bcryptjs';

async function hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 12);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
}

// Password strength validation
function validatePassword(password: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    if (password.length < 8) errors.push('Minimum 8 characters');
    if (!/[A-Z]/.test(password)) errors.push('Must contain uppercase');
    if (!/[a-z]/.test(password)) errors.push('Must contain lowercase');
    if (!/[0-9]/.test(password)) errors.push('Must contain number');
    if (!/[^A-Za-z0-9]/.test(password)) errors.push('Must contain special character');
    return { valid: errors.length === 0, errors };
}

// === Security Middleware Stack ===
function applySecurityMiddleware(app) {
    app.use(helmetConfig);
    app.use(corsConfig);
    app.use(rateLimiter);
    app.use(mongoSanitize()); // Prevent NoSQL injection
    app.use(hpp()); // Prevent HTTP Parameter Pollution
    app.use(setCSRFToken);
}

export {
    helmetConfig, corsConfig, rateLimiter, authLimiter,
    csrfMiddleware, setCSRFToken, generateCSRFToken,
    sanitizeInput, sanitizeHTML,
    hashPassword, verifyPassword, validatePassword,
    applySecurityMiddleware
};
`;
    }
}

export const securityPatterns = SecurityPatterns.getInstance();
