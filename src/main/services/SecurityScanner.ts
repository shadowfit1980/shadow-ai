/**
 * ðŸ”’ SecurityScanner
 * 
 * Security scanning:
 * - Vulnerabilities, OWASP, dependencies
 */

import { EventEmitter } from 'events';

export class SecurityScanner extends EventEmitter {
    private static instance: SecurityScanner;
    private constructor() { super(); }
    static getInstance(): SecurityScanner {
        if (!SecurityScanner.instance) {
            SecurityScanner.instance = new SecurityScanner();
        }
        return SecurityScanner.instance;
    }

    generate(): string {
        return `// Security Scanner - Vulnerabilities, OWASP, dependencies
// Generated by Shadow AI

// Dependency Vulnerability Scanner
class DependencyScanner {
    async scanPackageJson(packageJsonPath: string) {
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
        const dependencies = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
        
        const vulnerabilities = [];
        
        for (const [name, version] of Object.entries(dependencies)) {
            const vulns = await this.checkNPMAudit(name, version as string);
            vulnerabilities.push(...vulns);
        }
        
        return vulnerabilities;
    }
    
    private async checkNPMAudit(packageName: string, version: string) {
        const response = await fetch(\`https://registry.npmjs.org/-/npm/v1/security/audits\`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: packageName, version })
        });
        
        return response.json();
    }
}

// OWASP Security Checks
class OWASPChecker {
    async checkSQLInjection(code: string): Promise<SecurityIssue[]> {
        const issues: SecurityIssue[] = [];
        
        // Check for string concatenation in SQL
        const sqlConcatPattern = /(\\.query|\\execute)\\s*\\(\\s*["'\`].*\\$\\{/g;
        const matches = code.matchAll(sqlConcatPattern);
        
        for (const match of matches) {
            issues.push({
                type: 'SQL_INJECTION',
                severity: 'critical',
                line: this.getLineNumber(code, match.index!),
                description: 'Potential SQL injection vulnerability',
                suggestion: 'Use parameterized queries'
            });
        }
        
        return issues;
    }
    
    async checkXSS(code: string): Promise<SecurityIssue[]> {
        const issues: SecurityIssue[] = [];
        
        // Check for dangerouslySetInnerHTML
        const dangerousPattern = /dangerouslySetInnerHTML/g;
        const matches = code.matchAll(dangerousPattern);
        
        for (const match of matches) {
            issues.push({
                type: 'XSS',
                severity: 'high',
                line: this.getLineNumber(code, match.index!),
                description: 'Potential XSS vulnerability with dangerouslySetInnerHTML',
                suggestion: 'Sanitize input using DOMPurify'
            });
        }
        
        return issues;
    }
    
    async checkHardcodedSecrets(code: string): Promise<SecurityIssue[]> {
        const issues: SecurityIssue[] = [];
        
        const patterns = [
            { pattern: /api[_-]?key\\s*[:=]\\s*["'][^"']{20,}["']/gi, type: 'API_KEY' },
            { pattern: /password\\s*[:=]\\s*["'][^"']+["']/gi, type: 'PASSWORD' },
            { pattern: /secret\\s*[:=]\\s*["'][^"']+["']/gi, type: 'SECRET' }
        ];
        
        for (const { pattern, type } of patterns) {
            const matches = code.matchAll(pattern);
            for (const match of matches) {
                issues.push({
                    type: 'HARDCODED_SECRET',
                    severity: 'critical',
                    line: this.getLineNumber(code, match.index!),
                    description: \`Hardcoded \${type} detected\`,
                    suggestion: 'Use environment variables'
                });
            }
        }
        
        return issues;
    }
    
    private getLineNumber(code: string, index: number): number {
        return code.slice(0, index).split('\\n').length;
    }
}

// Security Report
class SecurityReporter {
    generateReport(issues: SecurityIssue[]): string {
        const byType = this.groupBy(issues, 'severity');
        
        let report = '# Security Scan Report\\n\\n';
        report += \`Total Issues: \${issues.length}\\n\\n\`;
        
        if (byType['critical']?.length) {
            report += '## ðŸ”´ Critical Issues\\n\\n';
            byType['critical'].forEach(issue => {
                report += \`- Line \${issue.line}: \${issue.description}\\n\`;
            });
        }
        
        if (byType['high']?.length) {
            report += '## ðŸŸ  High Issues\\n\\n';
            byType['high'].forEach(issue => {
                report += \`- Line \${issue.line}: \${issue.description}\\n\`;
            });
        }
        
        return report;
    }
}

export { DependencyScanner, OWASPChecker, SecurityReporter };
`;
    }
}

export const securityScanner = SecurityScanner.getInstance();
