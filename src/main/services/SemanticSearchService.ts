/**
 * üîç SemanticSearchService
 * 
 * Semantic code search:
 * - Embeddings, similarity, indexing
 */

import { EventEmitter } from 'events';

export class SemanticSearchService extends EventEmitter {
    private static instance: SemanticSearchService;
    private constructor() { super(); }
    static getInstance(): SemanticSearchService {
        if (!SemanticSearchService.instance) {
            SemanticSearchService.instance = new SemanticSearchService();
        }
        return SemanticSearchService.instance;
    }

    generate(): string {
        return `// Semantic Search Service - Embeddings, similarity
// Generated by Shadow AI

import OpenAI from 'openai';

class SemanticSearch {
    private openai = new OpenAI();
    private index: Map<string, { embedding: number[]; content: string; metadata: any }> = new Map();
    
    // Index a code file
    async indexFile(filePath: string, content: string) {
        // Split into chunks
        const chunks = this.chunkCode(content);
        
        for (let i = 0; i < chunks.length; i++) {
            const embedding = await this.getEmbedding(chunks[i]);
            const key = \`\${filePath}:\${i}\`;
            
            this.index.set(key, {
                embedding,
                content: chunks[i],
                metadata: { filePath, chunkIndex: i }
            });
        }
    }
    
    // Search for similar code
    async search(query: string, k = 5): Promise<SearchResult[]> {
        const queryEmbedding = await this.getEmbedding(query);
        
        const results: Array<{ key: string; score: number; content: string; metadata: any }> = [];
        
        for (const [key, doc] of this.index) {
            const score = this.cosineSimilarity(queryEmbedding, doc.embedding);
            results.push({ key, score, content: doc.content, metadata: doc.metadata });
        }
        
        return results
            .sort((a, b) => b.score - a.score)
            .slice(0, k)
            .map(r => ({
                filePath: r.metadata.filePath,
                content: r.content,
                score: r.score
            }));
    }
    
    // Get embedding from OpenAI
    private async getEmbedding(text: string): Promise<number[]> {
        const response = await this.openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: text
        });
        
        return response.data[0].embedding;
    }
    
    // Calculate cosine similarity
    private cosineSimilarity(a: number[], b: number[]): number {
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        
        for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }
        
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }
    
    // Chunk code intelligently
    private chunkCode(content: string, maxChunkSize = 1000): string[] {
        const lines = content.split('\\n');
        const chunks: string[] = [];
        let currentChunk = '';
        
        for (const line of lines) {
            if (currentChunk.length + line.length > maxChunkSize) {
                if (currentChunk) chunks.push(currentChunk);
                currentChunk = line;
            } else {
                currentChunk += (currentChunk ? '\\n' : '') + line;
            }
        }
        
        if (currentChunk) chunks.push(currentChunk);
        
        return chunks;
    }
    
    // Index entire project
    async indexProject(directory: string) {
        const files = await glob(\`\${directory}/**/*.{ts,tsx,js,jsx,py,go,rs}\`);
        
        for (const file of files) {
            const content = await fs.readFile(file, 'utf-8');
            await this.indexFile(file, content);
        }
    }
    
    // Clear index
    clearIndex() {
        this.index.clear();
    }
}

export { SemanticSearch };
`;
    }
}

export const semanticSearchService = SemanticSearchService.getInstance();
