/**
 * âš¡ Serverless Framework Generator
 * 
 * Generate serverless patterns:
 * - SST, Serverless Framework
 */

import { EventEmitter } from 'events';

export class ServerlessFramework extends EventEmitter {
    private static instance: ServerlessFramework;

    private constructor() { super(); }

    static getInstance(): ServerlessFramework {
        if (!ServerlessFramework.instance) {
            ServerlessFramework.instance = new ServerlessFramework();
        }
        return ServerlessFramework.instance;
    }

    generateSST(): string {
        return `// SST (Serverless Stack)
// Generated by Shadow AI

// === sst.config.ts ===
import { SSTConfig } from "sst";
import { API } from "./stacks/API";
import { Database } from "./stacks/Database";
import { Auth } from "./stacks/Auth";
import { Frontend } from "./stacks/Frontend";

export default {
    config() {
        return {
            name: "my-app",
            region: "us-east-1"
        };
    },
    stacks(app) {
        app.stack(Database);
        app.stack(Auth);
        app.stack(API);
        app.stack(Frontend);
    }
} satisfies SSTConfig;

// === stacks/Database.ts ===
import { StackContext, Table, Bucket, Queue } from "sst/constructs";

export function Database({ stack }: StackContext) {
    // DynamoDB Table
    const table = new Table(stack, "Items", {
        fields: {
            pk: "string",
            sk: "string",
            gsi1pk: "string",
            gsi1sk: "string"
        },
        primaryIndex: { partitionKey: "pk", sortKey: "sk" },
        globalIndexes: {
            gsi1: { partitionKey: "gsi1pk", sortKey: "gsi1sk" }
        },
        stream: "new_and_old_images"
    });

    // S3 Bucket
    const bucket = new Bucket(stack, "Uploads", {
        cors: [{ allowedMethods: ["GET", "PUT"], allowedOrigins: ["*"] }]
    });

    // SQS Queue
    const queue = new Queue(stack, "Queue", {
        consumer: "packages/functions/src/consumer.handler"
    });

    return { table, bucket, queue };
}

// === stacks/API.ts ===
import { StackContext, Api, use } from "sst/constructs";
import { Database } from "./Database";
import { Auth } from "./Auth";

export function API({ stack }: StackContext) {
    const { table, bucket } = use(Database);
    const { auth } = use(Auth);

    const api = new Api(stack, "Api", {
        authorizers: {
            jwt: {
                type: "user_pool",
                userPool: { id: auth.userPoolId, clientIds: [auth.userPoolClientId] }
            }
        },
        defaults: {
            authorizer: "jwt",
            function: {
                bind: [table, bucket],
                environment: {
                    TABLE_NAME: table.tableName
                }
            }
        },
        routes: {
            "GET /users": "packages/functions/src/users.list",
            "GET /users/{id}": "packages/functions/src/users.get",
            "POST /users": "packages/functions/src/users.create",
            "PUT /users/{id}": "packages/functions/src/users.update",
            "DELETE /users/{id}": "packages/functions/src/users.delete",
            
            // Public route
            "GET /health": {
                function: "packages/functions/src/health.handler",
                authorizer: "none"
            }
        }
    });

    stack.addOutputs({ ApiEndpoint: api.url });

    return { api };
}

// === stacks/Auth.ts ===
import { StackContext, Cognito } from "sst/constructs";

export function Auth({ stack }: StackContext) {
    const auth = new Cognito(stack, "Auth", {
        login: ["email"],
        triggers: {
            preSignUp: "packages/functions/src/auth/preSignUp.handler",
            postConfirmation: "packages/functions/src/auth/postConfirmation.handler"
        }
    });

    return { auth };
}

// === stacks/Frontend.ts ===
import { StackContext, NextjsSite, use } from "sst/constructs";
import { API } from "./API";
import { Auth } from "./Auth";

export function Frontend({ stack }: StackContext) {
    const { api } = use(API);
    const { auth } = use(Auth);

    const site = new NextjsSite(stack, "Site", {
        path: "packages/web",
        environment: {
            NEXT_PUBLIC_API_URL: api.url,
            NEXT_PUBLIC_USER_POOL_ID: auth.userPoolId,
            NEXT_PUBLIC_USER_POOL_CLIENT_ID: auth.userPoolClientId
        }
    });

    stack.addOutputs({ SiteUrl: site.url });
}

// === packages/functions/src/users.ts ===
import { ApiHandler } from "sst/node/api";
import { Table } from "sst/node/table";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, GetCommand, PutCommand, QueryCommand } from "@aws-sdk/lib-dynamodb";

const client = DynamoDBDocumentClient.from(new DynamoDBClient({}));

export const list = ApiHandler(async () => {
    const result = await client.send(new QueryCommand({
        TableName: Table.Items.tableName,
        KeyConditionExpression: "pk = :pk",
        ExpressionAttributeValues: { ":pk": "USER" }
    }));

    return {
        statusCode: 200,
        body: JSON.stringify(result.Items)
    };
});

export const get = ApiHandler(async (event) => {
    const { id } = event.pathParameters!;

    const result = await client.send(new GetCommand({
        TableName: Table.Items.tableName,
        Key: { pk: "USER", sk: id }
    }));

    if (!result.Item) {
        return { statusCode: 404, body: JSON.stringify({ error: "Not found" }) };
    }

    return { statusCode: 200, body: JSON.stringify(result.Item) };
});

export const create = ApiHandler(async (event) => {
    const body = JSON.parse(event.body || "{}");
    const id = crypto.randomUUID();

    await client.send(new PutCommand({
        TableName: Table.Items.tableName,
        Item: { pk: "USER", sk: id, ...body, createdAt: new Date().toISOString() }
    }));

    return { statusCode: 201, body: JSON.stringify({ id }) };
});
`;
    }

    generateServerless(): string {
        return `# Serverless Framework
# Generated by Shadow AI

# serverless.yml
service: my-service
frameworkVersion: '3'

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  stage: \${opt:stage, 'dev'}
  
  environment:
    STAGE: \${self:provider.stage}
    TABLE_NAME: \${self:service}-\${self:provider.stage}-table
    
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
            - dynamodb:Query
            - dynamodb:Scan
          Resource:
            - !GetAtt Table.Arn
            - !Join ['/', [!GetAtt Table.Arn, 'index/*']]

plugins:
  - serverless-esbuild
  - serverless-offline
  - serverless-domain-manager

custom:
  esbuild:
    bundle: true
    minify: true
    sourcemap: true
    target: node20
    
  customDomain:
    domainName: api.\${self:provider.stage}.example.com
    certificateName: '*.example.com'
    createRoute53Record: true

functions:
  # REST API
  getUsers:
    handler: src/handlers/users.list
    events:
      - http:
          path: /users
          method: get
          cors: true
          authorizer:
            type: COGNITO_USER_POOLS
            authorizerId: !Ref ApiGatewayAuthorizer

  createUser:
    handler: src/handlers/users.create
    events:
      - http:
          path: /users
          method: post
          cors: true

  # Scheduled job
  dailyCleanup:
    handler: src/handlers/jobs.cleanup
    events:
      - schedule: rate(1 day)

  # SQS Consumer
  processQueue:
    handler: src/handlers/queue.process
    events:
      - sqs:
          arn: !GetAtt Queue.Arn
          batchSize: 10

  # S3 Trigger
  processUpload:
    handler: src/handlers/uploads.process
    events:
      - s3:
          bucket: !Ref Bucket
          event: s3:ObjectCreated:*
          rules:
            - prefix: uploads/

resources:
  Resources:
    Table:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: \${self:provider.environment.TABLE_NAME}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: pk
            AttributeType: S
          - AttributeName: sk
            AttributeType: S
        KeySchema:
          - AttributeName: pk
            KeyType: HASH
          - AttributeName: sk
            KeyType: RANGE

    Queue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: \${self:service}-\${self:provider.stage}-queue
        VisibilityTimeout: 300

    Bucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: \${self:service}-\${self:provider.stage}-uploads

  Outputs:
    ApiEndpoint:
      Value: !Sub https://\${ApiGatewayRestApi}.execute-api.\${AWS::Region}.amazonaws.com/\${self:provider.stage}
`;
    }
}

export const serverlessFramework = ServerlessFramework.getInstance();
