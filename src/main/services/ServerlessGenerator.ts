/**
 * âš¡ Serverless Generator
 * 
 * Generate serverless functions:
 * - AWS Lambda, Cloud Functions, Vercel
 */

import { EventEmitter } from 'events';

export type ServerlessPlatform = 'lambda' | 'cloudFunctions' | 'vercel';

export class ServerlessGenerator extends EventEmitter {
    private static instance: ServerlessGenerator;

    private constructor() { super(); }

    static getInstance(): ServerlessGenerator {
        if (!ServerlessGenerator.instance) {
            ServerlessGenerator.instance = new ServerlessGenerator();
        }
        return ServerlessGenerator.instance;
    }

    getPlatforms(): ServerlessPlatform[] {
        return ['lambda', 'cloudFunctions', 'vercel'];
    }

    generate(platform: ServerlessPlatform): string {
        switch (platform) {
            case 'lambda': return this.generateLambda();
            case 'cloudFunctions': return this.generateCloudFunctions();
            case 'vercel': return this.generateVercel();
            default: return '';
        }
    }

    private generateLambda(): string {
        return `// AWS Lambda Functions
// Generated by Shadow AI

import { APIGatewayProxyHandler, APIGatewayProxyResult, SQSHandler, S3Handler } from 'aws-lambda';
import { DynamoDB, S3, SES, SQS } from 'aws-sdk';

const dynamodb = new DynamoDB.DocumentClient();
const s3 = new S3();
const ses = new SES();
const sqs = new SQS();

// API Gateway Handler
export const apiHandler: APIGatewayProxyHandler = async (event) => {
    try {
        const { httpMethod, path, body, queryStringParameters, pathParameters } = event;
        
        switch (httpMethod) {
            case 'GET':
                if (pathParameters?.id) {
                    const result = await dynamodb.get({
                        TableName: process.env.TABLE_NAME!,
                        Key: { id: pathParameters.id }
                    }).promise();
                    return response(200, result.Item);
                }
                const items = await dynamodb.scan({ TableName: process.env.TABLE_NAME! }).promise();
                return response(200, items.Items);
            
            case 'POST':
                const data = JSON.parse(body || '{}');
                const newItem = { id: Date.now().toString(), ...data, createdAt: new Date().toISOString() };
                await dynamodb.put({ TableName: process.env.TABLE_NAME!, Item: newItem }).promise();
                return response(201, newItem);
            
            case 'PUT':
                const updateData = JSON.parse(body || '{}');
                await dynamodb.update({
                    TableName: process.env.TABLE_NAME!,
                    Key: { id: pathParameters!.id },
                    UpdateExpression: 'SET #data = :data, updatedAt = :updatedAt',
                    ExpressionAttributeNames: { '#data': 'data' },
                    ExpressionAttributeValues: { ':data': updateData, ':updatedAt': new Date().toISOString() }
                }).promise();
                return response(200, { id: pathParameters!.id, ...updateData });
            
            case 'DELETE':
                await dynamodb.delete({
                    TableName: process.env.TABLE_NAME!,
                    Key: { id: pathParameters!.id }
                }).promise();
                return response(204, null);
            
            default:
                return response(405, { error: 'Method not allowed' });
        }
    } catch (error) {
        console.error(error);
        return response(500, { error: 'Internal server error' });
    }
};

// SQS Handler
export const sqsHandler: SQSHandler = async (event) => {
    for (const record of event.Records) {
        const message = JSON.parse(record.body);
        console.log('Processing message:', message);
        
        // Process message
        await processMessage(message);
    }
};

// S3 Trigger Handler
export const s3Handler: S3Handler = async (event) => {
    for (const record of event.Records) {
        const bucket = record.s3.bucket.name;
        const key = decodeURIComponent(record.s3.object.key);
        
        console.log(\`Processing \${bucket}/\${key}\`);
        
        // Get object
        const object = await s3.getObject({ Bucket: bucket, Key: key }).promise();
        
        // Process file
        await processFile(object.Body);
    }
};

// Scheduled Event (CloudWatch)
export const scheduledHandler = async () => {
    console.log('Running scheduled task at', new Date().toISOString());
    
    // Your scheduled logic here
    await runScheduledTask();
};

// Helper
function response(statusCode: number, body: any): APIGatewayProxyResult {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        },
        body: body ? JSON.stringify(body) : ''
    };
}

// serverless.yml
const serverlessConfig = \`
service: my-api

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  environment:
    TABLE_NAME: \${self:service}-\${sls:stage}
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:*
          Resource: !GetAtt Table.Arn

functions:
  api:
    handler: handler.apiHandler
    events:
      - http:
          path: /items
          method: any
          cors: true
      - http:
          path: /items/{id}
          method: any
          cors: true

  sqsProcessor:
    handler: handler.sqsHandler
    events:
      - sqs:
          arn: !GetAtt Queue.Arn

  scheduled:
    handler: handler.scheduledHandler
    events:
      - schedule: rate(1 hour)

resources:
  Resources:
    Table:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: \${self:service}-\${sls:stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
\`;
`;
    }

    private generateCloudFunctions(): string {
        return `// Google Cloud Functions
// Generated by Shadow AI

import * as functions from '@google-cloud/functions-framework';
import { Firestore } from '@google-cloud/firestore';
import { Storage } from '@google-cloud/storage';
import { PubSub } from '@google-cloud/pubsub';

const firestore = new Firestore();
const storage = new Storage();
const pubsub = new PubSub();

// HTTP Function
functions.http('api', async (req, res) => {
    res.set('Access-Control-Allow-Origin', '*');
    
    if (req.method === 'OPTIONS') {
        res.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
        res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
        res.status(204).send('');
        return;
    }

    try {
        const collection = firestore.collection('items');

        switch (req.method) {
            case 'GET':
                const snapshot = await collection.orderBy('createdAt', 'desc').get();
                const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                res.json(items);
                break;
            
            case 'POST':
                const newDoc = await collection.add({
                    ...req.body,
                    createdAt: new Date()
                });
                res.status(201).json({ id: newDoc.id, ...req.body });
                break;

            default:
                res.status(405).json({ error: 'Method not allowed' });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Pub/Sub Triggered Function
functions.cloudEvent('pubsubHandler', async (cloudEvent) => {
    const message = cloudEvent.data?.message;
    const data = Buffer.from(message.data, 'base64').toString();
    const parsed = JSON.parse(data);
    
    console.log('Received message:', parsed);
    
    // Process message
    await processMessage(parsed);
});

// Storage Triggered Function
functions.cloudEvent('storageHandler', async (cloudEvent) => {
    const file = cloudEvent.data;
    console.log(\`Processing file: \${file.bucket}/\${file.name}\`);
    
    const bucket = storage.bucket(file.bucket);
    const blob = bucket.file(file.name);
    
    const [contents] = await blob.download();
    await processFile(contents);
});

// Scheduled Function (Cloud Scheduler)
functions.http('scheduled', async (req, res) => {
    console.log('Running scheduled task');
    
    await runScheduledTask();
    
    res.status(200).send('OK');
});
`;
    }

    private generateVercel(): string {
        return `// Vercel Serverless Functions
// Generated by Shadow AI

// api/items/index.ts
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { prisma } from '../../lib/prisma';

export default async function handler(req: VercelRequest, res: VercelResponse) {
    try {
        switch (req.method) {
            case 'GET':
                const items = await prisma.item.findMany({
                    orderBy: { createdAt: 'desc' },
                    take: 50
                });
                return res.json(items);
            
            case 'POST':
                const newItem = await prisma.item.create({
                    data: req.body
                });
                return res.status(201).json(newItem);
            
            default:
                return res.status(405).json({ error: 'Method not allowed' });
        }
    } catch (error) {
        console.error(error);
        return res.status(500).json({ error: 'Internal server error' });
    }
}

// api/items/[id].ts
export default async function handler(req: VercelRequest, res: VercelResponse) {
    const { id } = req.query;
    
    try {
        switch (req.method) {
            case 'GET':
                const item = await prisma.item.findUnique({ where: { id: String(id) } });
                if (!item) return res.status(404).json({ error: 'Not found' });
                return res.json(item);
            
            case 'PUT':
                const updated = await prisma.item.update({
                    where: { id: String(id) },
                    data: req.body
                });
                return res.json(updated);
            
            case 'DELETE':
                await prisma.item.delete({ where: { id: String(id) } });
                return res.status(204).end();
            
            default:
                return res.status(405).json({ error: 'Method not allowed' });
        }
    } catch (error) {
        console.error(error);
        return res.status(500).json({ error: 'Internal server error' });
    }
}

// api/cron.ts (with vercel.json cron config)
export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.headers.authorization !== \`Bearer \${process.env.CRON_SECRET}\`) {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    
    console.log('Running cron job');
    await runScheduledTask();
    
    return res.json({ success: true });
}

// vercel.json
const vercelConfig = {
    "crons": [{
        "path": "/api/cron",
        "schedule": "0 * * * *"
    }]
};
`;
    }
}

export const serverlessGenerator = ServerlessGenerator.getInstance();
