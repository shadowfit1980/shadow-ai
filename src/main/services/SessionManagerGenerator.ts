/**
 * ðŸ” SessionManagerGenerator
 * 
 * Session management:
 * - JWT, Redis sessions, refresh tokens
 */

import { EventEmitter } from 'events';

export class SessionManagerGenerator extends EventEmitter {
    private static instance: SessionManagerGenerator;
    private constructor() { super(); }
    static getInstance(): SessionManagerGenerator {
        if (!SessionManagerGenerator.instance) {
            SessionManagerGenerator.instance = new SessionManagerGenerator();
        }
        return SessionManagerGenerator.instance;
    }

    generate(): string {
        return `// Session Manager Generator - JWT, Redis sessions, refresh tokens
// Generated by Shadow AI

import jwt from 'jsonwebtoken';
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

class SessionManager {
    private accessTokenSecret = process.env.JWT_ACCESS_SECRET!;
    private refreshTokenSecret = process.env.JWT_REFRESH_SECRET!;
    private accessTokenExpiry = '15m';
    private refreshTokenExpiry = '7d';
    
    async createSession(user: { id: string; email: string; role: string }) {
        const accessToken = jwt.sign(
            { userId: user.id, email: user.email, role: user.role },
            this.accessTokenSecret,
            { expiresIn: this.accessTokenExpiry }
        );
        
        const refreshToken = jwt.sign(
            { userId: user.id },
            this.refreshTokenSecret,
            { expiresIn: this.refreshTokenExpiry }
        );
        
        // Store refresh token in Redis
        await redis.set(
            \`refresh:\${user.id}:\${refreshToken}\`,
            JSON.stringify({ createdAt: Date.now() }),
            'EX', 7 * 24 * 60 * 60
        );
        
        return { accessToken, refreshToken };
    }
    
    async refreshSession(refreshToken: string) {
        try {
            const decoded = jwt.verify(refreshToken, this.refreshTokenSecret) as { userId: string };
            
            // Verify token exists in Redis
            const exists = await redis.get(\`refresh:\${decoded.userId}:\${refreshToken}\`);
            if (!exists) throw new Error('Invalid refresh token');
            
            // Get user
            const user = await prisma.user.findUnique({ where: { id: decoded.userId } });
            if (!user) throw new Error('User not found');
            
            // Rotate refresh token
            await redis.del(\`refresh:\${decoded.userId}:\${refreshToken}\`);
            
            return this.createSession(user);
        } catch (error) {
            throw new Error('Invalid refresh token');
        }
    }
    
    async revokeSession(userId: string, refreshToken: string) {
        await redis.del(\`refresh:\${userId}:\${refreshToken}\`);
    }
    
    async revokeAllSessions(userId: string) {
        const keys = await redis.keys(\`refresh:\${userId}:*\`);
        if (keys.length > 0) await redis.del(...keys);
    }
    
    async getActiveSessions(userId: string) {
        const keys = await redis.keys(\`refresh:\${userId}:*\`);
        const sessions = [];
        
        for (const key of keys) {
            const data = await redis.get(key);
            if (data) {
                sessions.push({
                    token: key.split(':')[2],
                    ...JSON.parse(data)
                });
            }
        }
        
        return sessions;
    }
    
    verifyAccessToken(token: string) {
        return jwt.verify(token, this.accessTokenSecret);
    }
}

// Auth Middleware
function authMiddleware(sessionManager: SessionManager) {
    return (req: any, res: any, next: Function) => {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) return res.status(401).json({ error: 'No token' });
        
        try {
            req.user = sessionManager.verifyAccessToken(token);
            next();
        } catch (error) {
            return res.status(401).json({ error: 'Invalid token' });
        }
    };
}

export { SessionManager, authMiddleware };
`;
    }
}

export const sessionManagerGenerator = SessionManagerGenerator.getInstance();
