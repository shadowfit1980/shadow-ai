/**
 * ðŸ‘¥ ShadowTeamsService
 * 
 * Team collaboration with AI:
 * - Task assignment, skill-based routing, team insights
 */

import { EventEmitter } from 'events';

export class ShadowTeamsService extends EventEmitter {
    private static instance: ShadowTeamsService;
    private constructor() { super(); }
    static getInstance(): ShadowTeamsService {
        if (!ShadowTeamsService.instance) {
            ShadowTeamsService.instance = new ShadowTeamsService();
        }
        return ShadowTeamsService.instance;
    }

    generate(): string {
        return `// Shadow Teams Service - Team collaboration with AI
// Generated by Shadow AI

interface TeamMember {
    id: string;
    name: string;
    skills: string[];
    skillLevels: Record<string, number>;
    availability: number; // 0-100
    currentTasks: string[];
    performanceScore: number;
}

interface Team {
    id: string;
    name: string;
    members: TeamMember[];
    projects: string[];
}

class ShadowTeams {
    private teams: Map<string, Team> = new Map();
    private taskAssignments: Map<string, string> = new Map(); // taskId -> memberId
    
    // Create team
    createTeam(name: string, members: TeamMember[]): string {
        const id = crypto.randomUUID();
        
        this.teams.set(id, {
            id,
            name,
            members,
            projects: []
        });
        
        return id;
    }
    
    // Add member
    addMember(teamId: string, member: TeamMember): void {
        const team = this.teams.get(teamId);
        if (!team) throw new Error('Team not found');
        
        team.members.push(member);
    }
    
    // AI-powered task assignment
    async assignTask(teamId: string, task: Task): Promise<TaskAssignment> {
        const team = this.teams.get(teamId);
        if (!team) throw new Error('Team not found');
        
        // Analyze task requirements
        const requirements = await this.analyzeTaskRequirements(task);
        
        // Score each member
        const scores = team.members.map(member => ({
            member,
            score: this.scoreMemberForTask(member, requirements)
        }));
        
        // Sort by score
        scores.sort((a, b) => b.score - a.score);
        
        const assigned = scores[0].member;
        
        // Record assignment
        this.taskAssignments.set(task.id, assigned.id);
        assigned.currentTasks.push(task.id);
        
        return {
            taskId: task.id,
            memberId: assigned.id,
            memberName: assigned.name,
            confidence: scores[0].score / 100,
            reasoning: await this.generateAssignmentReasoning(assigned, task, requirements)
        };
    }
    
    private async analyzeTaskRequirements(task: Task): Promise<TaskRequirements> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Analyze this task and identify required skills. Return JSON:
            { skills: string[], complexity: 'low' | 'medium' | 'high', estimatedHours: number }\`
        }, {
            role: 'user',
            content: \`Task: \${task.title}\\n\\nDescription: \${task.description}\`
        }]);
        
        return JSON.parse(response.content);
    }
    
    private scoreMemberForTask(member: TeamMember, requirements: TaskRequirements): number {
        let score = 0;
        
        // Skill match
        const skillMatch = requirements.skills.filter(s => member.skills.includes(s)).length;
        score += (skillMatch / requirements.skills.length) * 40;
        
        // Skill level
        for (const skill of requirements.skills) {
            score += (member.skillLevels[skill] || 0) * 2;
        }
        
        // Availability
        score += member.availability * 0.2;
        
        // Workload (fewer current tasks = higher score)
        score -= member.currentTasks.length * 5;
        
        // Performance history
        score += member.performanceScore * 0.1;
        
        return Math.max(0, score);
    }
    
    // AI code review for specific member
    async reviewForMember(memberId: string, code: string): Promise<Review> {
        const member = this.findMember(memberId);
        if (!member) throw new Error('Member not found');
        
        const response = await llm.chat([{
            role: 'system',
            content: \`Review this code for \${member.name}. They are \${member.skills.join(', ')} developer.
            Focus on their skill gaps: \${this.identifySkillGaps(member).join(', ')}.
            Be encouraging and educational.\`
        }, {
            role: 'user',
            content: code
        }]);
        
        return {
            review: response.content,
            targetedForSkillLevel: true,
            learningOpportunities: await this.identifyLearningOpportunities(member, code)
        };
    }
    
    // Team insights
    async getTeamInsights(teamId: string): Promise<TeamInsights> {
        const team = this.teams.get(teamId);
        if (!team) throw new Error('Team not found');
        
        return {
            skillCoverage: this.calculateSkillCoverage(team),
            bottlenecks: this.identifyBottlenecks(team),
            recommendations: await this.generateTeamRecommendations(team),
            workloadBalance: this.calculateWorkloadBalance(team)
        };
    }
    
    private calculateSkillCoverage(team: Team): Record<string, number> {
        const coverage: Record<string, number> = {};
        const allSkills = new Set(team.members.flatMap(m => m.skills));
        
        for (const skill of allSkills) {
            const membersWithSkill = team.members.filter(m => m.skills.includes(skill));
            coverage[skill] = membersWithSkill.length;
        }
        
        return coverage;
    }
    
    private identifyBottlenecks(team: Team): string[] {
        const bottlenecks: string[] = [];
        const coverage = this.calculateSkillCoverage(team);
        
        for (const [skill, count] of Object.entries(coverage)) {
            if (count === 1) {
                bottlenecks.push(\`Single point of failure: only 1 member knows \${skill}\`);
            }
        }
        
        const overloaded = team.members.filter(m => m.currentTasks.length > 5);
        if (overloaded.length > 0) {
            bottlenecks.push(\`Overloaded members: \${overloaded.map(m => m.name).join(', ')}\`);
        }
        
        return bottlenecks;
    }
    
    private findMember(memberId: string): TeamMember | null {
        for (const team of this.teams.values()) {
            const member = team.members.find(m => m.id === memberId);
            if (member) return member;
        }
        return null;
    }
    
    private identifySkillGaps(member: TeamMember): string[] {
        return Object.entries(member.skillLevels)
            .filter(([_, level]) => level < 60)
            .map(([skill]) => skill);
    }
}

export { ShadowTeams };
`;
    }
}

export const shadowTeamsService = ShadowTeamsService.getInstance();
