/**
 * ⛓️ Smart Contract Generator
 * 
 * Generate blockchain contracts:
 * - Solidity, Hardhat
 */

import { EventEmitter } from 'events';

export class SmartContractGenerator extends EventEmitter {
    private static instance: SmartContractGenerator;

    private constructor() { super(); }

    static getInstance(): SmartContractGenerator {
        if (!SmartContractGenerator.instance) {
            SmartContractGenerator.instance = new SmartContractGenerator();
        }
        return SmartContractGenerator.instance;
    }

    generate(): string {
        return `// Smart Contract Development
// Generated by Shadow AI

// === ERC20 Token (contracts/Token.sol) ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, ERC20Burnable, Ownable {
    uint256 public constant MAX_SUPPLY = 1_000_000_000 * 10**18;

    constructor() ERC20("MyToken", "MTK") Ownable(msg.sender) {
        _mint(msg.sender, 100_000_000 * 10**18);
    }

    function mint(address to, uint256 amount) public onlyOwner {
        require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds max supply");
        _mint(to, amount);
    }
}

// === NFT Collection (contracts/NFT.sol) ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721, ERC721URIStorage, ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    uint256 public constant PRICE = 0.05 ether;
    uint256 public constant MAX_SUPPLY = 10000;
    bool public saleActive = false;

    constructor() ERC721("MyNFT", "MNFT") Ownable(msg.sender) {}

    function toggleSale() external onlyOwner {
        saleActive = !saleActive;
    }

    function mint(uint256 quantity) external payable {
        require(saleActive, "Sale not active");
        require(quantity <= 10, "Max 10 per tx");
        require(_tokenIds.current() + quantity <= MAX_SUPPLY, "Exceeds supply");
        require(msg.value >= PRICE * quantity, "Insufficient payment");

        for (uint256 i = 0; i < quantity; i++) {
            _tokenIds.increment();
            _safeMint(msg.sender, _tokenIds.current());
        }
    }

    function setTokenURI(uint256 tokenId, string memory uri) external onlyOwner {
        _setTokenURI(tokenId, uri);
    }

    function withdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    // Required overrides
    function _update(address to, uint256 tokenId, address auth) internal override(ERC721, ERC721Enumerable) returns (address) {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }

    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

// === Hardhat Config (hardhat.config.ts) ===
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "dotenv/config";

const config: HardhatUserConfig = {
    solidity: {
        version: "0.8.20",
        settings: { optimizer: { enabled: true, runs: 200 } }
    },
    networks: {
        hardhat: {},
        sepolia: {
            url: process.env.SEPOLIA_RPC_URL,
            accounts: [process.env.PRIVATE_KEY!]
        },
        mainnet: {
            url: process.env.MAINNET_RPC_URL,
            accounts: [process.env.PRIVATE_KEY!]
        }
    },
    etherscan: {
        apiKey: process.env.ETHERSCAN_API_KEY
    }
};

export default config;

// === Deploy Script (scripts/deploy.ts) ===
import { ethers } from "hardhat";

async function main() {
    const [deployer] = await ethers.getSigners();
    console.log("Deploying with:", deployer.address);

    const Token = await ethers.getContractFactory("MyToken");
    const token = await Token.deploy();
    await token.waitForDeployment();
    console.log("Token deployed to:", await token.getAddress());

    const NFT = await ethers.getContractFactory("MyNFT");
    const nft = await NFT.deploy();
    await nft.waitForDeployment();
    console.log("NFT deployed to:", await nft.getAddress());
}

main().catch(console.error);

// === Test (test/Token.test.ts) ===
import { expect } from "chai";
import { ethers } from "hardhat";

describe("MyToken", function () {
    it("Should deploy with correct initial supply", async function () {
        const Token = await ethers.getContractFactory("MyToken");
        const token = await Token.deploy();
        
        const [owner] = await ethers.getSigners();
        const balance = await token.balanceOf(owner.address);
        
        expect(balance).to.equal(ethers.parseEther("100000000"));
    });

    it("Should allow owner to mint", async function () {
        const Token = await ethers.getContractFactory("MyToken");
        const token = await Token.deploy();
        
        const [owner, addr1] = await ethers.getSigners();
        await token.mint(addr1.address, ethers.parseEther("1000"));
        
        expect(await token.balanceOf(addr1.address)).to.equal(ethers.parseEther("1000"));
    });
});
`;
    }
}

export const smartContractGenerator = SmartContractGenerator.getInstance();
