/**
 * ðŸŽ¯ SmartRateLimiterService
 * 
 * Intelligent rate limiting:
 * - Adaptive limits, burst handling
 */

import { EventEmitter } from 'events';

export class SmartRateLimiterService extends EventEmitter {
    private static instance: SmartRateLimiterService;
    private constructor() { super(); }
    static getInstance(): SmartRateLimiterService {
        if (!SmartRateLimiterService.instance) {
            SmartRateLimiterService.instance = new SmartRateLimiterService();
        }
        return SmartRateLimiterService.instance;
    }

    generate(): string {
        return `// Smart Rate Limiter Service - Intelligent rate limiting
// Generated by Shadow AI

interface RateLimitConfig {
    tokensPerMinute: number;
    tokensPerHour: number;
    requestsPerMinute: number;
    burstAllowance: number;
    adaptiveScaling: boolean;
}

interface RateLimitState {
    tokensUsedThisMinute: number;
    tokensUsedThisHour: number;
    requestsThisMinute: number;
    lastResetMinute: number;
    lastResetHour: number;
    burstTokens: number;
}

class SmartRateLimiter {
    private configs: Map<string, RateLimitConfig> = new Map();
    private states: Map<string, RateLimitState> = new Map();
    
    constructor() {
        // Default configs for known providers
        this.configs.set('openai', { tokensPerMinute: 90000, tokensPerHour: 1000000, requestsPerMinute: 500, burstAllowance: 1.5, adaptiveScaling: true });
        this.configs.set('anthropic', { tokensPerMinute: 100000, tokensPerHour: 1000000, requestsPerMinute: 100, burstAllowance: 1.2, adaptiveScaling: true });
        this.configs.set('groq', { tokensPerMinute: 6000, tokensPerHour: 100000, requestsPerMinute: 30, burstAllowance: 2.0, adaptiveScaling: true });
    }
    
    // Check if request is allowed
    canMakeRequest(provider: string, estimatedTokens: number): { allowed: boolean; waitMs?: number; reason?: string } {
        const config = this.configs.get(provider);
        const state = this.getOrCreateState(provider);
        
        if (!config) {
            return { allowed: true };
        }
        
        // Reset counters if needed
        this.resetIfNeeded(provider);
        
        // Check tokens per minute
        if (state.tokensUsedThisMinute + estimatedTokens > config.tokensPerMinute * (1 + state.burstTokens)) {
            return {
                allowed: false,
                waitMs: this.calculateWaitTime(state, config, 'minute'),
                reason: 'Tokens per minute limit reached'
            };
        }
        
        // Check tokens per hour
        if (state.tokensUsedThisHour + estimatedTokens > config.tokensPerHour) {
            return {
                allowed: false,
                waitMs: this.calculateWaitTime(state, config, 'hour'),
                reason: 'Tokens per hour limit reached'
            };
        }
        
        // Check requests per minute
        if (state.requestsThisMinute >= config.requestsPerMinute) {
            return {
                allowed: false,
                waitMs: this.calculateWaitTime(state, config, 'minute'),
                reason: 'Requests per minute limit reached'
            };
        }
        
        return { allowed: true };
    }
    
    // Track usage
    trackUsage(provider: string, tokens: number): void {
        const state = this.getOrCreateState(provider);
        
        state.tokensUsedThisMinute += tokens;
        state.tokensUsedThisHour += tokens;
        state.requestsThisMinute++;
        
        // Emit usage event
        this.emit('usage', { provider, tokens, state });
    }
    
    // Wait for rate limit
    async waitForRateLimit(provider: string, estimatedTokens: number): Promise<void> {
        const check = this.canMakeRequest(provider, estimatedTokens);
        
        if (!check.allowed && check.waitMs) {
            this.emit('rate-limited', { provider, waitMs: check.waitMs, reason: check.reason });
            await new Promise(resolve => setTimeout(resolve, check.waitMs));
        }
    }
    
    // Execute with automatic retry on rate limit
    async executeWithRetry<T>(
        provider: string,
        estimatedTokens: number,
        executor: () => Promise<T>,
        maxRetries = 3
    ): Promise<T> {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            await this.waitForRateLimit(provider, estimatedTokens);
            
            try {
                const result = await executor();
                this.trackUsage(provider, estimatedTokens);
                return result;
            } catch (error: any) {
                if (this.isRateLimitError(error)) {
                    const waitTime = this.extractRetryAfter(error) || (2 ** attempt) * 1000;
                    this.emit('rate-limit-error', { provider, waitTime, attempt });
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                } else {
                    throw error;
                }
            }
        }
        
        throw new Error('Max retries exceeded');
    }
    
    // Adaptive scaling based on error rates
    adaptLimits(provider: string, errorRate: number): void {
        const config = this.configs.get(provider);
        if (!config || !config.adaptiveScaling) return;
        
        if (errorRate > 0.1) {
            // Too many errors, reduce limits
            config.tokensPerMinute *= 0.8;
            config.requestsPerMinute *= 0.8;
            this.emit('limits-reduced', { provider, reason: 'High error rate' });
        } else if (errorRate < 0.01) {
            // Very few errors, can increase limits
            config.tokensPerMinute = Math.min(config.tokensPerMinute * 1.1, 100000);
            config.requestsPerMinute = Math.min(config.requestsPerMinute * 1.1, 1000);
            this.emit('limits-increased', { provider, reason: 'Low error rate' });
        }
    }
    
    // Get current usage stats
    getUsageStats(provider: string): RateLimitState | null {
        return this.states.get(provider) || null;
    }
    
    // Set custom config
    setConfig(provider: string, config: Partial<RateLimitConfig>): void {
        const existing = this.configs.get(provider) || {
            tokensPerMinute: 10000,
            tokensPerHour: 100000,
            requestsPerMinute: 60,
            burstAllowance: 1.0,
            adaptiveScaling: true
        };
        
        this.configs.set(provider, { ...existing, ...config });
    }
    
    private getOrCreateState(provider: string): RateLimitState {
        if (!this.states.has(provider)) {
            this.states.set(provider, {
                tokensUsedThisMinute: 0,
                tokensUsedThisHour: 0,
                requestsThisMinute: 0,
                lastResetMinute: Date.now(),
                lastResetHour: Date.now(),
                burstTokens: 0
            });
        }
        return this.states.get(provider)!;
    }
    
    private resetIfNeeded(provider: string): void {
        const state = this.states.get(provider);
        if (!state) return;
        
        const now = Date.now();
        
        // Reset minute counters
        if (now - state.lastResetMinute >= 60000) {
            // Accumulate unused tokens as burst
            const config = this.configs.get(provider);
            if (config) {
                const unused = config.tokensPerMinute - state.tokensUsedThisMinute;
                state.burstTokens = Math.min(config.burstAllowance - 1, state.burstTokens + unused / config.tokensPerMinute);
            }
            
            state.tokensUsedThisMinute = 0;
            state.requestsThisMinute = 0;
            state.lastResetMinute = now;
        }
        
        // Reset hour counters
        if (now - state.lastResetHour >= 3600000) {
            state.tokensUsedThisHour = 0;
            state.lastResetHour = now;
        }
    }
    
    private calculateWaitTime(state: RateLimitState, config: RateLimitConfig, period: 'minute' | 'hour'): number {
        const now = Date.now();
        
        if (period === 'minute') {
            return 60000 - (now - state.lastResetMinute) + 100;
        } else {
            return 3600000 - (now - state.lastResetHour) + 100;
        }
    }
    
    private isRateLimitError(error: any): boolean {
        return error.status === 429 || error.message?.includes('rate limit');
    }
    
    private extractRetryAfter(error: any): number | null {
        return error.headers?.['retry-after'] ? parseInt(error.headers['retry-after']) * 1000 : null;
    }
}

export { SmartRateLimiter };
`;
    }
}

export const smartRateLimiterService = SmartRateLimiterService.getInstance();
