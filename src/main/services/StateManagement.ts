/**
 * ðŸ“¦ State Management Generator
 * 
 * Generate state management:
 * - Redux, Zustand, Pinia, MobX
 */

import { EventEmitter } from 'events';

export type StateLibrary = 'redux' | 'zustand' | 'mobx' | 'jotai';

export class StateManagement extends EventEmitter {
    private static instance: StateManagement;

    private constructor() { super(); }

    static getInstance(): StateManagement {
        if (!StateManagement.instance) {
            StateManagement.instance = new StateManagement();
        }
        return StateManagement.instance;
    }

    getLibraries(): StateLibrary[] {
        return ['redux', 'zustand', 'mobx', 'jotai'];
    }

    generate(library: StateLibrary): string {
        switch (library) {
            case 'redux': return this.generateRedux();
            case 'zustand': return this.generateZustand();
            case 'mobx': return this.generateMobX();
            case 'jotai': return this.generateJotai();
            default: return '';
        }
    }

    private generateRedux(): string {
        return `// Redux Toolkit
// Generated by Shadow AI

import { configureStore, createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';

// Types
interface User { id: string; name: string; email: string; }
interface AuthState {
    user: User | null;
    token: string | null;
    loading: boolean;
    error: string | null;
}

// Thunks
export const login = createAsyncThunk(
    'auth/login',
    async (credentials: { email: string; password: string }, { rejectWithValue }) => {
        try {
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(credentials)
            });
            if (!response.ok) throw new Error('Login failed');
            return response.json();
        } catch (error) {
            return rejectWithValue((error as Error).message);
        }
    }
);

export const logout = createAsyncThunk('auth/logout', async () => {
    await fetch('/api/auth/logout', { method: 'POST' });
});

// Slice
const authSlice = createSlice({
    name: 'auth',
    initialState: { user: null, token: null, loading: false, error: null } as AuthState,
    reducers: {
        setUser: (state, action: PayloadAction<User>) => {
            state.user = action.payload;
        },
        clearError: (state) => {
            state.error = null;
        }
    },
    extraReducers: (builder) => {
        builder
            .addCase(login.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(login.fulfilled, (state, action) => {
                state.loading = false;
                state.user = action.payload.user;
                state.token = action.payload.token;
            })
            .addCase(login.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload as string;
            })
            .addCase(logout.fulfilled, (state) => {
                state.user = null;
                state.token = null;
            });
    }
});

export const { setUser, clearError } = authSlice.actions;

// Store
export const store = configureStore({
    reducer: {
        auth: authSlice.reducer
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false })
});

// Types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Typed hooks
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Selectors
export const selectUser = (state: RootState) => state.auth.user;
export const selectIsAuthenticated = (state: RootState) => !!state.auth.token;
`;
    }

    private generateZustand(): string {
        return `// Zustand
// Generated by Shadow AI

import { create } from 'zustand';
import { devtools, persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface User { id: string; name: string; email: string; }

interface AuthStore {
    user: User | null;
    token: string | null;
    loading: boolean;
    error: string | null;
    login: (email: string, password: string) => Promise<void>;
    logout: () => void;
    setUser: (user: User) => void;
    clearError: () => void;
}

export const useAuthStore = create<AuthStore>()(
    devtools(
        persist(
            immer((set, get) => ({
                user: null,
                token: null,
                loading: false,
                error: null,

                login: async (email, password) => {
                    set({ loading: true, error: null });
                    try {
                        const response = await fetch('/api/auth/login', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email, password })
                        });
                        
                        if (!response.ok) throw new Error('Login failed');
                        
                        const { user, token } = await response.json();
                        set({ user, token, loading: false });
                    } catch (error) {
                        set({ error: (error as Error).message, loading: false });
                    }
                },

                logout: () => {
                    set({ user: null, token: null });
                },

                setUser: (user) => {
                    set((state) => { state.user = user; });
                },

                clearError: () => {
                    set({ error: null });
                }
            })),
            {
                name: 'auth-storage',
                storage: createJSONStorage(() => localStorage),
                partialize: (state) => ({ user: state.user, token: state.token })
            }
        ),
        { name: 'auth' }
    )
);

// Selectors
export const selectUser = () => useAuthStore((state) => state.user);
export const selectIsAuthenticated = () => useAuthStore((state) => !!state.token);

// Counter store example (simple)
interface CounterStore {
    count: number;
    increment: () => void;
    decrement: () => void;
    reset: () => void;
}

export const useCounterStore = create<CounterStore>((set) => ({
    count: 0,
    increment: () => set((state) => ({ count: state.count + 1 })),
    decrement: () => set((state) => ({ count: state.count - 1 })),
    reset: () => set({ count: 0 })
}));
`;
    }

    private generateMobX(): string {
        return `// MobX
// Generated by Shadow AI

import { makeAutoObservable, runInAction, reaction, autorun } from 'mobx';
import { observer } from 'mobx-react-lite';
import { createContext, useContext } from 'react';

interface User { id: string; name: string; email: string; }

class AuthStore {
    user: User | null = null;
    token: string | null = null;
    loading = false;
    error: string | null = null;

    constructor() {
        makeAutoObservable(this);
        this.loadFromStorage();
    }

    get isAuthenticated() {
        return !!this.token;
    }

    private loadFromStorage() {
        const stored = localStorage.getItem('auth');
        if (stored) {
            const { user, token } = JSON.parse(stored);
            runInAction(() => {
                this.user = user;
                this.token = token;
            });
        }
    }

    async login(email: string, password: string) {
        this.loading = true;
        this.error = null;

        try {
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            });

            if (!response.ok) throw new Error('Login failed');

            const { user, token } = await response.json();

            runInAction(() => {
                this.user = user;
                this.token = token;
                this.loading = false;
            });

            localStorage.setItem('auth', JSON.stringify({ user, token }));
        } catch (error) {
            runInAction(() => {
                this.error = (error as Error).message;
                this.loading = false;
            });
        }
    }

    logout() {
        this.user = null;
        this.token = null;
        localStorage.removeItem('auth');
    }
}

class RootStore {
    authStore: AuthStore;

    constructor() {
        this.authStore = new AuthStore();
    }
}

const rootStore = new RootStore();
const StoreContext = createContext(rootStore);

export const StoreProvider = ({ children }) => (
    <StoreContext.Provider value={rootStore}>{children}</StoreContext.Provider>
);

export const useStore = () => useContext(StoreContext);
export const useAuthStore = () => useStore().authStore;

// Usage in component
const LoginButton = observer(() => {
    const auth = useAuthStore();
    
    if (auth.isAuthenticated) {
        return <button onClick={() => auth.logout()}>Logout</button>;
    }
    
    return <button onClick={() => auth.login('test@test.com', 'password')}>Login</button>;
});

export { rootStore, observer };
`;
    }

    private generateJotai(): string {
        return `// Jotai
// Generated by Shadow AI

import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai';
import { atomWithStorage, atomWithReset, RESET } from 'jotai/utils';
import { atomWithQuery, atomWithMutation } from 'jotai-tanstack-query';

interface User { id: string; name: string; email: string; }

// Primitive atoms
export const userAtom = atomWithStorage<User | null>('user', null);
export const tokenAtom = atomWithStorage<string | null>('token', null);
export const loadingAtom = atom(false);
export const errorAtom = atomWithReset<string | null>(null);

// Derived atoms
export const isAuthenticatedAtom = atom((get) => !!get(tokenAtom));

// Async atom (with query)
export const userQueryAtom = atomWithQuery((get) => ({
    queryKey: ['user', get(tokenAtom)],
    queryFn: async () => {
        const token = get(tokenAtom);
        if (!token) return null;
        
        const res = await fetch('/api/me', {
            headers: { Authorization: \`Bearer \${token}\` }
        });
        return res.json();
    },
    enabled: !!get(tokenAtom)
}));

// Mutation atom
export const loginMutationAtom = atomWithMutation((get) => ({
    mutationFn: async ({ email, password }: { email: string; password: string }) => {
        const res = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
        });
        if (!res.ok) throw new Error('Login failed');
        return res.json();
    },
    onSuccess: (data) => {
        // This would need to be called outside to update atoms
    }
}));

// Actions as atoms
export const loginAtom = atom(
    null,
    async (get, set, { email, password }: { email: string; password: string }) => {
        set(loadingAtom, true);
        set(errorAtom, RESET);
        
        try {
            const res = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            });
            
            if (!res.ok) throw new Error('Login failed');
            
            const { user, token } = await res.json();
            set(userAtom, user);
            set(tokenAtom, token);
        } catch (error) {
            set(errorAtom, (error as Error).message);
        } finally {
            set(loadingAtom, false);
        }
    }
);

export const logoutAtom = atom(null, (get, set) => {
    set(userAtom, null);
    set(tokenAtom, null);
});

// Usage
function LoginComponent() {
    const [, login] = useAtom(loginAtom);
    const [, logout] = useAtom(logoutAtom);
    const isAuthenticated = useAtomValue(isAuthenticatedAtom);
    const loading = useAtomValue(loadingAtom);
    const error = useAtomValue(errorAtom);

    return (
        <div>
            {error && <p>{error}</p>}
            {isAuthenticated ? (
                <button onClick={() => logout()}>Logout</button>
            ) : (
                <button disabled={loading} onClick={() => login({ email: 'test@test.com', password: 'pass' })}>
                    {loading ? 'Loading...' : 'Login'}
                </button>
            )}
        </div>
    );
}
`;
    }
}

export const stateManagement = StateManagement.getInstance();
