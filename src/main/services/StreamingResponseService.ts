/**
 * ðŸ”€ StreamingResponseService
 * 
 * Response streaming:
 * - SSE, chunks, real-time
 */

import { EventEmitter } from 'events';

export class StreamingResponseService extends EventEmitter {
    private static instance: StreamingResponseService;
    private constructor() { super(); }
    static getInstance(): StreamingResponseService {
        if (!StreamingResponseService.instance) {
            StreamingResponseService.instance = new StreamingResponseService();
        }
        return StreamingResponseService.instance;
    }

    generate(): string {
        return `// Streaming Response Service - SSE, chunks
// Generated by Shadow AI

import OpenAI from 'openai';

class StreamingResponse {
    private openai = new OpenAI();
    
    // Stream chat completion
    async *streamChat(messages: any[], options: StreamOptions = {}): AsyncGenerator<StreamChunk> {
        const stream = await this.openai.chat.completions.create({
            model: options.model || 'gpt-4-turbo-preview',
            messages,
            stream: true
        });
        
        let fullContent = '';
        
        for await (const chunk of stream) {
            const delta = chunk.choices[0]?.delta?.content || '';
            fullContent += delta;
            
            yield {
                content: delta,
                fullContent,
                done: false,
                usage: null
            };
        }
        
        yield {
            content: '',
            fullContent,
            done: true,
            usage: null
        };
    }
    
    // Stream with tool calls
    async *streamWithTools(messages: any[], tools: any[]): AsyncGenerator<ToolStreamChunk> {
        const stream = await this.openai.chat.completions.create({
            model: 'gpt-4-turbo-preview',
            messages,
            tools,
            stream: true
        });
        
        let fullContent = '';
        const toolCalls: any[] = [];
        
        for await (const chunk of stream) {
            const delta = chunk.choices[0]?.delta;
            
            if (delta?.content) {
                fullContent += delta.content;
                yield { type: 'content', content: delta.content, fullContent };
            }
            
            if (delta?.tool_calls) {
                for (const tc of delta.tool_calls) {
                    if (tc.index >= toolCalls.length) {
                        toolCalls.push({ id: tc.id, function: { name: '', arguments: '' } });
                    }
                    
                    if (tc.function?.name) {
                        toolCalls[tc.index].function.name = tc.function.name;
                    }
                    
                    if (tc.function?.arguments) {
                        toolCalls[tc.index].function.arguments += tc.function.arguments;
                    }
                    
                    yield { type: 'tool_call', toolCall: toolCalls[tc.index] };
                }
            }
        }
        
        yield { type: 'done', content: fullContent, toolCalls };
    }
    
    // Create SSE response
    createSSEResponse(generator: AsyncGenerator<any>): Response {
        const stream = new ReadableStream({
            async start(controller) {
                try {
                    for await (const chunk of generator) {
                        controller.enqueue(\`data: \${JSON.stringify(chunk)}\\n\\n\`);
                    }
                    controller.enqueue('data: [DONE]\\n\\n');
                    controller.close();
                } catch (error) {
                    controller.error(error);
                }
            }
        });
        
        return new Response(stream, {
            headers: {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
            }
        });
    }
    
    // Parse SSE events
    async *parseSSE(response: Response): AsyncGenerator<any> {
        const reader = response.body!.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\\n');
            buffer = lines.pop() || '';
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    if (data === '[DONE]') return;
                    yield JSON.parse(data);
                }
            }
        }
    }
}

export { StreamingResponse };
`;
    }
}

export const streamingResponseService = StreamingResponseService.getInstance();
