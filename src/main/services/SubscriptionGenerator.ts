/**
 * ðŸ’³ SubscriptionGenerator
 * 
 * Subscription management:
 * - Plans, billing, usage, trials
 */

import { EventEmitter } from 'events';

export class SubscriptionGenerator extends EventEmitter {
    private static instance: SubscriptionGenerator;
    private constructor() { super(); }
    static getInstance(): SubscriptionGenerator {
        if (!SubscriptionGenerator.instance) {
            SubscriptionGenerator.instance = new SubscriptionGenerator();
        }
        return SubscriptionGenerator.instance;
    }

    generate(): string {
        return `// Subscription Generator - Plans, billing, usage, trials
// Generated by Shadow AI

// Subscription Schema
model Subscription {
    id          String   @id @default(cuid())
    userId      String
    planId      String
    status      SubscriptionStatus @default(ACTIVE)
    currentPeriodStart DateTime
    currentPeriodEnd   DateTime
    cancelAtPeriodEnd  Boolean @default(false)
    trialEnd           DateTime?
    stripeSubscriptionId String? @unique
    createdAt   DateTime @default(now())
}

// Subscription Service
class SubscriptionService {
    async createSubscription(userId: string, planId: string, paymentMethodId?: string) {
        const plan = await prisma.plan.findUnique({ where: { id: planId } });
        
        // Create Stripe subscription
        const stripeSubscription = await stripe.subscriptions.create({
            customer: await this.getOrCreateCustomer(userId),
            items: [{ price: plan.stripePriceId }],
            trial_period_days: plan.trialDays || 0,
            payment_behavior: 'default_incomplete',
            expand: ['latest_invoice.payment_intent']
        });
        
        // Create local subscription
        return prisma.subscription.create({
            data: {
                userId,
                planId,
                status: 'TRIALING',
                stripeSubscriptionId: stripeSubscription.id,
                currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
                currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
                trialEnd: stripeSubscription.trial_end 
                    ? new Date(stripeSubscription.trial_end * 1000) 
                    : null
            }
        });
    }
    
    async cancelSubscription(subscriptionId: string, immediate = false) {
        const subscription = await prisma.subscription.findUnique({ where: { id: subscriptionId } });
        
        if (immediate) {
            await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);
            return prisma.subscription.update({
                where: { id: subscriptionId },
                data: { status: 'CANCELED', canceledAt: new Date() }
            });
        } else {
            await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
                cancel_at_period_end: true
            });
            return prisma.subscription.update({
                where: { id: subscriptionId },
                data: { cancelAtPeriodEnd: true }
            });
        }
    }
    
    async changePlan(subscriptionId: string, newPlanId: string) {
        const subscription = await prisma.subscription.findUnique({ where: { id: subscriptionId } });
        const newPlan = await prisma.plan.findUnique({ where: { id: newPlanId } });
        
        const stripeSubscription = await stripe.subscriptions.retrieve(subscription.stripeSubscriptionId);
        
        await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
            items: [{
                id: stripeSubscription.items.data[0].id,
                price: newPlan.stripePriceId
            }],
            proration_behavior: 'always_invoice'
        });
        
        return prisma.subscription.update({
            where: { id: subscriptionId },
            data: { planId: newPlanId }
        });
    }
}

// Usage Metering
class UsageMeter {
    async recordUsage(subscriptionId: string, quantity: number, idempotencyKey?: string) {
        const subscription = await prisma.subscription.findUnique({ where: { id: subscriptionId } });
        
        await stripe.subscriptionItems.createUsageRecord(
            subscription.stripeItemId,
            { quantity, timestamp: Math.floor(Date.now() / 1000) },
            { idempotencyKey }
        );
    }
}

export { SubscriptionService, UsageMeter };
`;
    }
}

export const subscriptionGenerator = SubscriptionGenerator.getInstance();
