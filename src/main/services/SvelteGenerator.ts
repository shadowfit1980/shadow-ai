/**
 * ðŸ”¶ Svelte Generator
 * 
 * Generate Svelte code:
 * - Components, stores, transitions
 */

import { EventEmitter } from 'events';

export class SvelteGenerator extends EventEmitter {
    private static instance: SvelteGenerator;

    private constructor() { super(); }

    static getInstance(): SvelteGenerator {
        if (!SvelteGenerator.instance) {
            SvelteGenerator.instance = new SvelteGenerator();
        }
        return SvelteGenerator.instance;
    }

    generateApp(): string {
        return `// SvelteKit App Structure
// Generated by Shadow AI

// src/routes/+layout.svelte
<script lang="ts">
    import { page } from '$app/stores'
    import Header from '$lib/components/Header.svelte'
    import Footer from '$lib/components/Footer.svelte'
    import '../app.css'
</script>

<Header />
<main>
    <slot />
</main>
<Footer />

// src/routes/+page.svelte
<script lang="ts">
    import { onMount } from 'svelte'
    import { fade, slide } from 'svelte/transition'
    import { items } from '$lib/stores/items'

    let loading = true
    
    onMount(async () => {
        await items.fetch()
        loading = false
    })
</script>

<svelte:head>
    <title>Home | My App</title>
    <meta name="description" content="My awesome Svelte app" />
</svelte:head>

{#if loading}
    <div class="loading" transition:fade>Loading...</div>
{:else}
    <div class="content" transition:slide>
        {#each $items as item (item.id)}
            <div class="card" transition:fade={{ delay: 100 }}>
                <h3>{item.title}</h3>
                <p>{item.description}</p>
            </div>
        {/each}
    </div>
{/if}

<style>
    .content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1rem;
    }
    .card {
        padding: 1rem;
        border-radius: 8px;
        background: var(--surface);
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
</style>

// src/routes/+layout.server.ts
import type { LayoutServerLoad } from './$types'

export const load: LayoutServerLoad = async ({ locals }) => {
    return {
        user: locals.user
    }
}

// src/hooks.server.ts
import type { Handle } from '@sveltejs/kit'

export const handle: Handle = async ({ event, resolve }) => {
    const session = event.cookies.get('session')
    
    if (session) {
        event.locals.user = await getUserFromSession(session)
    }
    
    return resolve(event)
}
`;
    }

    generateComponent(name: string): string {
        return `// ${name}.svelte
<script lang="ts">
    import { createEventDispatcher, onMount, onDestroy } from 'svelte'
    import { fade, fly } from 'svelte/transition'
    import { quintOut } from 'svelte/easing'

    // Props
    export let title = 'Default Title'
    export let items: any[] = []
    export let loading = false

    // Events
    const dispatch = createEventDispatcher<{
        select: { id: string }
        delete: { id: string }
    }>()

    // Local state
    let selectedId: string | null = null
    let searchQuery = ''

    // Reactive declarations
    $: filteredItems = items.filter(item => 
        item.name.toLowerCase().includes(searchQuery.toLowerCase())
    )
    $: hasItems = filteredItems.length > 0

    // Methods
    function handleSelect(id: string) {
        selectedId = id
        dispatch('select', { id })
    }

    function handleDelete(id: string) {
        dispatch('delete', { id })
    }

    // Lifecycle
    onMount(() => {
        console.log('${name} mounted')
    })

    onDestroy(() => {
        console.log('${name} destroyed')
    })
</script>

<div class="${name.toLowerCase()}" transition:fade>
    <header>
        <h2>{title}</h2>
        <input 
            type="search" 
            bind:value={searchQuery} 
            placeholder="Search..."
        />
    </header>

    {#if loading}
        <div class="loading">Loading...</div>
    {:else if !hasItems}
        <div class="empty">No items found</div>
    {:else}
        <ul>
            {#each filteredItems as item, i (item.id)}
                <li 
                    class:selected={selectedId === item.id}
                    transition:fly={{ y: 20, delay: i * 50, easing: quintOut }}
                    on:click={() => handleSelect(item.id)}
                >
                    <span>{item.name}</span>
                    <button on:click|stopPropagation={() => handleDelete(item.id)}>Ã—</button>
                </li>
            {/each}
        </ul>
    {/if}

    <slot name="footer" />
</div>

<style>
    .${name.toLowerCase()} {
        padding: 1rem;
    }
    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    input {
        padding: 0.5rem;
        border: 1px solid var(--border);
        border-radius: 4px;
    }
    ul {
        list-style: none;
        padding: 0;
    }
    li {
        display: flex;
        justify-content: space-between;
        padding: 0.75rem;
        border-bottom: 1px solid var(--border);
        cursor: pointer;
    }
    li:hover {
        background: var(--hover);
    }
    li.selected {
        background: var(--primary-light);
    }
</style>
`;
    }

    generateStore(name: string): string {
        return `// ${name}Store.ts
import { writable, derived, get } from 'svelte/store'

interface ${name}Item {
    id: string
    name: string
    [key: string]: any
}

function create${name}Store() {
    const items = writable<${name}Item[]>([])
    const loading = writable(false)
    const error = writable<Error | null>(null)

    // Derived stores
    const count = derived(items, $items => $items.length)
    const isEmpty = derived(items, $items => $items.length === 0)

    return {
        subscribe: items.subscribe,
        loading: { subscribe: loading.subscribe },
        error: { subscribe: error.subscribe },
        count,
        isEmpty,

        async fetch() {
            loading.set(true)
            error.set(null)
            try {
                const res = await fetch('/api/${name.toLowerCase()}s')
                const data = await res.json()
                items.set(data)
            } catch (e) {
                error.set(e as Error)
            } finally {
                loading.set(false)
            }
        },

        async add(item: Omit<${name}Item, 'id'>) {
            const res = await fetch('/api/${name.toLowerCase()}s', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(item)
            })
            const newItem = await res.json()
            items.update(current => [...current, newItem])
            return newItem
        },

        async update(id: string, data: Partial<${name}Item>) {
            const res = await fetch(\`/api/${name.toLowerCase()}s/\${id}\`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            const updated = await res.json()
            items.update(current => 
                current.map(item => item.id === id ? updated : item)
            )
            return updated
        },

        async remove(id: string) {
            await fetch(\`/api/${name.toLowerCase()}s/\${id}\`, { method: 'DELETE' })
            items.update(current => current.filter(item => item.id !== id))
        },

        reset() {
            items.set([])
            loading.set(false)
            error.set(null)
        },

        getById(id: string) {
            return get(items).find(item => item.id === id)
        }
    }
}

export const ${name.toLowerCase()}s = create${name}Store()
`;
    }
}

export const svelteGenerator = SvelteGenerator.getInstance();
