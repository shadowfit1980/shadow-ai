/**
 * ðŸ”„ SyncGenerator
 * 
 * Data synchronization:
 * - Offline-first, conflict resolution, sync
 */

import { EventEmitter } from 'events';

export class SyncGenerator extends EventEmitter {
    private static instance: SyncGenerator;
    private constructor() { super(); }
    static getInstance(): SyncGenerator {
        if (!SyncGenerator.instance) {
            SyncGenerator.instance = new SyncGenerator();
        }
        return SyncGenerator.instance;
    }

    generate(): string {
        return `// Sync Generator - Offline-first, conflict resolution
// Generated by Shadow AI

// Sync Engine
class SyncEngine {
    private localDb: IDBDatabase;
    private pendingChanges: Change[] = [];
    
    async sync() {
        // 1. Pull remote changes
        const remoteChanges = await this.pullChanges();
        
        // 2. Apply remote changes locally
        for (const change of remoteChanges) {
            await this.applyChange(change);
        }
        
        // 3. Push local changes
        const localChanges = await this.getPendingChanges();
        for (const change of localChanges) {
            await this.pushChange(change);
        }
        
        // 4. Clear pending
        await this.clearPendingChanges();
    }
    
    private async applyChange(change: Change) {
        const local = await this.getLocal(change.id);
        
        if (!local) {
            // No conflict, apply directly
            await this.setLocal(change.id, change.data);
        } else if (local.updatedAt < change.updatedAt) {
            // Remote is newer
            await this.setLocal(change.id, change.data);
        } else {
            // Conflict - local is newer or same time
            await this.resolveConflict(local, change);
        }
    }
    
    private async resolveConflict(local: any, remote: Change) {
        // Last-write-wins by default
        const winner = local.updatedAt > remote.updatedAt ? local : remote.data;
        await this.setLocal(remote.id, winner);
    }
}

// Offline-First Hook
export function useOfflineFirst<T>(key: string, fetcher: () => Promise<T>) {
    const [data, setData] = useState<T | null>(null);
    const [isOnline, setIsOnline] = useState(navigator.onLine);
    
    useEffect(() => {
        // Load from cache first
        const cached = localStorage.getItem(key);
        if (cached) setData(JSON.parse(cached));
        
        // Then fetch fresh data
        if (isOnline) {
            fetcher().then(freshData => {
                setData(freshData);
                localStorage.setItem(key, JSON.stringify(freshData));
            });
        }
    }, [key, isOnline]);
    
    useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
            window.removeEventListener('online', handleOnline);
            window.removeEventListener('offline', handleOffline);
        };
    }, []);
    
    return { data, isOnline };
}

// IndexedDB Wrapper
class IndexedDBStore {
    private db: IDBDatabase | null = null;
    
    async open(name: string, version: number) {
        return new Promise<void>((resolve, reject) => {
            const request = indexedDB.open(name, version);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => { this.db = request.result; resolve(); };
            request.onupgradeneeded = (event) => {
                const db = (event.target as any).result;
                db.createObjectStore('data', { keyPath: 'id' });
            };
        });
    }
    
    async get<T>(key: string): Promise<T | null> {
        return new Promise((resolve, reject) => {
            const tx = this.db!.transaction('data', 'readonly');
            const request = tx.objectStore('data').get(key);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
        });
    }
    
    async set(key: string, value: any): Promise<void> {
        return new Promise((resolve, reject) => {
            const tx = this.db!.transaction('data', 'readwrite');
            const request = tx.objectStore('data').put({ id: key, ...value });
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve();
        });
    }
}

export { SyncEngine, IndexedDBStore };
`;
    }
}

export const syncGenerator = SyncGenerator.getInstance();
