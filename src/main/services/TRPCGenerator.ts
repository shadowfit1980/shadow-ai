/**
 * ðŸ”Œ tRPC Generator
 * 
 * Generate type-safe APIs:
 * - tRPC with React Query
 */

import { EventEmitter } from 'events';

export class TRPCGenerator extends EventEmitter {
    private static instance: TRPCGenerator;

    private constructor() { super(); }

    static getInstance(): TRPCGenerator {
        if (!TRPCGenerator.instance) {
            TRPCGenerator.instance = new TRPCGenerator();
        }
        return TRPCGenerator.instance;
    }

    generate(): string {
        return `// tRPC Setup
// Generated by Shadow AI

// === Server Setup ===
import { initTRPC, TRPCError } from '@trpc/server';
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { z } from 'zod';
import superjson from 'superjson';

// Context
interface Context {
    user: { id: string; email: string } | null;
    db: PrismaClient;
}

async function createContext({ req }: { req: any }): Promise<Context> {
    const token = req.headers.authorization?.replace('Bearer ', '');
    const user = token ? await verifyToken(token) : null;
    return { user, db: prisma };
}

// Initialize tRPC
const t = initTRPC.context<Context>().create({
    transformer: superjson,
    errorFormatter({ shape, error }) {
        return {
            ...shape,
            data: {
                ...shape.data,
                zodError: error.cause instanceof z.ZodError ? error.cause.flatten() : null
            }
        };
    }
});

// Middleware
const isAuthed = t.middleware(({ ctx, next }) => {
    if (!ctx.user) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return next({ ctx: { ...ctx, user: ctx.user } });
});

// Procedures
const publicProcedure = t.procedure;
const protectedProcedure = t.procedure.use(isAuthed);

// Routers
const userRouter = t.router({
    me: protectedProcedure.query(({ ctx }) => {
        return ctx.user;
    }),

    getById: publicProcedure
        .input(z.object({ id: z.string().uuid() }))
        .query(async ({ ctx, input }) => {
            const user = await ctx.db.user.findUnique({ where: { id: input.id } });
            if (!user) throw new TRPCError({ code: 'NOT_FOUND' });
            return user;
        }),

    update: protectedProcedure
        .input(z.object({
            name: z.string().min(2).optional(),
            email: z.string().email().optional()
        }))
        .mutation(async ({ ctx, input }) => {
            return ctx.db.user.update({
                where: { id: ctx.user.id },
                data: input
            });
        })
});

const postRouter = t.router({
    list: publicProcedure
        .input(z.object({
            limit: z.number().min(1).max(100).default(20),
            cursor: z.string().optional()
        }))
        .query(async ({ ctx, input }) => {
            const posts = await ctx.db.post.findMany({
                take: input.limit + 1,
                cursor: input.cursor ? { id: input.cursor } : undefined,
                orderBy: { createdAt: 'desc' }
            });

            let nextCursor: string | undefined;
            if (posts.length > input.limit) {
                const nextItem = posts.pop();
                nextCursor = nextItem!.id;
            }

            return { posts, nextCursor };
        }),

    create: protectedProcedure
        .input(z.object({
            title: z.string().min(1).max(200),
            content: z.string().min(1)
        }))
        .mutation(async ({ ctx, input }) => {
            return ctx.db.post.create({
                data: { ...input, authorId: ctx.user.id }
            });
        }),

    delete: protectedProcedure
        .input(z.object({ id: z.string().uuid() }))
        .mutation(async ({ ctx, input }) => {
            const post = await ctx.db.post.findUnique({ where: { id: input.id } });
            if (!post || post.authorId !== ctx.user.id) {
                throw new TRPCError({ code: 'FORBIDDEN' });
            }
            return ctx.db.post.delete({ where: { id: input.id } });
        })
});

// App router
export const appRouter = t.router({
    user: userRouter,
    post: postRouter
});

export type AppRouter = typeof appRouter;

// HTTP Server
const server = createHTTPServer({
    router: appRouter,
    createContext
});
server.listen(3000);

// === Client Setup ===
import { createTRPCReact, httpBatchLink } from '@trpc/react-query';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import type { AppRouter } from './server';

export const trpc = createTRPCReact<AppRouter>();

const queryClient = new QueryClient({
    defaultOptions: {
        queries: { staleTime: 5000, retry: 1 }
    }
});

const trpcClient = trpc.createClient({
    links: [
        httpBatchLink({
            url: 'http://localhost:3000',
            headers() {
                return { authorization: \`Bearer \${getToken()}\` };
            }
        })
    ],
    transformer: superjson
});

function TRPCProvider({ children }: { children: React.ReactNode }) {
    return (
        <trpc.Provider client={trpcClient} queryClient={queryClient}>
            <QueryClientProvider client={queryClient}>
                {children}
            </QueryClientProvider>
        </trpc.Provider>
    );
}

// === Usage in Components ===
function UserProfile() {
    const { data: user, isLoading } = trpc.user.me.useQuery();
    const updateUser = trpc.user.update.useMutation();

    if (isLoading) return <Loading />;

    return (
        <div>
            <h1>{user?.name}</h1>
            <button onClick={() => updateUser.mutate({ name: 'New Name' })}>
                Update
            </button>
        </div>
    );
}

function PostList() {
    const { data, fetchNextPage, hasNextPage } = trpc.post.list.useInfiniteQuery(
        { limit: 20 },
        { getNextPageParam: (lastPage) => lastPage.nextCursor }
    );

    const posts = data?.pages.flatMap(page => page.posts) ?? [];

    return (
        <div>
            {posts.map(post => <PostCard key={post.id} post={post} />)}
            {hasNextPage && <button onClick={() => fetchNextPage()}>Load More</button>}
        </div>
    );
}

export { TRPCProvider, trpc };
`;
    }
}

export const trpcGenerator = TRPCGenerator.getInstance();
