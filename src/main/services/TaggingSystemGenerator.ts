/**
 * ðŸ·ï¸ TaggingSystemGenerator
 * 
 * Tagging & taxonomy:
 * - Tags, categories, hierarchies
 */

import { EventEmitter } from 'events';

export class TaggingSystemGenerator extends EventEmitter {
    private static instance: TaggingSystemGenerator;
    private constructor() { super(); }
    static getInstance(): TaggingSystemGenerator {
        if (!TaggingSystemGenerator.instance) {
            TaggingSystemGenerator.instance = new TaggingSystemGenerator();
        }
        return TaggingSystemGenerator.instance;
    }

    generate(): string {
        return `// Tagging System Generator - Tags, categories, hierarchies
// Generated by Shadow AI

// Tag Schema
model Tag {
    id        String   @id @default(cuid())
    name      String
    slug      String   @unique
    color     String?
    items     TaggedItem[]
    createdAt DateTime @default(now())
}

model TaggedItem {
    id        String   @id @default(cuid())
    tagId     String
    tag       Tag      @relation(fields: [tagId], references: [id])
    itemId    String
    itemType  String
    @@unique([tagId, itemId, itemType])
}

// Category Schema (Hierarchical)
model Category {
    id        String     @id @default(cuid())
    name      String
    slug      String
    parentId  String?
    parent    Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
    children  Category[] @relation("CategoryHierarchy")
    level     Int        @default(0)
    path      String     // materialized path for fast queries
}

// Tag Service
class TagService {
    async addTag(itemId: string, itemType: string, tagName: string) {
        const tag = await prisma.tag.upsert({
            where: { slug: this.slugify(tagName) },
            create: { name: tagName, slug: this.slugify(tagName) },
            update: {}
        });
        
        return prisma.taggedItem.create({
            data: { tagId: tag.id, itemId, itemType }
        });
    }
    
    async removeTag(itemId: string, itemType: string, tagSlug: string) {
        const tag = await prisma.tag.findUnique({ where: { slug: tagSlug } });
        if (!tag) return;
        
        return prisma.taggedItem.delete({
            where: { tagId_itemId_itemType: { tagId: tag.id, itemId, itemType } }
        });
    }
    
    async getItemsByTag(tagSlug: string, itemType?: string) {
        return prisma.taggedItem.findMany({
            where: { tag: { slug: tagSlug }, itemType },
            include: { tag: true }
        });
    }
    
    async getTagCloud(itemType?: string) {
        return prisma.taggedItem.groupBy({
            by: ['tagId'],
            where: itemType ? { itemType } : {},
            _count: { tagId: true },
            orderBy: { _count: { tagId: 'desc' } }
        });
    }
    
    private slugify(text: string): string {
        return text.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');
    }
}

// Tag Input Component
export function TagInput({ value, onChange }: { value: string[]; onChange: (tags: string[]) => void }) {
    const [input, setInput] = useState('');
    const [suggestions, setSuggestions] = useState<string[]>([]);
    
    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter' && input.trim()) {
            e.preventDefault();
            onChange([...value, input.trim()]);
            setInput('');
        } else if (e.key === 'Backspace' && !input && value.length > 0) {
            onChange(value.slice(0, -1));
        }
    };
    
    return (
        <div className="tag-input">
            {value.map(tag => (
                <span key={tag} className="tag">
                    {tag}
                    <button onClick={() => onChange(value.filter(t => t !== tag))}>Ã—</button>
                </span>
            ))}
            <input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="Add tag..."
            />
        </div>
    );
}

export { TagService, TagInput };
`;
    }
}

export const taggingSystemGenerator = TaggingSystemGenerator.getInstance();
