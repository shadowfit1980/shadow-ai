/**
 * ðŸŽ¯ TaskPlannerService
 * 
 * Agent task planning:
 * - Decomposition, DAG, execution order
 */

import { EventEmitter } from 'events';

export class TaskPlannerService extends EventEmitter {
    private static instance: TaskPlannerService;
    private constructor() { super(); }
    static getInstance(): TaskPlannerService {
        if (!TaskPlannerService.instance) {
            TaskPlannerService.instance = new TaskPlannerService();
        }
        return TaskPlannerService.instance;
    }

    generate(): string {
        return `// Task Planner Service - Decomposition, DAG, execution
// Generated by Shadow AI

interface PlanStep {
    id: string;
    action: string;
    description: string;
    dependencies: string[];
    tool?: string;
    parameters?: Record<string, any>;
    status: 'pending' | 'running' | 'completed' | 'failed';
}

class TaskPlanner {
    async createPlan(goal: string, context: string): Promise<PlanStep[]> {
        const response = await llm.chat([{
            role: 'system',
            content: \`You are a task planning AI. Break down the user's goal into concrete executable steps.
            Return a JSON array of steps with: id, action, description, dependencies (array of step ids), tool (optional), parameters (optional).
            Order steps so dependencies come first.\`
        }, {
            role: 'user',
            content: \`Goal: \${goal}\\n\\nContext: \${context}\`
        }]);
        
        const steps: PlanStep[] = JSON.parse(response.content);
        return steps.map(s => ({ ...s, status: 'pending' }));
    }
    
    getExecutionOrder(steps: PlanStep[]): PlanStep[] {
        const completed = new Set<string>();
        const ordered: PlanStep[] = [];
        
        while (ordered.length < steps.length) {
            for (const step of steps) {
                if (ordered.includes(step)) continue;
                
                const depsReady = step.dependencies.every(d => completed.has(d));
                if (depsReady) {
                    ordered.push(step);
                    completed.add(step.id);
                }
            }
        }
        
        return ordered;
    }
    
    getParallelizable(steps: PlanStep[]): PlanStep[][] {
        const batches: PlanStep[][] = [];
        const completed = new Set<string>();
        const remaining = [...steps];
        
        while (remaining.length > 0) {
            const batch: PlanStep[] = [];
            
            for (let i = remaining.length - 1; i >= 0; i--) {
                const step = remaining[i];
                const depsReady = step.dependencies.every(d => completed.has(d));
                
                if (depsReady) {
                    batch.push(step);
                    remaining.splice(i, 1);
                }
            }
            
            if (batch.length === 0 && remaining.length > 0) {
                throw new Error('Circular dependency detected');
            }
            
            batch.forEach(s => completed.add(s.id));
            if (batch.length > 0) batches.push(batch);
        }
        
        return batches;
    }
    
    async refinePlan(steps: PlanStep[], feedback: string): Promise<PlanStep[]> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Refine the following plan based on feedback. Return updated JSON array.'
        }, {
            role: 'user',
            content: \`Current plan: \${JSON.stringify(steps)}\\n\\nFeedback: \${feedback}\`
        }]);
        
        return JSON.parse(response.content);
    }
}

export { TaskPlanner, PlanStep };
`;
    }
}

export const taskPlannerService = TaskPlannerService.getInstance();
