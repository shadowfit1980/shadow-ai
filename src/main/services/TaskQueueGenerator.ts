/**
 * ðŸ“‹ TaskQueueGenerator
 * 
 * Task queues:
 * - Priority queues, retries, dead letter
 */

import { EventEmitter } from 'events';

export class TaskQueueGenerator extends EventEmitter {
    private static instance: TaskQueueGenerator;
    private constructor() { super(); }
    static getInstance(): TaskQueueGenerator {
        if (!TaskQueueGenerator.instance) {
            TaskQueueGenerator.instance = new TaskQueueGenerator();
        }
        return TaskQueueGenerator.instance;
    }

    generate(): string {
        return `// Task Queue Generator - Priority queues, retries
// Generated by Shadow AI

import { Queue, Worker, Job } from 'bullmq';

// Priority Queue with Dead Letter
class PriorityTaskQueue {
    private queue: Queue;
    private deadLetterQueue: Queue;
    private worker: Worker;
    
    constructor(name: string, processor: (job: Job) => Promise<any>) {
        this.queue = new Queue(name, {
            connection,
            defaultJobOptions: {
                attempts: 3,
                backoff: { type: 'exponential', delay: 1000 },
                removeOnComplete: 100,
                removeOnFail: 1000
            }
        });
        
        this.deadLetterQueue = new Queue(\`\${name}:dlq\`, { connection });
        
        this.worker = new Worker(name, async (job) => {
            try {
                return await processor(job);
            } catch (error) {
                if (job.attemptsMade >= job.opts.attempts!) {
                    // Move to dead letter queue
                    await this.deadLetterQueue.add(job.name, job.data, {
                        jobId: job.id,
                        delay: 0
                    });
                }
                throw error;
            }
        }, { connection, concurrency: 5 });
    }
    
    async add(name: string, data: any, priority: 'critical' | 'high' | 'normal' | 'low' = 'normal') {
        const priorityMap = { critical: 1, high: 2, normal: 3, low: 4 };
        
        return this.queue.add(name, data, {
            priority: priorityMap[priority]
        });
    }
    
    async addBulk(jobs: Array<{ name: string; data: any; priority?: 'critical' | 'high' | 'normal' | 'low' }>) {
        const priorityMap = { critical: 1, high: 2, normal: 3, low: 4 };
        
        return this.queue.addBulk(jobs.map(j => ({
            name: j.name,
            data: j.data,
            opts: { priority: priorityMap[j.priority || 'normal'] }
        })));
    }
    
    async getStats() {
        const [waiting, active, completed, failed, delayed] = await Promise.all([
            this.queue.getWaitingCount(),
            this.queue.getActiveCount(),
            this.queue.getCompletedCount(),
            this.queue.getFailedCount(),
            this.queue.getDelayedCount()
        ]);
        
        return { waiting, active, completed, failed, delayed };
    }
    
    async retryFailed() {
        const failed = await this.queue.getFailed();
        
        for (const job of failed) {
            await job.retry();
        }
        
        return failed.length;
    }
    
    async processDeadLetter() {
        const jobs = await this.deadLetterQueue.getJobs(['waiting']);
        // Manual review or reprocessing logic
        return jobs;
    }
}

// Task Scheduler
class TaskScheduler {
    constructor(private queue: Queue) {}
    
    async scheduleRecurring(name: string, data: any, cron: string) {
        return this.queue.add(name, data, {
            repeat: { pattern: cron }
        });
    }
    
    async scheduleOnce(name: string, data: any, runAt: Date) {
        const delay = runAt.getTime() - Date.now();
        
        return this.queue.add(name, data, {
            delay: Math.max(0, delay)
        });
    }
    
    async cancelRecurring(name: string) {
        const repeatableJobs = await this.queue.getRepeatableJobs();
        const job = repeatableJobs.find(j => j.name === name);
        
        if (job) {
            await this.queue.removeRepeatableByKey(job.key);
        }
    }
}

export { PriorityTaskQueue, TaskScheduler };
`;
    }
}

export const taskQueueGenerator = TaskQueueGenerator.getInstance();
