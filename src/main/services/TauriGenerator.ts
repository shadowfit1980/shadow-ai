/**
 * ðŸ¦€ Tauri Generator
 * 
 * Generate Tauri desktop apps:
 * - Rust backend, commands
 */

import { EventEmitter } from 'events';

export class TauriGenerator extends EventEmitter {
    private static instance: TauriGenerator;

    private constructor() { super(); }

    static getInstance(): TauriGenerator {
        if (!TauriGenerator.instance) {
            TauriGenerator.instance = new TauriGenerator();
        }
        return TauriGenerator.instance;
    }

    generateRustMain(): string {
        return `// Tauri Main (Rust)
// Generated by Shadow AI

// src-tauri/src/main.rs
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use tauri::{Manager, State};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

// App State
struct AppState {
    counter: Mutex<i32>,
    user: Mutex<Option<User>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    id: String,
    name: String,
    email: String,
}

// Commands
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! Welcome to Tauri.", name)
}

#[tauri::command]
fn increment(state: State<AppState>) -> i32 {
    let mut counter = state.counter.lock().unwrap();
    *counter += 1;
    *counter
}

#[tauri::command]
fn get_counter(state: State<AppState>) -> i32 {
    *state.counter.lock().unwrap()
}

#[tauri::command]
async fn get_user(state: State<'_, AppState>) -> Result<Option<User>, String> {
    Ok(state.user.lock().unwrap().clone())
}

#[tauri::command]
async fn set_user(user: User, state: State<'_, AppState>) -> Result<(), String> {
    let mut u = state.user.lock().unwrap();
    *u = Some(user);
    Ok(())
}

#[tauri::command]
async fn read_file(path: String) -> Result<String, String> {
    std::fs::read_to_string(&path).map_err(|e| e.to_string())
}

#[tauri::command]
async fn write_file(path: String, content: String) -> Result<(), String> {
    std::fs::write(&path, &content).map_err(|e| e.to_string())
}

#[tauri::command]
async fn http_get(url: String) -> Result<String, String> {
    reqwest::get(&url)
        .await
        .map_err(|e| e.to_string())?
        .text()
        .await
        .map_err(|e| e.to_string())
}

fn main() {
    tauri::Builder::default()
        .manage(AppState {
            counter: Mutex::new(0),
            user: Mutex::new(None),
        })
        .invoke_handler(tauri::generate_handler![
            greet,
            increment,
            get_counter,
            get_user,
            set_user,
            read_file,
            write_file,
            http_get
        ])
        .setup(|app| {
            // Setup window events
            let window = app.get_window("main").unwrap();
            
            window.on_window_event(|event| match event {
                tauri::WindowEvent::CloseRequested { api, .. } => {
                    // Prevent close, hide instead
                    // api.prevent_close();
                    // window.hide().unwrap();
                }
                _ => {}
            });
            
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

// tauri.conf.json
const tauriConfig = {
    "build": {
        "beforeDevCommand": "npm run dev",
        "beforeBuildCommand": "npm run build",
        "devPath": "http://localhost:5173",
        "distDir": "../dist"
    },
    "package": {
        "productName": "My App",
        "version": "1.0.0"
    },
    "tauri": {
        "allowlist": {
            "all": false,
            "shell": { "all": false, "open": true },
            "dialog": { "all": true },
            "fs": { "all": true, "scope": ["$APPDATA/*", "$DOCUMENT/*"] },
            "path": { "all": true },
            "window": { "all": true }
        },
        "bundle": {
            "active": true,
            "targets": "all",
            "identifier": "com.myapp.app",
            "icon": ["icons/32x32.png", "icons/128x128.png", "icons/icon.icns", "icons/icon.ico"]
        },
        "security": {
            "csp": "default-src 'self'; img-src 'self' data: https:; script-src 'self'"
        },
        "windows": [{
            "fullscreen": false,
            "resizable": true,
            "title": "My App",
            "width": 1200,
            "height": 800,
            "minWidth": 800,
            "minHeight": 600
        }]
    }
};
`;
    }

    generateFrontend(): string {
        return `// Tauri Frontend (TypeScript/React)
// Generated by Shadow AI

import { invoke } from '@tauri-apps/api/tauri';
import { open, save } from '@tauri-apps/api/dialog';
import { readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/api/fs';
import { appDataDir, join } from '@tauri-apps/api/path';
import { listen, emit } from '@tauri-apps/api/event';
import { WebviewWindow, appWindow } from '@tauri-apps/api/window';

// Invoke Rust commands
async function greet(name: string): Promise<string> {
    return invoke('greet', { name });
}

async function increment(): Promise<number> {
    return invoke('increment');
}

async function getCounter(): Promise<number> {
    return invoke('get_counter');
}

interface User {
    id: string;
    name: string;
    email: string;
}

async function getUser(): Promise<User | null> {
    return invoke('get_user');
}

async function setUser(user: User): Promise<void> {
    return invoke('set_user', { user });
}

// File operations
async function openFile(): Promise<string | null> {
    const selected = await open({
        filters: [{ name: 'Text', extensions: ['txt', 'md', 'json'] }]
    });
    
    if (typeof selected === 'string') {
        const content = await invoke<string>('read_file', { path: selected });
        return content;
    }
    return null;
}

async function saveFile(content: string): Promise<void> {
    const filePath = await save({
        filters: [{ name: 'Text', extensions: ['txt', 'md'] }]
    });
    
    if (filePath) {
        await invoke('write_file', { path: filePath, content });
    }
}

// App data storage
async function saveToAppData(filename: string, data: any): Promise<void> {
    const appDataPath = await appDataDir();
    const filePath = await join(appDataPath, filename);
    await writeTextFile(filePath, JSON.stringify(data));
}

async function readFromAppData(filename: string): Promise<any> {
    const appDataPath = await appDataDir();
    const filePath = await join(appDataPath, filename);
    const content = await readTextFile(filePath);
    return JSON.parse(content);
}

// Window controls
function minimizeWindow() {
    appWindow.minimize();
}

function maximizeWindow() {
    appWindow.toggleMaximize();
}

function closeWindow() {
    appWindow.close();
}

// Events
async function setupEvents() {
    // Listen for events from Rust
    const unlisten = await listen<string>('event-name', (event) => {
        console.log('Received:', event.payload);
    });

    // Cleanup
    return unlisten;
}

// Emit event to Rust
function sendEvent(eventName: string, payload: any) {
    emit(eventName, payload);
}

// Create new window
async function createSettingsWindow() {
    const webview = new WebviewWindow('settings', {
        url: '/settings',
        title: 'Settings',
        width: 600,
        height: 400,
        resizable: true
    });

    webview.once('tauri://created', () => {
        console.log('Settings window created');
    });

    webview.once('tauri://error', (e) => {
        console.error('Failed to create window:', e);
    });
}

// React Hook
function useTauriCommand<T>(command: string, args?: any) {
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        setLoading(true);
        invoke<T>(command, args)
            .then(setData)
            .catch(setError)
            .finally(() => setLoading(false));
    }, [command, JSON.stringify(args)]);

    return { data, loading, error };
}

export {
    greet, increment, getCounter, getUser, setUser,
    openFile, saveFile, saveToAppData, readFromAppData,
    minimizeWindow, maximizeWindow, closeWindow,
    setupEvents, sendEvent, createSettingsWindow,
    useTauriCommand
};
`;
    }
}

export const tauriGenerator = TauriGenerator.getInstance();
