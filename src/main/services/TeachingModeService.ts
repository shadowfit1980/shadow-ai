/**
 * ðŸŽ“ TeachingModeService
 * 
 * Code explanation and mentoring:
 * - Line-by-line explanation, quizzes, skill adaptation
 */

import { EventEmitter } from 'events';

export class TeachingModeService extends EventEmitter {
    private static instance: TeachingModeService;
    private constructor() { super(); }
    static getInstance(): TeachingModeService {
        if (!TeachingModeService.instance) {
            TeachingModeService.instance = new TeachingModeService();
        }
        return TeachingModeService.instance;
    }

    generate(): string {
        return `// Teaching Mode Service - Code explanation and mentoring
// Generated by Shadow AI

class TeachingMode {
    private skillProfile: SkillProfile = { level: 'intermediate', strengths: [], weaknesses: [] };
    private learningHistory: LearningEntry[] = [];
    
    // Explain code line by line
    async explainCode(code: string, options: ExplainOptions = {}): Promise<Explanation> {
        const detail = options.detailLevel || this.skillProfile.level;
        
        const response = await llm.chat([{
            role: 'system',
            content: \`Explain this code to a \${detail} developer. Include:
            - What each section does
            - Why certain patterns are used
            - Common gotchas
            - How it could be improved
            
            Format as markdown with sections.\`
        }, {
            role: 'user',
            content: code
        }]);
        
        return {
            explanation: response.content,
            concepts: await this.extractConcepts(code),
            relatedTopics: await this.findRelatedTopics(code)
        };
    }
    
    // Generate quiz about code
    async generateQuiz(code: string, topic: string): Promise<Quiz> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Create a quiz about this code and \${topic}. Return JSON: {
                questions: [{ 
                    question, 
                    options: string[], 
                    correct: number, 
                    explanation 
                }]
            }\`
        }, {
            role: 'user',
            content: code
        }]);
        
        return JSON.parse(response.content);
    }
    
    // Evaluate quiz answer
    async evaluateAnswer(question: Question, answer: number): Promise<AnswerResult> {
        const isCorrect = answer === question.correct;
        
        if (!isCorrect) {
            // Track weakness
            await this.recordWeakness(question.topic);
        }
        
        return {
            correct: isCorrect,
            explanation: question.explanation,
            nextStep: isCorrect 
                ? 'Great! Ready for a harder question?' 
                : await this.generateHint(question)
        };
    }
    
    // Adapt to skill level
    async adaptToSkillLevel(interactions: Interaction[]): Promise<void> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Analyze these interactions and determine developer skill level.
            Return JSON: { level, strengths, weaknesses, recommended_topics }\`
        }, {
            role: 'user',
            content: JSON.stringify(interactions)
        }]);
        
        const assessment = JSON.parse(response.content);
        this.skillProfile = assessment;
    }
    
    // Learn from project
    async learnFromProject(projectPath: string): Promise<Course> {
        const files = await this.scanProject(projectPath);
        
        const response = await llm.chat([{
            role: 'system',
            content: \`Create an interactive course to teach this project's architecture and patterns.
            Return JSON: {
                title,
                modules: [{ name, concepts: string[], exercises: string[] }],
                estimatedHours
            }\`
        }, {
            role: 'user',
            content: JSON.stringify(files.slice(0, 20))
        }]);
        
        return JSON.parse(response.content);
    }
    
    // Mentor during coding
    async mentorDuringCoding(code: string, action: string): Promise<MentorTip | null> {
        // Check if there's something to teach
        const teachableMoment = await this.detectTeachableMoment(code, action);
        
        if (!teachableMoment) return null;
        
        const response = await llm.chat([{
            role: 'system',
            content: \`Provide a brief, encouraging teaching tip about this code pattern. 
            Keep it under 2 sentences. Be like a supportive senior developer.\`
        }, {
            role: 'user',
            content: \`Pattern detected: \${teachableMoment}\n\nCode: \${code}\`
        }]);
        
        return {
            tip: response.content,
            concept: teachableMoment,
            learnMore: await this.getLearnMoreLink(teachableMoment)
        };
    }
    
    // Track learning progress
    async trackProgress(): Promise<ProgressReport> {
        return {
            currentLevel: this.skillProfile.level,
            strengths: this.skillProfile.strengths,
            improvementAreas: this.skillProfile.weaknesses,
            conceptsMastered: this.learningHistory.filter(e => e.mastered).length,
            suggestedNext: await this.suggestNextLearning()
        };
    }
    
    // Generate certification path
    async generateCertificationPath(skill: string): Promise<CertificationPath> {
        const response = await llm.chat([{
            role: 'system',
            content: \`Create a certification path for "\${skill}". Include:
            - Prerequisites
            - Core modules
            - Projects to complete
            - Assessment criteria
            
            Return JSON format.\`
        }, {
            role: 'user',
            content: \`Current skill profile: \${JSON.stringify(this.skillProfile)}\`
        }]);
        
        return JSON.parse(response.content);
    }
    
    private async detectTeachableMoment(code: string, action: string): Promise<string | null> {
        const patterns = [
            { pattern: /useEffect.*\\[\\]/, concept: 'useEffect empty deps' },
            { pattern: /async.*await/, concept: 'async/await' },
            { pattern: /map.*filter/, concept: 'array chaining' },
            { pattern: /try.*catch/, concept: 'error handling' }
        ];
        
        for (const { pattern, concept } of patterns) {
            if (pattern.test(code) && !this.alreadyTaught(concept)) {
                return concept;
            }
        }
        
        return null;
    }
}

export { TeachingMode };
`;
    }
}

export const teachingModeService = TeachingModeService.getInstance();
