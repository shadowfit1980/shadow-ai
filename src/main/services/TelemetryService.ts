/**
 * ðŸ“Š TelemetryService
 * 
 * Agent telemetry:
 * - Metrics, tracing, performance
 */

import { EventEmitter } from 'events';

export class TelemetryService extends EventEmitter {
    private static instance: TelemetryService;
    private constructor() { super(); }
    static getInstance(): TelemetryService {
        if (!TelemetryService.instance) {
            TelemetryService.instance = new TelemetryService();
        }
        return TelemetryService.instance;
    }

    generate(): string {
        return `// Telemetry Service - Metrics, tracing
// Generated by Shadow AI

class Telemetry {
    private metrics: Map<string, number[]> = new Map();
    private traces: Trace[] = [];
    
    // Track metric
    trackMetric(name: string, value: number, tags?: Record<string, string>): void {
        if (!this.metrics.has(name)) {
            this.metrics.set(name, []);
        }
        this.metrics.get(name)!.push(value);
    }
    
    // Start span for tracing
    startSpan(name: string): Span {
        const span: Span = {
            id: crypto.randomUUID(),
            name,
            startTime: Date.now(),
            events: [],
            attributes: {}
        };
        
        return span;
    }
    
    // End span
    endSpan(span: Span): void {
        span.endTime = Date.now();
        span.duration = span.endTime - span.startTime;
        
        this.traces.push({
            spanId: span.id,
            name: span.name,
            duration: span.duration,
            events: span.events,
            attributes: span.attributes,
            timestamp: span.startTime
        });
    }
    
    // Track LLM call
    async trackLLMCall<T>(model: string, fn: () => Promise<T>): Promise<T> {
        const span = this.startSpan(\`llm:\${model}\`);
        const startTokens = process.memoryUsage().heapUsed;
        
        try {
            const result = await fn();
            span.attributes['success'] = 'true';
            return result;
        } catch (error) {
            span.attributes['success'] = 'false';
            span.attributes['error'] = error.message;
            throw error;
        } finally {
            this.endSpan(span);
            this.trackMetric('llm_latency_ms', span.duration!, { model });
        }
    }
    
    // Get metrics summary
    getMetricsSummary(): Record<string, MetricSummary> {
        const summary: Record<string, MetricSummary> = {};
        
        for (const [name, values] of this.metrics) {
            const sorted = [...values].sort((a, b) => a - b);
            
            summary[name] = {
                count: values.length,
                min: Math.min(...values),
                max: Math.max(...values),
                avg: values.reduce((a, b) => a + b, 0) / values.length,
                p50: sorted[Math.floor(sorted.length * 0.5)],
                p95: sorted[Math.floor(sorted.length * 0.95)],
                p99: sorted[Math.floor(sorted.length * 0.99)]
            };
        }
        
        return summary;
    }
    
    // Get recent traces
    getTraces(limit = 100): Trace[] {
        return this.traces.slice(-limit);
    }
    
    // Track agent action
    trackAction(action: string, metadata: Record<string, any>): void {
        this.traces.push({
            spanId: crypto.randomUUID(),
            name: \`action:\${action}\`,
            duration: 0,
            events: [],
            attributes: metadata,
            timestamp: Date.now()
        });
    }
    
    // Export to OpenTelemetry format
    exportOTLP(): any {
        return {
            resourceSpans: [{
                resource: {
                    attributes: [
                        { key: 'service.name', value: { stringValue: 'shadow-ai' } }
                    ]
                },
                scopeSpans: [{
                    spans: this.traces.map(t => ({
                        traceId: t.spanId,
                        spanId: t.spanId,
                        name: t.name,
                        startTimeUnixNano: t.timestamp * 1000000,
                        endTimeUnixNano: (t.timestamp + (t.duration || 0)) * 1000000,
                        attributes: Object.entries(t.attributes).map(([k, v]) => ({
                            key: k,
                            value: { stringValue: String(v) }
                        }))
                    }))
                }]
            }]
        };
    }
    
    // Clear telemetry data
    clear(): void {
        this.metrics.clear();
        this.traces = [];
    }
}

export { Telemetry };
`;
    }
}

export const telemetryService = TelemetryService.getInstance();
