/**
 * ‚è∞ TemporalMemoryService
 * 
 * Time-aware memory:
 * - Remember across sessions, decay old memories
 */

import { EventEmitter } from 'events';

export class TemporalMemoryService extends EventEmitter {
    private static instance: TemporalMemoryService;
    private constructor() { super(); }
    static getInstance(): TemporalMemoryService {
        if (!TemporalMemoryService.instance) {
            TemporalMemoryService.instance = new TemporalMemoryService();
        }
        return TemporalMemoryService.instance;
    }

    generate(): string {
        return `// Temporal Memory Service - Time-aware memory
// Generated by Shadow AI

interface Memory {
    id: string;
    content: string;
    type: 'fact' | 'preference' | 'pattern' | 'decision' | 'error' | 'success';
    importance: number; // 0-100
    createdAt: number;
    lastAccessedAt: number;
    accessCount: number;
    decayRate: number;
    associations: string[];
    metadata: Record<string, any>;
}

class TemporalMemory {
    private memories: Map<string, Memory> = new Map();
    private decayInterval: NodeJS.Timeout | null = null;
    
    constructor() {
        // Start decay timer
        this.startDecayTimer();
    }
    
    // Store memory
    store(content: string, type: Memory['type'], importance = 50, metadata = {}): string {
        const id = crypto.randomUUID();
        
        const memory: Memory = {
            id,
            content,
            type,
            importance,
            createdAt: Date.now(),
            lastAccessedAt: Date.now(),
            accessCount: 1,
            decayRate: this.calculateDecayRate(importance),
            associations: [],
            metadata
        };
        
        this.memories.set(id, memory);
        
        // Find and store associations
        this.findAssociations(memory);
        
        return id;
    }
    
    // Recall with decay consideration
    recall(query: string, limit = 10): Memory[] {
        const now = Date.now();
        const results: Array<{ memory: Memory; score: number }> = [];
        
        for (const memory of this.memories.values()) {
            // Calculate current effective importance
            const age = now - memory.lastAccessedAt;
            const decayFactor = Math.exp(-memory.decayRate * age / (24 * 60 * 60 * 1000)); // decay per day
            const effectiveImportance = memory.importance * decayFactor;
            
            // Skip if too decayed
            if (effectiveImportance < 5) continue;
            
            // Score based on relevance and importance
            const relevance = this.calculateRelevance(query, memory);
            const score = relevance * 0.6 + effectiveImportance * 0.4;
            
            if (score > 10) {
                results.push({ memory, score });
            }
        }
        
        // Sort by score and return
        return results
            .sort((a, b) => b.score - a.score)
            .slice(0, limit)
            .map(r => {
                // Update access stats
                r.memory.lastAccessedAt = now;
                r.memory.accessCount++;
                return r.memory;
            });
    }
    
    // Strengthen memory (prevent decay)
    reinforce(memoryId: string): void {
        const memory = this.memories.get(memoryId);
        if (memory) {
            memory.importance = Math.min(100, memory.importance + 10);
            memory.lastAccessedAt = Date.now();
            memory.decayRate *= 0.9; // Slow decay rate
        }
    }
    
    // Forget explicitly
    forget(memoryId: string): void {
        this.memories.delete(memoryId);
    }
    
    // Get memories by time period
    getByTimePeriod(start: number, end: number): Memory[] {
        return Array.from(this.memories.values())
            .filter(m => m.createdAt >= start && m.createdAt <= end);
    }
    
    // Get memories by type
    getByType(type: Memory['type']): Memory[] {
        return Array.from(this.memories.values())
            .filter(m => m.type === type);
    }
    
    // Associate memories
    associate(memoryId1: string, memoryId2: string): void {
        const m1 = this.memories.get(memoryId1);
        const m2 = this.memories.get(memoryId2);
        
        if (m1 && m2) {
            if (!m1.associations.includes(memoryId2)) {
                m1.associations.push(memoryId2);
            }
            if (!m2.associations.includes(memoryId1)) {
                m2.associations.push(memoryId1);
            }
        }
    }
    
    // Get associated memories
    getAssociated(memoryId: string): Memory[] {
        const memory = this.memories.get(memoryId);
        if (!memory) return [];
        
        return memory.associations
            .map(id => this.memories.get(id))
            .filter(Boolean) as Memory[];
    }
    
    // Consolidate memories (compress similar ones)
    async consolidate(): Promise<number> {
        const groups = this.groupSimilarMemories();
        let consolidated = 0;
        
        for (const group of groups) {
            if (group.length >= 3) {
                // Consolidate into one summary memory
                const summary = await this.summarizeMemories(group);
                
                this.store(summary, 'pattern', 
                    Math.max(...group.map(m => m.importance)),
                    { consolidatedFrom: group.map(m => m.id) }
                );
                
                // Remove original memories
                for (const memory of group) {
                    this.memories.delete(memory.id);
                }
                
                consolidated += group.length;
            }
        }
        
        return consolidated;
    }
    
    private startDecayTimer(): void {
        // Run decay check every hour
        this.decayInterval = setInterval(() => {
            this.applyDecay();
        }, 60 * 60 * 1000);
    }
    
    private applyDecay(): void {
        const now = Date.now();
        
        for (const [id, memory] of this.memories.entries()) {
            const age = now - memory.lastAccessedAt;
            const decayFactor = Math.exp(-memory.decayRate * age / (24 * 60 * 60 * 1000));
            
            // Delete if too decayed
            if (memory.importance * decayFactor < 1) {
                this.memories.delete(id);
            }
        }
    }
    
    private calculateDecayRate(importance: number): number {
        // Higher importance = slower decay
        return 0.1 / (importance / 50);
    }
    
    private calculateRelevance(query: string, memory: Memory): number {
        const queryWords = query.toLowerCase().split(/\\s+/);
        const memoryWords = memory.content.toLowerCase().split(/\\s+/);
        
        let matches = 0;
        for (const word of queryWords) {
            if (memoryWords.includes(word)) matches++;
        }
        
        return (matches / queryWords.length) * 100;
    }
    
    private findAssociations(memory: Memory): void {
        // Find related memories automatically
        const related = this.recall(memory.content, 5);
        
        for (const m of related) {
            if (m.id !== memory.id) {
                this.associate(memory.id, m.id);
            }
        }
    }
    
    private groupSimilarMemories(): Memory[][] {
        // Would use embeddings for similarity
        return [];
    }
    
    private async summarizeMemories(memories: Memory[]): Promise<string> {
        const response = await llm.chat([{
            role: 'system',
            content: 'Summarize these memories into one consolidated memory.'
        }, {
            role: 'user',
            content: memories.map(m => m.content).join('\\n')
        }]);
        
        return response.content;
    }
}

export { TemporalMemory };
`;
    }
}

export const temporalMemoryService = TemporalMemoryService.getInstance();
