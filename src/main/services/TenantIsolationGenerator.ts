/**
 * ðŸ  TenantIsolationGenerator
 * 
 * Multi-tenant isolation:
 * - Row-level, schema, database
 */

import { EventEmitter } from 'events';

export class TenantIsolationGenerator extends EventEmitter {
    private static instance: TenantIsolationGenerator;
    private constructor() { super(); }
    static getInstance(): TenantIsolationGenerator {
        if (!TenantIsolationGenerator.instance) {
            TenantIsolationGenerator.instance = new TenantIsolationGenerator();
        }
        return TenantIsolationGenerator.instance;
    }

    generate(): string {
        return `// Tenant Isolation Generator - Row-level, schema, database
// Generated by Shadow AI

// Tenant Context
class TenantContext {
    private static current: string | null = null;
    
    static set(tenantId: string) {
        this.current = tenantId;
    }
    
    static get(): string {
        if (!this.current) throw new Error('No tenant context');
        return this.current;
    }
    
    static clear() {
        this.current = null;
    }
}

// Tenant Middleware
function tenantMiddleware(req: any, res: any, next: Function) {
    const tenantId = req.headers['x-tenant-id'] || req.user?.tenantId;
    
    if (!tenantId) {
        return res.status(400).json({ error: 'Tenant ID required' });
    }
    
    TenantContext.set(tenantId);
    req.tenantId = tenantId;
    
    res.on('finish', () => TenantContext.clear());
    
    next();
}

// Row-Level Isolation with Prisma
const prismaWithTenant = prisma.$extends({
    query: {
        $allModels: {
            async $allOperations({ model, operation, args, query }) {
                const tenantId = TenantContext.get();
                
                // Skip for tenant-agnostic models
                const tenantAgnostic = ['Tenant', 'User'];
                if (tenantAgnostic.includes(model)) return query(args);
                
                // Inject tenant filter for reads
                if (['findMany', 'findFirst', 'findUnique', 'count', 'aggregate'].includes(operation)) {
                    args.where = { ...args.where, tenantId };
                }
                
                // Inject tenant for creates
                if (['create', 'createMany'].includes(operation)) {
                    if (Array.isArray(args.data)) {
                        args.data = args.data.map(d => ({ ...d, tenantId }));
                    } else {
                        args.data = { ...args.data, tenantId };
                    }
                }
                
                return query(args);
            }
        }
    }
});

// Schema-Level Isolation
class SchemaIsolation {
    async createTenantSchema(tenantId: string) {
        await prisma.$executeRaw\`CREATE SCHEMA IF NOT EXISTS "tenant_\${tenantId}"\`;
        await this.runMigrations(\`tenant_\${tenantId}\`);
    }
    
    async getTenantConnection(tenantId: string) {
        const schema = \`tenant_\${tenantId}\`;
        return new PrismaClient({
            datasources: {
                db: { url: \`\${process.env.DATABASE_URL}?schema=\${schema}\` }
            }
        });
    }
}

// Database-Level Isolation
class DatabaseIsolation {
    async createTenantDatabase(tenantId: string) {
        await prisma.$executeRaw\`CREATE DATABASE "tenant_\${tenantId}"\`;
    }
    
    async getTenantConnection(tenantId: string) {
        const url = process.env.DATABASE_URL!.replace('/main', \`/tenant_\${tenantId}\`);
        return new PrismaClient({
            datasources: { db: { url } }
        });
    }
}

export { TenantContext, tenantMiddleware, prismaWithTenant, SchemaIsolation, DatabaseIsolation };
`;
    }
}

export const tenantIsolationGenerator = TenantIsolationGenerator.getInstance();
