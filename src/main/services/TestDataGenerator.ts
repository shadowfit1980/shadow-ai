/**
 * ðŸ§ª TestDataGenerator
 * 
 * Test data generation:
 * - Faker, fixtures, snapshots
 */

import { EventEmitter } from 'events';

export class TestDataGenerator extends EventEmitter {
    private static instance: TestDataGenerator;
    private constructor() { super(); }
    static getInstance(): TestDataGenerator {
        if (!TestDataGenerator.instance) {
            TestDataGenerator.instance = new TestDataGenerator();
        }
        return TestDataGenerator.instance;
    }

    generate(): string {
        return `// Test Data Generator - Faker, fixtures, snapshots
// Generated by Shadow AI

import { faker } from '@faker-js/faker';

// Factory Functions
class DataFactory {
    static user(overrides: Partial<User> = {}): User {
        return {
            id: faker.string.uuid(),
            email: faker.internet.email(),
            name: faker.person.fullName(),
            avatar: faker.image.avatar(),
            role: faker.helpers.arrayElement(['admin', 'user', 'moderator']),
            createdAt: faker.date.past(),
            ...overrides
        };
    }
    
    static post(overrides: Partial<Post> = {}): Post {
        return {
            id: faker.string.uuid(),
            title: faker.lorem.sentence(),
            content: faker.lorem.paragraphs(3),
            authorId: faker.string.uuid(),
            status: faker.helpers.arrayElement(['draft', 'published']),
            tags: faker.helpers.arrayElements(['tech', 'news', 'tutorial', 'review'], { min: 1, max: 3 }),
            createdAt: faker.date.past(),
            ...overrides
        };
    }
    
    static product(overrides: Partial<Product> = {}): Product {
        return {
            id: faker.string.uuid(),
            name: faker.commerce.productName(),
            description: faker.commerce.productDescription(),
            price: parseFloat(faker.commerce.price()),
            category: faker.commerce.department(),
            image: faker.image.urlLoremFlickr({ category: 'product' }),
            stock: faker.number.int({ min: 0, max: 100 }),
            ...overrides
        };
    }
    
    static order(overrides: Partial<Order> = {}): Order {
        const items = Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () => ({
            productId: faker.string.uuid(),
            quantity: faker.number.int({ min: 1, max: 5 }),
            price: parseFloat(faker.commerce.price())
        }));
        
        return {
            id: faker.string.uuid(),
            userId: faker.string.uuid(),
            items,
            total: items.reduce((sum, i) => sum + i.price * i.quantity, 0),
            status: faker.helpers.arrayElement(['pending', 'processing', 'shipped', 'delivered']),
            createdAt: faker.date.past(),
            ...overrides
        };
    }
}

// Fixture Manager
class FixtureManager {
    private fixtures: Map<string, any[]> = new Map();
    
    define<T>(name: string, factory: () => T, count = 10) {
        this.fixtures.set(name, Array.from({ length: count }, factory));
    }
    
    get<T>(name: string): T[] {
        return this.fixtures.get(name) || [];
    }
    
    seed(prisma: any) {
        return async () => {
            for (const [name, data] of this.fixtures) {
                await prisma[name].createMany({ data });
            }
        };
    }
}

// Snapshot Testing Helper
class SnapshotManager {
    async captureSnapshot(data: any, name: string) {
        const fs = await import('fs/promises');
        const path = \`__snapshots__/\${name}.json\`;
        await fs.writeFile(path, JSON.stringify(data, null, 2));
    }
    
    async compareSnapshot(data: any, name: string): Promise<{ match: boolean; diff?: any }> {
        const fs = await import('fs/promises');
        const path = \`__snapshots__/\${name}.json\`;
        
        try {
            const existing = JSON.parse(await fs.readFile(path, 'utf-8'));
            const match = JSON.stringify(data) === JSON.stringify(existing);
            return { match, diff: match ? undefined : this.diff(existing, data) };
        } catch {
            await this.captureSnapshot(data, name);
            return { match: true };
        }
    }
}

export { DataFactory, FixtureManager, SnapshotManager };
`;
    }
}

export const testDataGenerator = TestDataGenerator.getInstance();
