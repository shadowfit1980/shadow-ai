/**
 * ðŸ“Š TokenUsageGenerator
 * 
 * Token tracking:
 * - Usage, costs, quotas
 */

import { EventEmitter } from 'events';

export class TokenUsageGenerator extends EventEmitter {
    private static instance: TokenUsageGenerator;
    private constructor() { super(); }
    static getInstance(): TokenUsageGenerator {
        if (!TokenUsageGenerator.instance) {
            TokenUsageGenerator.instance = new TokenUsageGenerator();
        }
        return TokenUsageGenerator.instance;
    }

    generate(): string {
        return `// Token Usage Generator - Usage, costs, quotas
// Generated by Shadow AI

class TokenUsageService {
    async track(userId: string, usage: TokenUsage) {
        await prisma.tokenUsage.create({
            data: {
                userId,
                model: usage.model,
                inputTokens: usage.inputTokens,
                outputTokens: usage.outputTokens,
                cost: this.calculateCost(usage)
            }
        });
        
        // Update quotas
        await this.updateQuota(userId, usage.inputTokens + usage.outputTokens);
    }
    
    private calculateCost(usage: TokenUsage): number {
        const pricing: Record<string, { input: number; output: number }> = {
            'gpt-4-turbo': { input: 0.01 / 1000, output: 0.03 / 1000 },
            'gpt-3.5-turbo': { input: 0.0005 / 1000, output: 0.0015 / 1000 },
            'claude-3-opus': { input: 0.015 / 1000, output: 0.075 / 1000 },
            'claude-3-sonnet': { input: 0.003 / 1000, output: 0.015 / 1000 }
        };
        
        const price = pricing[usage.model] || { input: 0.001, output: 0.002 };
        return (usage.inputTokens * price.input) + (usage.outputTokens * price.output);
    }
    
    async getUsage(userId: string, period: 'day' | 'week' | 'month') {
        const startDate = this.getStartDate(period);
        
        const usage = await prisma.tokenUsage.aggregate({
            where: { userId, createdAt: { gte: startDate } },
            _sum: { inputTokens: true, outputTokens: true, cost: true }
        });
        
        return {
            inputTokens: usage._sum.inputTokens || 0,
            outputTokens: usage._sum.outputTokens || 0,
            totalCost: usage._sum.cost || 0
        };
    }
    
    async checkQuota(userId: string): Promise<{ allowed: boolean; remaining: number }> {
        const quota = await prisma.quota.findUnique({ where: { userId } });
        const usage = await this.getUsage(userId, 'month');
        
        const limit = quota?.monthlyLimit || 100000;
        const used = usage.inputTokens + usage.outputTokens;
        
        return {
            allowed: used < limit,
            remaining: Math.max(0, limit - used)
        };
    }
}

export { TokenUsageService };
`;
    }
}

export const tokenUsageGenerator = TokenUsageGenerator.getInstance();
