/**
 * ðŸ”§ ToolExecutorService
 * 
 * Agent tool execution:
 * - Registry, invocation, sandboxing
 */

import { EventEmitter } from 'events';

export class ToolExecutorService extends EventEmitter {
    private static instance: ToolExecutorService;
    private constructor() { super(); }
    static getInstance(): ToolExecutorService {
        if (!ToolExecutorService.instance) {
            ToolExecutorService.instance = new ToolExecutorService();
        }
        return ToolExecutorService.instance;
    }

    generate(): string {
        return `// Tool Executor Service - Registry, invocation, sandboxing
// Generated by Shadow AI

interface Tool {
    name: string;
    description: string;
    parameters: {
        type: 'object';
        properties: Record<string, { type: string; description: string }>;
        required?: string[];
    };
    execute: (params: any) => Promise<any>;
    dangerous?: boolean;
    requiresApproval?: boolean;
}

class ToolExecutor {
    private tools: Map<string, Tool> = new Map();
    private executionHistory: Array<{ tool: string; params: any; result: any; timestamp: number }> = [];
    
    register(tool: Tool) {
        this.tools.set(tool.name, tool);
    }
    
    getToolDefinitions(): any[] {
        return Array.from(this.tools.values()).map(t => ({
            type: 'function',
            function: {
                name: t.name,
                description: t.description,
                parameters: t.parameters
            }
        }));
    }
    
    async execute(toolName: string, params: any, options?: { requireApproval?: boolean }): Promise<any> {
        const tool = this.tools.get(toolName);
        if (!tool) throw new Error(\`Tool not found: \${toolName}\`);
        
        // Check if approval required
        if (tool.dangerous || tool.requiresApproval || options?.requireApproval) {
            const approved = await this.requestApproval(toolName, params);
            if (!approved) throw new Error('Execution not approved by user');
        }
        
        const startTime = Date.now();
        
        try {
            const result = await tool.execute(params);
            
            this.executionHistory.push({
                tool: toolName,
                params,
                result,
                timestamp: startTime
            });
            
            return result;
        } catch (error) {
            this.executionHistory.push({
                tool: toolName,
                params,
                result: { error: error.message },
                timestamp: startTime
            });
            throw error;
        }
    }
    
    private async requestApproval(toolName: string, params: any): Promise<boolean> {
        // Emit event for UI to show approval dialog
        return new Promise((resolve) => {
            this.emit('approval-required', { toolName, params, resolve });
        });
    }
    
    getHistory(limit = 50) {
        return this.executionHistory.slice(-limit);
    }
    
    listTools(): string[] {
        return Array.from(this.tools.keys());
    }
}

// Built-in Agent Tools
const builtInTools: Tool[] = [
    {
        name: 'read_file',
        description: 'Read contents of a file',
        parameters: {
            type: 'object',
            properties: { path: { type: 'string', description: 'File path' } },
            required: ['path']
        },
        execute: async ({ path }) => fs.readFile(path, 'utf-8')
    },
    {
        name: 'write_file',
        description: 'Write content to a file',
        parameters: {
            type: 'object',
            properties: {
                path: { type: 'string', description: 'File path' },
                content: { type: 'string', description: 'File content' }
            },
            required: ['path', 'content']
        },
        execute: async ({ path, content }) => fs.writeFile(path, content),
        dangerous: true
    },
    {
        name: 'run_command',
        description: 'Execute a shell command',
        parameters: {
            type: 'object',
            properties: {
                command: { type: 'string', description: 'Command to run' },
                cwd: { type: 'string', description: 'Working directory' }
            },
            required: ['command']
        },
        execute: async ({ command, cwd }) => execAsync(command, { cwd }),
        dangerous: true,
        requiresApproval: true
    },
    {
        name: 'search_codebase',
        description: 'Search for patterns in codebase',
        parameters: {
            type: 'object',
            properties: {
                query: { type: 'string', description: 'Search query' },
                path: { type: 'string', description: 'Directory to search' }
            },
            required: ['query']
        },
        execute: async ({ query, path }) => grepSearch(query, path)
    }
];

export { ToolExecutor, builtInTools, Tool };
`;
    }
}

export const toolExecutorService = ToolExecutorService.getInstance();
