/**
 * üîê TwoFactorAuthGenerator
 * 
 * 2FA Authentication:
 * - TOTP, SMS, backup codes
 */

import { EventEmitter } from 'events';

export class TwoFactorAuthGenerator extends EventEmitter {
    private static instance: TwoFactorAuthGenerator;
    private constructor() { super(); }
    static getInstance(): TwoFactorAuthGenerator {
        if (!TwoFactorAuthGenerator.instance) {
            TwoFactorAuthGenerator.instance = new TwoFactorAuthGenerator();
        }
        return TwoFactorAuthGenerator.instance;
    }

    generate(): string {
        return `// Two Factor Auth Generator - TOTP, SMS, backup codes
// Generated by Shadow AI

import { authenticator } from 'otplib';
import QRCode from 'qrcode';

class TwoFactorAuthService {
    async setup(userId: string, email: string) {
        const secret = authenticator.generateSecret();
        const otpauth = authenticator.keyuri(email, 'MyApp', secret);
        const qrCode = await QRCode.toDataURL(otpauth);
        
        await prisma.twoFactorSecret.create({
            data: { userId, secret, verified: false }
        });
        
        return { secret, qrCode };
    }
    
    async verify(userId: string, token: string): Promise<boolean> {
        const record = await prisma.twoFactorSecret.findUnique({ where: { userId } });
        if (!record) return false;
        
        const isValid = authenticator.verify({ token, secret: record.secret });
        
        if (isValid && !record.verified) {
            await prisma.twoFactorSecret.update({
                where: { userId },
                data: { verified: true }
            });
            
            await this.generateBackupCodes(userId);
        }
        
        return isValid;
    }
    
    async generateBackupCodes(userId: string): Promise<string[]> {
        const codes = Array.from({ length: 10 }, () => 
            Math.random().toString(36).substring(2, 10).toUpperCase()
        );
        
        const hashedCodes = await Promise.all(
            codes.map(code => bcrypt.hash(code, 10))
        );
        
        await prisma.backupCode.createMany({
            data: hashedCodes.map(hash => ({ userId, codeHash: hash }))
        });
        
        return codes;
    }
    
    async verifyBackupCode(userId: string, code: string): Promise<boolean> {
        const backupCodes = await prisma.backupCode.findMany({
            where: { userId, usedAt: null }
        });
        
        for (const bc of backupCodes) {
            if (await bcrypt.compare(code, bc.codeHash)) {
                await prisma.backupCode.update({
                    where: { id: bc.id },
                    data: { usedAt: new Date() }
                });
                return true;
            }
        }
        
        return false;
    }
    
    async disable(userId: string, token: string): Promise<boolean> {
        if (!await this.verify(userId, token)) return false;
        
        await prisma.twoFactorSecret.delete({ where: { userId } });
        await prisma.backupCode.deleteMany({ where: { userId } });
        
        return true;
    }
}

export { TwoFactorAuthService };
`;
    }
}

export const twoFactorAuthGenerator = TwoFactorAuthGenerator.getInstance();
