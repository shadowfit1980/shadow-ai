/**
 * ðŸ”§ TypeInferenceService
 * 
 * Type inference:
 * - TypeScript, auto-types, schema
 */

import { EventEmitter } from 'events';

export class TypeInferenceService extends EventEmitter {
    private static instance: TypeInferenceService;
    private constructor() { super(); }
    static getInstance(): TypeInferenceService {
        if (!TypeInferenceService.instance) {
            TypeInferenceService.instance = new TypeInferenceService();
        }
        return TypeInferenceService.instance;
    }

    generate(): string {
        return `// Type Inference Service - TypeScript, auto-types
// Generated by Shadow AI

class TypeInference {
    // Infer TypeScript types from JSON
    inferFromJSON(json: any, name = 'Generated'): string {
        if (json === null) return 'null';
        if (json === undefined) return 'undefined';
        
        if (Array.isArray(json)) {
            if (json.length === 0) return 'any[]';
            const itemType = this.inferFromJSON(json[0], \`\${name}Item\`);
            return \`\${itemType}[]\`;
        }
        
        if (typeof json === 'object') {
            const properties = Object.entries(json).map(([key, value]) => {
                const propType = this.inferFromJSON(value, this.capitalize(key));
                return \`  \${key}: \${propType};\`;
            });
            
            return \`{\\n\${properties.join('\\n')}\\n}\`;
        }
        
        return typeof json;
    }
    
    // Generate TypeScript interface
    generateInterface(json: any, name: string): string {
        const body = this.inferFromJSON(json, name);
        return \`interface \${name} \${body}\`;
    }
    
    // Generate types from API response
    async generateFromAPI(url: string, method = 'GET'): Promise<string> {
        const response = await fetch(url, { method });
        const data = await response.json();
        
        const typeName = this.urlToTypeName(url);
        return this.generateInterface(data, typeName);
    }
    
    // Infer function parameter types
    inferFunctionTypes(code: string): FunctionTypeInfo {
        const response = await llm.chat([{
            role: 'system',
            content: \`Analyze this function and infer TypeScript types. Return JSON:
            { name, params: [{ name, type, optional }], returnType, generics? }\`
        }, {
            role: 'user',
            content: code
        }]);
        
        return JSON.parse(response.content);
    }
    
    // Convert Zod schema to TypeScript
    zodToTS(schema: string): string {
        const response = await llm.chat([{
            role: 'system',
            content: 'Convert this Zod schema to TypeScript interface. Return only the TypeScript code.'
        }, {
            role: 'user',
            content: schema
        }]);
        
        return response.content;
    }
    
    // Generate Zod schema from TypeScript
    tsToZod(typescript: string): string {
        const response = await llm.chat([{
            role: 'system',
            content: 'Convert this TypeScript interface to a Zod schema. Return only the Zod code.'
        }, {
            role: 'user',
            content: typescript
        }]);
        
        return response.content;
    }
    
    private capitalize(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    
    private urlToTypeName(url: string): string {
        const path = new URL(url).pathname;
        const parts = path.split('/').filter(Boolean);
        return parts.map(p => this.capitalize(p)).join('') + 'Response';
    }
}

export { TypeInference };
`;
    }
}

export const typeInferenceService = TypeInferenceService.getInstance();
