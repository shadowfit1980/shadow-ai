/**
 * ðŸ“‹ Validation Generator
 * 
 * Generate validation schemas:
 * - Zod, Yup, Joi
 */

import { EventEmitter } from 'events';

export type ValidationLib = 'zod' | 'yup' | 'joi';

export class ValidationGenerator extends EventEmitter {
    private static instance: ValidationGenerator;

    private constructor() { super(); }

    static getInstance(): ValidationGenerator {
        if (!ValidationGenerator.instance) {
            ValidationGenerator.instance = new ValidationGenerator();
        }
        return ValidationGenerator.instance;
    }

    getLibraries(): ValidationLib[] {
        return ['zod', 'yup', 'joi'];
    }

    generate(lib: ValidationLib): string {
        switch (lib) {
            case 'zod': return this.generateZod();
            case 'yup': return this.generateYup();
            case 'joi': return this.generateJoi();
            default: return '';
        }
    }

    private generateZod(): string {
        return `// Zod Validation
// Generated by Shadow AI

import { z } from 'zod';

// Basic types
const stringSchema = z.string();
const numberSchema = z.number();
const booleanSchema = z.boolean();
const dateSchema = z.date();

// Common validators
const emailSchema = z.string().email('Invalid email');
const urlSchema = z.string().url('Invalid URL');
const uuidSchema = z.string().uuid('Invalid UUID');

// Password with requirements
const passwordSchema = z.string()
    .min(8, 'Minimum 8 characters')
    .max(100)
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[a-z]/, 'Must contain lowercase letter')
    .regex(/[0-9]/, 'Must contain number')
    .regex(/[^A-Za-z0-9]/, 'Must contain special character');

// User schema
const userSchema = z.object({
    id: z.string().uuid().optional(),
    name: z.string().min(2).max(100),
    email: emailSchema,
    password: passwordSchema,
    age: z.number().int().min(0).max(150).optional(),
    role: z.enum(['user', 'admin', 'moderator']).default('user'),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().default(() => new Date()),
    updatedAt: z.date().optional()
});

type User = z.infer<typeof userSchema>;

// Create/Update schemas (partial)
const createUserSchema = userSchema.omit({ id: true, createdAt: true, updatedAt: true });
const updateUserSchema = createUserSchema.partial();

// Array schemas
const usersArraySchema = z.array(userSchema);

// Union and discriminated unions
const responseSchema = z.discriminatedUnion('status', [
    z.object({ status: z.literal('success'), data: z.unknown() }),
    z.object({ status: z.literal('error'), message: z.string(), code: z.number() })
]);

// API request validation
const paginationSchema = z.object({
    page: z.coerce.number().int().min(1).default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
    sortBy: z.string().optional(),
    order: z.enum(['asc', 'desc']).default('desc')
});

// Transform and refine
const sanitizedStringSchema = z.string()
    .transform(s => s.trim().toLowerCase())
    .refine(s => s.length > 0, 'Cannot be empty');

// Custom validation
const phoneSchema = z.string().refine(
    val => /^\\+?[1-9]\\d{1,14}$/.test(val),
    'Invalid phone number'
);

// Async validation
const uniqueEmailSchema = z.string().email().refine(
    async (email) => {
        const exists = await checkEmailExists(email);
        return !exists;
    },
    'Email already in use'
);

// Parse functions
function parseUser(data: unknown): User {
    return userSchema.parse(data);
}

function safeParseUser(data: unknown) {
    return userSchema.safeParse(data);
}

export { userSchema, createUserSchema, updateUserSchema, paginationSchema, parseUser, safeParseUser };
`;
    }

    private generateYup(): string {
        return `// Yup Validation
// Generated by Shadow AI

import * as yup from 'yup';

const userSchema = yup.object({
    id: yup.string().uuid(),
    name: yup.string().min(2).max(100).required(),
    email: yup.string().email().required(),
    password: yup.string()
        .min(8)
        .matches(/[A-Z]/, 'Must contain uppercase')
        .matches(/[0-9]/, 'Must contain number')
        .required(),
    confirmPassword: yup.string()
        .oneOf([yup.ref('password')], 'Passwords must match')
        .required(),
    age: yup.number().integer().min(0).max(150),
    role: yup.string().oneOf(['user', 'admin', 'moderator']).default('user'),
    isActive: yup.boolean().default(true),
    profile: yup.object({
        bio: yup.string().max(500),
        avatar: yup.string().url()
    }).optional()
});

type User = yup.InferType<typeof userSchema>;

async function validateUser(data: unknown) {
    try {
        const user = await userSchema.validate(data, { abortEarly: false });
        return { success: true, data: user };
    } catch (error) {
        if (error instanceof yup.ValidationError) {
            return { success: false, errors: error.errors };
        }
        throw error;
    }
}

export { userSchema, validateUser };
`;
    }

    private generateJoi(): string {
        return `// Joi Validation
// Generated by Shadow AI

import Joi from 'joi';

const userSchema = Joi.object({
    id: Joi.string().uuid(),
    name: Joi.string().min(2).max(100).required(),
    email: Joi.string().email().required(),
    password: Joi.string()
        .min(8)
        .pattern(/[A-Z]/, 'uppercase')
        .pattern(/[0-9]/, 'number')
        .required(),
    age: Joi.number().integer().min(0).max(150),
    role: Joi.string().valid('user', 'admin', 'moderator').default('user'),
    tags: Joi.array().items(Joi.string()).max(10)
});

// Express middleware
function validate(schema: Joi.Schema) {
    return (req, res, next) => {
        const { error, value } = schema.validate(req.body, { abortEarly: false });
        if (error) {
            return res.status(400).json({
                errors: error.details.map(d => ({ field: d.path.join('.'), message: d.message }))
            });
        }
        req.body = value;
        next();
    };
}

export { userSchema, validate };
`;
    }
}

export const validationGenerator = ValidationGenerator.getInstance();
