/**
 * üó≥Ô∏è VotingSystemGenerator
 * 
 * Voting & polling:
 * - Upvotes, polls, rankings
 */

import { EventEmitter } from 'events';

export class VotingSystemGenerator extends EventEmitter {
    private static instance: VotingSystemGenerator;
    private constructor() { super(); }
    static getInstance(): VotingSystemGenerator {
        if (!VotingSystemGenerator.instance) {
            VotingSystemGenerator.instance = new VotingSystemGenerator();
        }
        return VotingSystemGenerator.instance;
    }

    generate(): string {
        return `// Voting System Generator - Upvotes, polls, rankings
// Generated by Shadow AI

// Vote Schema
model Vote {
    id        String   @id @default(cuid())
    value     Int      // 1 for upvote, -1 for downvote
    userId    String
    itemId    String
    itemType  String
    createdAt DateTime @default(now())
    @@unique([userId, itemId, itemType])
}

// Poll Schema
model Poll {
    id        String       @id @default(cuid())
    question  String
    options   PollOption[]
    multiSelect Boolean    @default(false)
    endsAt    DateTime?
    createdAt DateTime     @default(now())
}

model PollOption {
    id     String     @id @default(cuid())
    text   String
    pollId String
    poll   Poll       @relation(fields: [pollId], references: [id])
    votes  PollVote[]
}

model PollVote {
    id       String     @id @default(cuid())
    userId   String
    optionId String
    option   PollOption @relation(fields: [optionId], references: [id])
    @@unique([userId, optionId])
}

// Voting Service
class VotingService {
    async vote(userId: string, itemId: string, itemType: string, value: 1 | -1) {
        const existing = await prisma.vote.findUnique({
            where: { userId_itemId_itemType: { userId, itemId, itemType } }
        });
        
        if (existing?.value === value) {
            // Remove vote if same value
            await prisma.vote.delete({ where: { id: existing.id } });
            return { action: 'removed' };
        }
        
        await prisma.vote.upsert({
            where: { userId_itemId_itemType: { userId, itemId, itemType } },
            create: { userId, itemId, itemType, value },
            update: { value }
        });
        
        return { action: existing ? 'changed' : 'added', value };
    }
    
    async getScore(itemId: string, itemType: string): Promise<number> {
        const result = await prisma.vote.aggregate({
            where: { itemId, itemType },
            _sum: { value: true }
        });
        return result._sum.value || 0;
    }
    
    async getUserVote(userId: string, itemId: string, itemType: string) {
        const vote = await prisma.vote.findUnique({
            where: { userId_itemId_itemType: { userId, itemId, itemType } }
        });
        return vote?.value || 0;
    }
}

// Poll Service
class PollService {
    async createPoll(question: string, options: string[], settings?: { multiSelect?: boolean; endsAt?: Date }) {
        return prisma.poll.create({
            data: {
                question,
                multiSelect: settings?.multiSelect || false,
                endsAt: settings?.endsAt,
                options: {
                    createMany: { data: options.map(text => ({ text })) }
                }
            },
            include: { options: true }
        });
    }
    
    async votePoll(userId: string, optionId: string) {
        const option = await prisma.pollOption.findUnique({
            where: { id: optionId },
            include: { poll: true }
        });
        
        if (!option?.poll.multiSelect) {
            // Remove existing votes for this poll
            await prisma.pollVote.deleteMany({
                where: { userId, option: { pollId: option.poll.id } }
            });
        }
        
        return prisma.pollVote.create({
            data: { userId, optionId }
        });
    }
    
    async getPollResults(pollId: string) {
        const poll = await prisma.poll.findUnique({
            where: { id: pollId },
            include: {
                options: {
                    include: { _count: { select: { votes: true } } }
                }
            }
        });
        
        const totalVotes = poll?.options.reduce((sum, o) => sum + o._count.votes, 0) || 0;
        
        return poll?.options.map(o => ({
            ...o,
            votes: o._count.votes,
            percentage: totalVotes > 0 ? (o._count.votes / totalVotes) * 100 : 0
        }));
    }
}

export { VotingService, PollService };
`;
    }
}

export const votingSystemGenerator = VotingSystemGenerator.getInstance();
