/**
 * ðŸ’š Vue Generator
 * 
 * Generate Vue 3 code:
 * - Composition API, Pinia, components
 */

import { EventEmitter } from 'events';

export class VueGenerator extends EventEmitter {
    private static instance: VueGenerator;

    private constructor() { super(); }

    static getInstance(): VueGenerator {
        if (!VueGenerator.instance) {
            VueGenerator.instance = new VueGenerator();
        }
        return VueGenerator.instance;
    }

    generateApp(): string {
        return `// Vue 3 App Structure
// Generated by Shadow AI

// main.ts
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import { createRouter, createWebHistory } from 'vue-router'
import App from './App.vue'

const pinia = createPinia()

const router = createRouter({
    history: createWebHistory(),
    routes: [
        { path: '/', name: 'Home', component: () => import('./views/Home.vue') },
        { path: '/about', name: 'About', component: () => import('./views/About.vue') },
        { path: '/dashboard', name: 'Dashboard', component: () => import('./views/Dashboard.vue'), meta: { requiresAuth: true } }
    ]
})

router.beforeEach((to, from, next) => {
    const authStore = useAuthStore()
    if (to.meta.requiresAuth && !authStore.isAuthenticated) {
        next('/login')
    } else {
        next()
    }
})

const app = createApp(App)
app.use(pinia)
app.use(router)
app.mount('#app')

// App.vue
<script setup lang="ts">
import { RouterView } from 'vue-router'
import TheHeader from './components/TheHeader.vue'
import TheFooter from './components/TheFooter.vue'
</script>

<template>
    <div id="app">
        <TheHeader />
        <main>
            <RouterView v-slot="{ Component }">
                <Transition name="fade" mode="out-in">
                    <component :is="Component" />
                </Transition>
            </RouterView>
        </main>
        <TheFooter />
    </div>
</template>

<style>
.fade-enter-active, .fade-leave-active {
    transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
    opacity: 0;
}
</style>
`;
    }

    generateComponent(name: string): string {
        return `// ${name}.vue
<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { use${name}Store } from '@/stores/${name.toLowerCase()}'

// Props
interface Props {
    id?: string
    title?: string
}
const props = withDefaults(defineProps<Props>(), {
    title: 'Default Title'
})

// Emits
const emit = defineEmits<{
    (e: 'update', value: string): void
    (e: 'delete', id: string): void
}>()

// Store
const store = use${name}Store()

// Reactive state
const isLoading = ref(false)
const error = ref<Error | null>(null)
const items = ref<any[]>([])

// Computed
const filteredItems = computed(() => {
    return items.value.filter(item => item.active)
})

// Methods
async function fetchData() {
    isLoading.value = true
    error.value = null
    try {
        items.value = await store.fetchItems()
    } catch (e) {
        error.value = e as Error
    } finally {
        isLoading.value = false
    }
}

function handleClick(item: any) {
    emit('update', item.id)
}

// Lifecycle
onMounted(() => {
    fetchData()
})

// Watchers
watch(() => props.id, (newId) => {
    if (newId) fetchData()
})
</script>

<template>
    <div class="${name.toLowerCase()}">
        <h2>{{ props.title }}</h2>
        
        <div v-if="isLoading" class="loading">Loading...</div>
        <div v-else-if="error" class="error">{{ error.message }}</div>
        
        <ul v-else>
            <li v-for="item in filteredItems" :key="item.id" @click="handleClick(item)">
                {{ item.name }}
            </li>
        </ul>
        
        <slot name="actions" />
    </div>
</template>

<style scoped>
.${name.toLowerCase()} {
    padding: 1rem;
}
.loading, .error {
    text-align: center;
    padding: 2rem;
}
.error {
    color: red;
}
</style>
`;
    }

    generatePiniaStore(name: string): string {
        return `// ${name}Store.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const use${name}Store = defineStore('${name.toLowerCase()}', () => {
    // State
    const items = ref<any[]>([])
    const isLoading = ref(false)
    const error = ref<Error | null>(null)
    const currentItem = ref<any | null>(null)

    // Getters
    const count = computed(() => items.value.length)
    const activeItems = computed(() => items.value.filter(i => i.active))

    // Actions
    async function fetchItems() {
        isLoading.value = true
        error.value = null
        try {
            const response = await fetch('/api/${name.toLowerCase()}s')
            items.value = await response.json()
            return items.value
        } catch (e) {
            error.value = e as Error
            throw e
        } finally {
            isLoading.value = false
        }
    }

    async function fetchById(id: string) {
        isLoading.value = true
        try {
            const response = await fetch(\`/api/${name.toLowerCase()}s/\${id}\`)
            currentItem.value = await response.json()
            return currentItem.value
        } finally {
            isLoading.value = false
        }
    }

    async function create(data: any) {
        const response = await fetch('/api/${name.toLowerCase()}s', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        })
        const newItem = await response.json()
        items.value.push(newItem)
        return newItem
    }

    async function update(id: string, data: any) {
        const response = await fetch(\`/api/${name.toLowerCase()}s/\${id}\`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        })
        const updated = await response.json()
        const index = items.value.findIndex(i => i.id === id)
        if (index !== -1) items.value[index] = updated
        return updated
    }

    async function remove(id: string) {
        await fetch(\`/api/${name.toLowerCase()}s/\${id}\`, { method: 'DELETE' })
        items.value = items.value.filter(i => i.id !== id)
    }

    function $reset() {
        items.value = []
        isLoading.value = false
        error.value = null
        currentItem.value = null
    }

    return {
        items, isLoading, error, currentItem,
        count, activeItems,
        fetchItems, fetchById, create, update, remove, $reset
    }
})
`;
    }

    generateComposable(name: string): string {
        return `// use${name}.ts
import { ref, onMounted, onUnmounted, watch, type Ref } from 'vue'

export function use${name}(initialValue?: any) {
    const value = ref(initialValue)
    const loading = ref(false)
    const error = ref<Error | null>(null)

    async function execute<T>(fn: () => Promise<T>): Promise<T> {
        loading.value = true
        error.value = null
        try {
            const result = await fn()
            return result
        } catch (e) {
            error.value = e as Error
            throw e
        } finally {
            loading.value = false
        }
    }

    function reset() {
        value.value = initialValue
        error.value = null
    }

    return { value, loading, error, execute, reset }
}

// useDebounce
export function useDebounce<T>(value: Ref<T>, delay = 300) {
    const debouncedValue = ref(value.value) as Ref<T>
    let timeout: ReturnType<typeof setTimeout>

    watch(value, (newVal) => {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
            debouncedValue.value = newVal
        }, delay)
    })

    return debouncedValue
}

// useLocalStorage
export function useLocalStorage<T>(key: string, defaultValue: T) {
    const stored = localStorage.getItem(key)
    const value = ref<T>(stored ? JSON.parse(stored) : defaultValue)

    watch(value, (newVal) => {
        localStorage.setItem(key, JSON.stringify(newVal))
    }, { deep: true })

    return value
}

// useEventListener
export function useEventListener(
    target: EventTarget,
    event: string,
    handler: EventListener
) {
    onMounted(() => target.addEventListener(event, handler))
    onUnmounted(() => target.removeEventListener(event, handler))
}
`;
    }
}

export const vueGenerator = VueGenerator.getInstance();
