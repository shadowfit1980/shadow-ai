/**
 * ⛓️ Web3 Generator
 * 
 * Generate blockchain/Web3 code:
 * - ethers.js, wagmi, wallet connection
 */

import { EventEmitter } from 'events';

export class Web3Generator extends EventEmitter {
    private static instance: Web3Generator;

    private constructor() { super(); }

    static getInstance(): Web3Generator {
        if (!Web3Generator.instance) {
            Web3Generator.instance = new Web3Generator();
        }
        return Web3Generator.instance;
    }

    generateWagmi(): string {
        return `// Wagmi Web3 Setup
// Generated by Shadow AI

import { WagmiProvider, createConfig, http, useAccount, useConnect, useDisconnect, useBalance, useReadContract, useWriteContract } from 'wagmi';
import { mainnet, polygon, arbitrum, optimism, base } from 'wagmi/chains';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ConnectKitProvider, ConnectKitButton, getDefaultConfig } from 'connectkit';

// Config
const config = createConfig(
    getDefaultConfig({
        chains: [mainnet, polygon, arbitrum, optimism, base],
        transports: {
            [mainnet.id]: http(\`https://eth-mainnet.g.alchemy.com/v2/\${process.env.NEXT_PUBLIC_ALCHEMY_KEY}\`),
            [polygon.id]: http(\`https://polygon-mainnet.g.alchemy.com/v2/\${process.env.NEXT_PUBLIC_ALCHEMY_KEY}\`),
            [arbitrum.id]: http(),
            [optimism.id]: http(),
            [base.id]: http()
        },
        walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!,
        appName: 'My DApp',
        appDescription: 'A decentralized application',
        appUrl: 'https://myapp.com',
        appIcon: 'https://myapp.com/logo.png'
    })
);

const queryClient = new QueryClient();

// Provider
function Web3Provider({ children }: { children: React.ReactNode }) {
    return (
        <WagmiProvider config={config}>
            <QueryClientProvider client={queryClient}>
                <ConnectKitProvider theme="auto" mode="auto">
                    {children}
                </ConnectKitProvider>
            </QueryClientProvider>
        </WagmiProvider>
    );
}

// Wallet Connection Component
function WalletConnect() {
    const { address, isConnected, chain } = useAccount();
    const { disconnect } = useDisconnect();
    const { data: balance } = useBalance({ address });

    if (!isConnected) {
        return <ConnectKitButton />;
    }

    return (
        <div className="wallet-info">
            <span>{chain?.name}</span>
            <span>{address?.slice(0, 6)}...{address?.slice(-4)}</span>
            <span>{balance?.formatted} {balance?.symbol}</span>
            <button onClick={() => disconnect()}>Disconnect</button>
        </div>
    );
}

// Read Contract Hook
const ERC20_ABI = [
    { name: 'balanceOf', type: 'function', stateMutability: 'view', inputs: [{ name: 'owner', type: 'address' }], outputs: [{ type: 'uint256' }] },
    { name: 'transfer', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }], outputs: [{ type: 'bool' }] },
    { name: 'approve', type: 'function', stateMutability: 'nonpayable', inputs: [{ name: 'spender', type: 'address' }, { name: 'amount', type: 'uint256' }], outputs: [{ type: 'bool' }] }
] as const;

function useTokenBalance(tokenAddress: \`0x\${string}\`, userAddress?: \`0x\${string}\`) {
    return useReadContract({
        address: tokenAddress,
        abi: ERC20_ABI,
        functionName: 'balanceOf',
        args: userAddress ? [userAddress] : undefined,
        query: { enabled: !!userAddress }
    });
}

// Write Contract Hook
function useTransferToken(tokenAddress: \`0x\${string}\`) {
    const { writeContract, isPending, isSuccess, error } = useWriteContract();

    const transfer = (to: \`0x\${string}\`, amount: bigint) => {
        writeContract({
            address: tokenAddress,
            abi: ERC20_ABI,
            functionName: 'transfer',
            args: [to, amount]
        });
    };

    return { transfer, isPending, isSuccess, error };
}

export { Web3Provider, WalletConnect, useTokenBalance, useTransferToken, ERC20_ABI };
`;
    }

    generateEthers(): string {
        return `// Ethers.js Utilities
// Generated by Shadow AI

import { ethers, Contract, formatEther, parseEther, formatUnits, parseUnits } from 'ethers';

// Provider setup
function getProvider() {
    if (typeof window !== 'undefined' && window.ethereum) {
        return new ethers.BrowserProvider(window.ethereum);
    }
    return new ethers.JsonRpcProvider(process.env.RPC_URL);
}

// Contract interaction
async function getContract(address: string, abi: any[], withSigner = false) {
    const provider = getProvider();
    if (withSigner) {
        const signer = await (provider as ethers.BrowserProvider).getSigner();
        return new Contract(address, abi, signer);
    }
    return new Contract(address, abi, provider);
}

// Wallet utilities
async function connectWallet() {
    if (!window.ethereum) throw new Error('No wallet found');
    
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    return accounts[0];
}

async function getBalance(address: string) {
    const provider = getProvider();
    const balance = await provider.getBalance(address);
    return formatEther(balance);
}

async function sendTransaction(to: string, amount: string) {
    const provider = getProvider() as ethers.BrowserProvider;
    const signer = await provider.getSigner();
    
    const tx = await signer.sendTransaction({
        to,
        value: parseEther(amount)
    });
    
    return tx.wait();
}

// Sign message
async function signMessage(message: string) {
    const provider = getProvider() as ethers.BrowserProvider;
    const signer = await provider.getSigner();
    return signer.signMessage(message);
}

// Verify signature
function verifyMessage(message: string, signature: string) {
    return ethers.verifyMessage(message, signature);
}

// ERC20 helpers
async function getTokenInfo(tokenAddress: string) {
    const abi = ['function name() view returns (string)', 'function symbol() view returns (string)', 'function decimals() view returns (uint8)', 'function totalSupply() view returns (uint256)'];
    const contract = await getContract(tokenAddress, abi);
    
    const [name, symbol, decimals, totalSupply] = await Promise.all([
        contract.name(),
        contract.symbol(),
        contract.decimals(),
        contract.totalSupply()
    ]);
    
    return { name, symbol, decimals, totalSupply: formatUnits(totalSupply, decimals) };
}

// NFT helpers
async function getNFTMetadata(contractAddress: string, tokenId: number) {
    const abi = ['function tokenURI(uint256) view returns (string)', 'function ownerOf(uint256) view returns (address)'];
    const contract = await getContract(contractAddress, abi);
    
    const [tokenURI, owner] = await Promise.all([
        contract.tokenURI(tokenId),
        contract.ownerOf(tokenId)
    ]);
    
    const metadata = await fetch(tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/')).then(r => r.json());
    return { ...metadata, owner };
}

export { getProvider, getContract, connectWallet, getBalance, sendTransaction, signMessage, verifyMessage, getTokenInfo, getNFTMetadata };
`;
    }
}

export const web3Generator = Web3Generator.getInstance();
