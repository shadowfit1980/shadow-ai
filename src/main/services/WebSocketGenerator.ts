/**
 * ðŸ”Œ WebSocket Generator
 * 
 * Generate WebSocket servers:
 * - Socket.io, WS patterns
 */

import { EventEmitter } from 'events';

export class WebSocketGenerator extends EventEmitter {
    private static instance: WebSocketGenerator;

    private constructor() { super(); }

    static getInstance(): WebSocketGenerator {
        if (!WebSocketGenerator.instance) {
            WebSocketGenerator.instance = new WebSocketGenerator();
        }
        return WebSocketGenerator.instance;
    }

    generateSocketIO(): string {
        return `// Socket.io Server
// Generated by Shadow AI

import { Server } from 'socket.io';
import { createServer } from 'http';
import jwt from 'jsonwebtoken';

const httpServer = createServer();
const io = new Server(httpServer, {
    cors: { origin: process.env.FRONTEND_URL || '*', credentials: true },
    pingTimeout: 60000,
    pingInterval: 25000
});

// Types
interface User { id: string; name: string; room?: string; }
interface Message { id: string; userId: string; content: string; timestamp: Date; }

// State
const users = new Map<string, User>();
const rooms = new Map<string, Set<string>>();

// Authentication Middleware
io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    if (!token) return next(new Error('Authentication required'));
    
    try {
        const payload = jwt.verify(token, process.env.JWT_SECRET!) as any;
        socket.data.user = payload;
        next();
    } catch (error) {
        next(new Error('Invalid token'));
    }
});

io.on('connection', (socket) => {
    const userId = socket.data.user.id;
    console.log(\`User connected: \${userId}\`);

    // Store user
    users.set(socket.id, { id: userId, name: socket.data.user.name });

    // Join Room
    socket.on('join:room', (roomId: string) => {
        socket.join(roomId);
        
        if (!rooms.has(roomId)) rooms.set(roomId, new Set());
        rooms.get(roomId)!.add(socket.id);
        
        const user = users.get(socket.id)!;
        user.room = roomId;
        
        // Notify others
        socket.to(roomId).emit('user:joined', { user, roomId });
        
        // Send room members
        const members = Array.from(rooms.get(roomId)!).map(id => users.get(id));
        socket.emit('room:members', members);
    });

    // Leave Room
    socket.on('leave:room', (roomId: string) => {
        socket.leave(roomId);
        rooms.get(roomId)?.delete(socket.id);
        
        const user = users.get(socket.id)!;
        user.room = undefined;
        
        socket.to(roomId).emit('user:left', { userId, roomId });
    });

    // Chat Message
    socket.on('message:send', (data: { roomId: string; content: string }) => {
        const message: Message = {
            id: Date.now().toString(),
            userId,
            content: data.content,
            timestamp: new Date()
        };
        
        io.to(data.roomId).emit('message:new', message);
    });

    // Typing Indicator
    socket.on('typing:start', (roomId: string) => {
        socket.to(roomId).emit('user:typing', { userId, isTyping: true });
    });

    socket.on('typing:stop', (roomId: string) => {
        socket.to(roomId).emit('user:typing', { userId, isTyping: false });
    });

    // Direct Message
    socket.on('dm:send', (data: { toUserId: string; content: string }) => {
        const targetSocket = Array.from(users.entries())
            .find(([_, user]) => user.id === data.toUserId)?.[0];
        
        if (targetSocket) {
            io.to(targetSocket).emit('dm:new', {
                fromUserId: userId,
                content: data.content,
                timestamp: new Date()
            });
        }
    });

    // Presence
    socket.on('presence:update', (status: 'online' | 'away' | 'busy') => {
        io.emit('user:presence', { userId, status });
    });

    // Disconnect
    socket.on('disconnect', () => {
        const user = users.get(socket.id);
        if (user?.room) {
            socket.to(user.room).emit('user:left', { userId, roomId: user.room });
            rooms.get(user.room)?.delete(socket.id);
        }
        users.delete(socket.id);
        console.log(\`User disconnected: \${userId}\`);
    });
});

// Broadcast to all or specific rooms
function broadcast(event: string, data: any, roomId?: string) {
    if (roomId) {
        io.to(roomId).emit(event, data);
    } else {
        io.emit(event, data);
    }
}

httpServer.listen(3001, () => console.log('WebSocket server on port 3001'));

export { io, broadcast };
`;
    }

    generateWSClient(): string {
        return `// WebSocket Client
// Generated by Shadow AI

import { io, Socket } from 'socket.io-client';

class WebSocketClient {
    private socket: Socket | null = null;
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private listeners = new Map<string, Set<Function>>();

    connect(url: string, token: string) {
        this.socket = io(url, {
            auth: { token },
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            timeout: 20000
        });

        this.socket.on('connect', () => {
            console.log('Connected to WebSocket');
            this.reconnectAttempts = 0;
            this.emit('connected');
        });

        this.socket.on('disconnect', (reason) => {
            console.log('Disconnected:', reason);
            this.emit('disconnected', reason);
        });

        this.socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            this.reconnectAttempts++;
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                this.emit('connection_failed');
            }
        });

        // Forward all events to local listeners
        this.socket.onAny((event, ...args) => {
            this.emit(event, ...args);
        });

        return this;
    }

    disconnect() {
        this.socket?.disconnect();
        this.socket = null;
    }

    // Room management
    joinRoom(roomId: string) {
        this.socket?.emit('join:room', roomId);
    }

    leaveRoom(roomId: string) {
        this.socket?.emit('leave:room', roomId);
    }

    // Messaging
    sendMessage(roomId: string, content: string) {
        this.socket?.emit('message:send', { roomId, content });
    }

    sendDM(toUserId: string, content: string) {
        this.socket?.emit('dm:send', { toUserId, content });
    }

    // Typing
    startTyping(roomId: string) {
        this.socket?.emit('typing:start', roomId);
    }

    stopTyping(roomId: string) {
        this.socket?.emit('typing:stop', roomId);
    }

    // Presence
    setPresence(status: 'online' | 'away' | 'busy') {
        this.socket?.emit('presence:update', status);
    }

    // Event system
    on(event: string, callback: Function) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event)!.add(callback);
        return () => this.off(event, callback);
    }

    off(event: string, callback: Function) {
        this.listeners.get(event)?.delete(callback);
    }

    private emit(event: string, ...args: any[]) {
        this.listeners.get(event)?.forEach(cb => cb(...args));
    }
}

// React Hook
function useWebSocket(url: string, token: string) {
    const clientRef = useRef<WebSocketClient | null>(null);
    const [connected, setConnected] = useState(false);
    const [messages, setMessages] = useState<Message[]>([]);

    useEffect(() => {
        const client = new WebSocketClient();
        client.connect(url, token);
        clientRef.current = client;

        client.on('connected', () => setConnected(true));
        client.on('disconnected', () => setConnected(false));
        client.on('message:new', (msg: Message) => {
            setMessages(prev => [...prev, msg]);
        });

        return () => client.disconnect();
    }, [url, token]);

    const sendMessage = useCallback((roomId: string, content: string) => {
        clientRef.current?.sendMessage(roomId, content);
    }, []);

    return { connected, messages, sendMessage, client: clientRef.current };
}

export { WebSocketClient, useWebSocket };
`;
    }
}

export const webSocketGenerator = WebSocketGenerator.getInstance();
