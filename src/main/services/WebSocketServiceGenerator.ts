/**
 * ðŸ”„ WebSocketServiceGenerator
 * 
 * WebSocket services:
 * - Socket.IO, rooms, events
 */

import { EventEmitter } from 'events';

export class WebSocketServiceGenerator extends EventEmitter {
    private static instance: WebSocketServiceGenerator;
    private constructor() { super(); }
    static getInstance(): WebSocketServiceGenerator {
        if (!WebSocketServiceGenerator.instance) {
            WebSocketServiceGenerator.instance = new WebSocketServiceGenerator();
        }
        return WebSocketServiceGenerator.instance;
    }

    generate(): string {
        return `// WebSocket Service Generator - Socket.IO, rooms, events
// Generated by Shadow AI

import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { Redis } from 'ioredis';

class WebSocketService {
    private io: Server;
    
    constructor(httpServer: any) {
        this.io = new Server(httpServer, {
            cors: { origin: '*' },
            transports: ['websocket', 'polling']
        });
        
        // Redis adapter for scaling
        if (process.env.REDIS_URL) {
            const pubClient = new Redis(process.env.REDIS_URL);
            const subClient = pubClient.duplicate();
            this.io.adapter(createAdapter(pubClient, subClient));
        }
        
        this.setupHandlers();
    }
    
    private setupHandlers() {
        this.io.use(async (socket, next) => {
            try {
                const token = socket.handshake.auth.token;
                const user = await verifyToken(token);
                socket.data.user = user;
                next();
            } catch (error) {
                next(new Error('Authentication error'));
            }
        });
        
        this.io.on('connection', (socket) => {
            console.log(\`User connected: \${socket.data.user.id}\`);
            
            // Join user's personal room
            socket.join(\`user:\${socket.data.user.id}\`);
            
            // Handle events
            socket.on('join:room', (roomId) => {
                socket.join(roomId);
                socket.to(roomId).emit('user:joined', socket.data.user);
            });
            
            socket.on('leave:room', (roomId) => {
                socket.leave(roomId);
                socket.to(roomId).emit('user:left', socket.data.user);
            });
            
            socket.on('message', (data) => {
                this.io.to(data.roomId).emit('message', {
                    ...data,
                    userId: socket.data.user.id,
                    timestamp: new Date()
                });
            });
            
            socket.on('typing', (roomId) => {
                socket.to(roomId).emit('user:typing', socket.data.user);
            });
            
            socket.on('disconnect', () => {
                console.log(\`User disconnected: \${socket.data.user.id}\`);
            });
        });
    }
    
    // Emit to specific user
    emitToUser(userId: string, event: string, data: any) {
        this.io.to(\`user:\${userId}\`).emit(event, data);
    }
    
    // Emit to room
    emitToRoom(roomId: string, event: string, data: any) {
        this.io.to(roomId).emit(event, data);
    }
    
    // Broadcast to all
    broadcast(event: string, data: any) {
        this.io.emit(event, data);
    }
    
    // Get connected users in room
    async getUsersInRoom(roomId: string) {
        const sockets = await this.io.in(roomId).fetchSockets();
        return sockets.map(s => s.data.user);
    }
}

// React Hook
export function useWebSocket(url: string) {
    const [connected, setConnected] = useState(false);
    const socketRef = useRef<Socket | null>(null);
    
    useEffect(() => {
        socketRef.current = io(url, { auth: { token: getAuthToken() } });
        
        socketRef.current.on('connect', () => setConnected(true));
        socketRef.current.on('disconnect', () => setConnected(false));
        
        return () => { socketRef.current?.disconnect(); };
    }, [url]);
    
    const emit = (event: string, data: any) => {
        socketRef.current?.emit(event, data);
    };
    
    const on = (event: string, handler: (data: any) => void) => {
        socketRef.current?.on(event, handler);
    };
    
    return { connected, emit, on, socket: socketRef.current };
}

export { WebSocketService, useWebSocket };
`;
    }
}

export const webSocketServiceGenerator = WebSocketServiceGenerator.getInstance();
