/**
 * ðŸ”— WebhookDispatcher
 * 
 * Webhook dispatching:
 * - Events, retry, delivery tracking
 */

import { EventEmitter } from 'events';

export class WebhookDispatcher extends EventEmitter {
    private static instance: WebhookDispatcher;
    private constructor() { super(); }
    static getInstance(): WebhookDispatcher {
        if (!WebhookDispatcher.instance) {
            WebhookDispatcher.instance = new WebhookDispatcher();
        }
        return WebhookDispatcher.instance;
    }

    generate(): string {
        return `// Webhook Dispatcher - Events, retry, delivery tracking
// Generated by Shadow AI

// Webhook Schema
model WebhookEndpoint {
    id          String   @id @default(cuid())
    url         String
    secret      String
    events      String[] // ['order.created', 'user.updated']
    enabled     Boolean  @default(true)
    ownerId     String
    deliveries  WebhookDelivery[]
    createdAt   DateTime @default(now())
}

model WebhookDelivery {
    id          String   @id @default(cuid())
    endpointId  String
    endpoint    WebhookEndpoint @relation(fields: [endpointId], references: [id])
    event       String
    payload     Json
    status      DeliveryStatus @default(PENDING)
    statusCode  Int?
    response    String?
    attempts    Int      @default(0)
    nextRetry   DateTime?
    createdAt   DateTime @default(now())
    deliveredAt DateTime?
}

enum DeliveryStatus {
    PENDING
    SUCCESS
    FAILED
    RETRYING
}

// Webhook Dispatcher Service
class WebhookDispatcherService {
    async dispatch(event: string, payload: any) {
        const endpoints = await prisma.webhookEndpoint.findMany({
            where: { enabled: true, events: { has: event } }
        });
        
        for (const endpoint of endpoints) {
            await this.queueDelivery(endpoint, event, payload);
        }
    }
    
    private async queueDelivery(endpoint: WebhookEndpoint, event: string, payload: any) {
        const delivery = await prisma.webhookDelivery.create({
            data: {
                endpointId: endpoint.id,
                event,
                payload
            }
        });
        
        await this.deliver(delivery.id);
    }
    
    async deliver(deliveryId: string) {
        const delivery = await prisma.webhookDelivery.findUnique({
            where: { id: deliveryId },
            include: { endpoint: true }
        });
        
        if (!delivery) return;
        
        const signature = this.sign(delivery.payload, delivery.endpoint.secret);
        
        try {
            const response = await fetch(delivery.endpoint.url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Webhook-Signature': signature,
                    'X-Webhook-Event': delivery.event,
                    'X-Webhook-Delivery-Id': delivery.id
                },
                body: JSON.stringify(delivery.payload),
                signal: AbortSignal.timeout(30000)
            });
            
            await prisma.webhookDelivery.update({
                where: { id: deliveryId },
                data: {
                    status: response.ok ? 'SUCCESS' : 'FAILED',
                    statusCode: response.status,
                    response: await response.text(),
                    deliveredAt: response.ok ? new Date() : undefined,
                    attempts: { increment: 1 }
                }
            });
            
            if (!response.ok) {
                await this.scheduleRetry(deliveryId, delivery.attempts + 1);
            }
        } catch (error) {
            await prisma.webhookDelivery.update({
                where: { id: deliveryId },
                data: {
                    status: 'FAILED',
                    response: error.message,
                    attempts: { increment: 1 }
                }
            });
            
            await this.scheduleRetry(deliveryId, delivery.attempts + 1);
        }
    }
    
    private async scheduleRetry(deliveryId: string, attempts: number) {
        if (attempts >= 5) return; // Max retries
        
        const delays = [60, 300, 900, 3600, 7200]; // 1m, 5m, 15m, 1h, 2h
        const delay = delays[Math.min(attempts - 1, delays.length - 1)];
        
        await prisma.webhookDelivery.update({
            where: { id: deliveryId },
            data: {
                status: 'RETRYING',
                nextRetry: new Date(Date.now() + delay * 1000)
            }
        });
    }
    
    private sign(payload: any, secret: string): string {
        const hmac = crypto.createHmac('sha256', secret);
        hmac.update(JSON.stringify(payload));
        return hmac.digest('hex');
    }
}

// Webhook Management UI
export function WebhookManager({ ownerId }: { ownerId: string }) {
    const { data: endpoints } = useQuery(['webhooks', ownerId], () => getWebhooks(ownerId));
    
    return (
        <div className="webhook-manager">
            <h2>Webhooks</h2>
            <Button onClick={() => openCreateModal()}>Add Endpoint</Button>
            
            {endpoints?.map(endpoint => (
                <WebhookEndpointCard key={endpoint.id} endpoint={endpoint} />
            ))}
        </div>
    );
}

export { WebhookDispatcherService, WebhookManager };
`;
    }
}

export const webhookDispatcher = WebhookDispatcher.getInstance();
