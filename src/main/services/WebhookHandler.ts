/**
 * ðŸª Webhook Handler Generator
 * 
 * Generate webhook patterns:
 * - Receiving, verification, retry
 */

import { EventEmitter } from 'events';

export class WebhookHandler extends EventEmitter {
    private static instance: WebhookHandler;

    private constructor() { super(); }

    static getInstance(): WebhookHandler {
        if (!WebhookHandler.instance) {
            WebhookHandler.instance = new WebhookHandler();
        }
        return WebhookHandler.instance;
    }

    generate(): string {
        return `// Webhook Handler
// Generated by Shadow AI

import crypto from 'crypto';
import { Queue } from 'bullmq';

// Webhook verification
function verifySignature(payload: string, signature: string, secret: string, algorithm = 'sha256'): boolean {
    const expectedSignature = crypto.createHmac(algorithm, secret).update(payload).digest('hex');
    const providedSignature = signature.replace('sha256=', '');
    return crypto.timingSafeEqual(Buffer.from(expectedSignature), Buffer.from(providedSignature));
}

// Stripe webhook verification
function verifyStripeWebhook(payload: string, signature: string, secret: string) {
    const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
    return stripe.webhooks.constructEvent(payload, signature, secret);
}

// GitHub webhook verification
function verifyGitHubWebhook(payload: string, signature: string, secret: string): boolean {
    const sig = \`sha256=\${crypto.createHmac('sha256', secret).update(payload).digest('hex')}\`;
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(sig));
}

// Webhook queue for reliable processing
const webhookQueue = new Queue('webhooks', { connection: { host: 'localhost', port: 6379 } });

// Express webhook endpoint
import express from 'express';
const router = express.Router();

// Store raw body for signature verification
router.use('/webhooks', express.raw({ type: 'application/json' }));

router.post('/webhooks/:provider', async (req, res) => {
    const { provider } = req.params;
    const signature = req.headers['x-signature'] || req.headers['x-hub-signature-256'] || req.headers['stripe-signature'];
    const payload = req.body.toString();

    try {
        // Verify signature
        const secret = process.env[\`\${provider.toUpperCase()}_WEBHOOK_SECRET\`];
        if (!secret) throw new Error('Webhook secret not configured');

        let verified = false;
        switch (provider) {
            case 'stripe':
                verifyStripeWebhook(payload, signature as string, secret);
                verified = true;
                break;
            case 'github':
                verified = verifyGitHubWebhook(payload, signature as string, secret);
                break;
            default:
                verified = verifySignature(payload, signature as string, secret);
        }

        if (!verified) {
            return res.status(401).json({ error: 'Invalid signature' });
        }

        // Queue for processing (idempotent)
        const event = JSON.parse(payload);
        const jobId = event.id || crypto.randomUUID();

        await webhookQueue.add(provider, event, {
            jobId, // Prevents duplicate processing
            attempts: 3,
            backoff: { type: 'exponential', delay: 5000 }
        });

        // Acknowledge immediately
        res.status(200).json({ received: true });

    } catch (error: any) {
        console.error('Webhook error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Webhook processor
import { Worker } from 'bullmq';

const webhookWorker = new Worker('webhooks', async (job) => {
    const { name: provider, data: event } = job;

    switch (provider) {
        case 'stripe':
            await handleStripeEvent(event);
            break;
        case 'github':
            await handleGitHubEvent(event);
            break;
        default:
            console.log('Unknown webhook provider:', provider);
    }
}, { connection: { host: 'localhost', port: 6379 } });

async function handleStripeEvent(event: any) {
    switch (event.type) {
        case 'checkout.session.completed':
            await handleCheckoutComplete(event.data.object);
            break;
        case 'customer.subscription.updated':
            await handleSubscriptionUpdate(event.data.object);
            break;
        case 'invoice.payment_failed':
            await handlePaymentFailed(event.data.object);
            break;
    }
}

async function handleGitHubEvent(event: any) {
    const eventType = event.action ? \`\${event.type}.\${event.action}\` : event.type;
    
    switch (eventType) {
        case 'push':
            await handlePush(event);
            break;
        case 'pull_request.opened':
            await handlePROpened(event);
            break;
        case 'issues.opened':
            await handleIssueOpened(event);
            break;
    }
}

// Outgoing webhooks
async function sendWebhook(url: string, payload: object, secret?: string) {
    const body = JSON.stringify(payload);
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };

    if (secret) {
        headers['X-Signature'] = \`sha256=\${crypto.createHmac('sha256', secret).update(body).digest('hex')}\`;
    }

    const response = await fetch(url, { method: 'POST', headers, body });

    if (!response.ok) {
        throw new Error(\`Webhook failed: \${response.status}\`);
    }

    return response.json();
}

// Retry with exponential backoff
async function sendWithRetry(url: string, payload: object, maxRetries = 3) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            return await sendWebhook(url, payload);
        } catch (error) {
            if (attempt === maxRetries - 1) throw error;
            await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 1000));
        }
    }
}

export { verifySignature, verifyStripeWebhook, verifyGitHubWebhook, sendWebhook, sendWithRetry, router as webhookRouter };
`;
    }
}

export const webhookHandler = WebhookHandler.getInstance();
